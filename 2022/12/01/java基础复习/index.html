<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>java复习笔记1 | 邦尼的博客</title><meta name="author" content="邦尼"><meta name="copyright" content="邦尼"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="java基础复习开发者客栈-帮助开发者面试的平台-顽强网络 (developers.pub)&lt;br &#x2F;&gt;http:&#x2F;&#x2F;c.biancheng.net&#x2F;java&#x2F;10&#x2F;&lt;br &#x2F;&gt;Java 语言是一种分布式的面向对象语言，具有面向对象、平台无关性、简单性、解释执行、多线程、安全性等很多特点&lt;a name&#x3D;&quot;bXuoh&quot;&gt;&lt;&#x2F;a&gt; 1">
<meta property="og:type" content="article">
<meta property="og:title" content="java复习笔记1">
<meta property="og:url" content="https://xyylegend.github.io/2022/12/01/java%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A0/index.html">
<meta property="og:site_name" content="邦尼的博客">
<meta property="og:description" content="java基础复习开发者客栈-帮助开发者面试的平台-顽强网络 (developers.pub)&lt;br &#x2F;&gt;http:&#x2F;&#x2F;c.biancheng.net&#x2F;java&#x2F;10&#x2F;&lt;br &#x2F;&gt;Java 语言是一种分布式的面向对象语言，具有面向对象、平台无关性、简单性、解释执行、多线程、安全性等很多特点&lt;a name&#x3D;&quot;bXuoh&quot;&gt;&lt;&#x2F;a&gt; 1">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/xyylegend/picgo_photo/imgs/05.webp">
<meta property="article:published_time" content="2022-12-01T12:22:33.000Z">
<meta property="article:modified_time" content="2022-12-01T13:40:53.781Z">
<meta property="article:author" content="邦尼">
<meta property="article:tag" content="java">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/xyylegend/picgo_photo/imgs/05.webp"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://xyylegend.github.io/2022/12/01/java%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A0/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'java复习笔记1',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-12-01 21:40:53'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><div class="aplayer no-destroy" data-id="3136952023" data-server="netease" data-type="playlist" data-fixed="true" data-autoplay="true"> </div><link rel="stylesheet" href="/css/ls.css"><link rel="stylesheet" href="/css/mouse.css"><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/./img/toux.webp" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">12</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">6</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 娱乐</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://cdn.jsdelivr.net/gh/xyylegend/picgo_photo/imgs/05.webp')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">邦尼的博客</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 娱乐</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">java复习笔记1</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-12-01T12:22:33.000Z" title="发表于 2022-12-01 20:22:33">2022-12-01</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-12-01T13:40:53.781Z" title="更新于 2022-12-01 21:40:53">2022-12-01</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/java/">java</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">21.9k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>76分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="java复习笔记1"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="java基础复习"><a href="#java基础复习" class="headerlink" title="java基础复习"></a><strong>java基础复习</strong></h1><p><a target="_blank" rel="noopener" href="https://www.developers.pub/wiki/1002310/1012017">开发者客栈-帮助开发者面试的平台-顽强网络 (developers.pub)</a><code>&lt;br /&gt;</code><a target="_blank" rel="noopener" href="http://c.biancheng.net/java/10/">http://c.biancheng.net/java/10/</a><code>&lt;br /&gt;</code><strong>Java 语言是一种分布式的面向对象语言，具有面向对象、平台无关性、简单性、解释执行、多线程、安全性等很多特点</strong><br><code>&lt;a name=&quot;bXuoh&quot;&gt;&lt;/a&gt;</code></p>
<h2 id="1-面向对象"><a href="#1-面向对象" class="headerlink" title="1. 面向对象"></a>1. 面向对象</h2><p>Java 是一种面向对象的语言，它对对象中的类、对象、继承、封装、多态、接口、包等均有很好的支持。为了简单起见，Java 只支持类之间的单继承，但是可以使用接口来实现多继承。<br><code>&lt;a name=&quot;DcKJf&quot;&gt;&lt;/a&gt;</code></p>
<h2 id="2-多线程"><a href="#2-多线程" class="headerlink" title="2. 多线程"></a>2. 多线程</h2><p>Java 语言是多线程的，这也是 Java 语言的一大特性，它必须由 Thread 类和它的子类来创建。Java 支持多个线程同时执行，并提供多线程之间的同步机制。任何一个线程都有自己的 run() 方法，要执行的方法就写在 run() 方法体内。<br><code>&lt;a name=&quot;hKtkN&quot;&gt;&lt;/a&gt;</code></p>
<h2 id="3-java中jvm-jre-jdk三者有什么区别"><a href="#3-java中jvm-jre-jdk三者有什么区别" class="headerlink" title="3.java中jvm ,jre,jdk三者有什么区别"></a>3.java中jvm ,jre,jdk三者有什么区别</h2><p><a target="_blank" rel="noopener" href="http://c.biancheng.net/java/">Java</a> 语言的开发运行，也离不开 Java 语言的运行环境 JRE。没有 JRE 的支持，Java 语言便无法运行。当然，如果还想编译 Java 程序，搞搞小开发的话，JRE 是明显不够了，这时候就需要 JDK。  <code>&lt;br /&gt;</code>其实啊，JDK 就是 JRE 加上一些常用工具组成的。JDK 不仅能运行已经被编译好了的 Java 程序，还能支持我们编译 Java 程序（JDK&#x3D;JER+各种工具）。</p>
<ul>
<li>JDK（Java Development Kid，Java 开发开源工具包），是针对 Java 开发人员的产品，是整个 Java 的核心，包括了 Java 运行环境 JRE、Java 工具和 Java 基础类库。</li>
<li>JRE（Java Runtime Environment，Java 运行环境）是运行 JAVA 程序所必须的环境的集合，包含 JVM 标准实现及 Java 核心类库。</li>
<li>JVM（Java Virtual Machine，Java 虚拟机）是整个 Java 实现跨平台的最核心的部分，能够运行以 Java 语言写作的软件程序。</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/33764834/1668330128204-7358e5f4-8f27-44ee-976b-53a0151c0af8.png#averageHue=%2392bf77&crop=0&crop=0&crop=1&crop=1&id=cxFcI&originHeight=346&originWidth=411&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><code>&lt;br /&gt;</code><img src="https://cdn.nlark.com/yuque/0/2022/png/33764834/1668330128666-9d7478b5-376a-49c6-9fb2-65fc65477ca8.png#averageHue=%2399a0eb&crop=0&crop=0&crop=1&crop=1&id=lD9Of&originHeight=275&originWidth=500&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<ul>
<li>JDK&#x3D;JRE+多种Java开发工具</li>
<li>JRE&#x3D;JVM+各种类库</li>
<li>这三者的关系是一层层的嵌套关系。JDK&gt;JRE&gt;JVM<br><code>&lt;a name=&quot;kd8EI&quot;&gt;&lt;/a&gt;</code></li>
</ul>
<h2 id="4-java初学者容易犯的几个问题"><a href="#4-java初学者容易犯的几个问题" class="headerlink" title="4.java初学者容易犯的几个问题"></a>4.java初学者容易犯的几个问题</h2><p><code>&lt;a name=&quot;XOnhn&quot;&gt;&lt;/a&gt;</code></p>
<h4 id="1）大小写问题"><a href="#1）大小写问题" class="headerlink" title="1）大小写问题"></a>1）大小写问题</h4><p><code>&lt;a name=&quot;1VdwB&quot;&gt;&lt;/a&gt;</code></p>
<h4 id="2）路径里包含空格的问题"><a href="#2）路径里包含空格的问题" class="headerlink" title="2）路径里包含空格的问题"></a>2）路径里包含空格的问题</h4><p><code>&lt;a name=&quot;O9tKO&quot;&gt;&lt;/a&gt;</code></p>
<h4 id="3）main-方法的问题"><a href="#3）main-方法的问题" class="headerlink" title="3）main 方法的问题"></a>3）main 方法的问题</h4><p>如果需要用 java 命令直接运行一个 Java 类，这个 Java 类必须包含 main 方法，这个 main 方法必须使用 public 和 static 来修饰，必须使用 void 声明该方法的返回值，而且该方法的参数类型只能是一个字符串数组，而不能是其他形式的参数。对于这个 main 方法而言，前面的 public 和 static 修饰符的位置可以互换，但其他部分则是固定的。  <code>&lt;br /&gt;</code>定义 main 方法时，不要写成 Main 方法，如果不小心把方法名的首字母写成了大写，编译时不会出现任何问题，但运行该程序时将给出如图 2 的错误提示：<code>&lt;br /&gt;</code>这个错误提示找不到 main 方法，因为 Java 虚拟机只会选择从 main 方法开始执行。对于 Main 方法，Java 虚拟机会把该方法当成一个普通方法，而不是程序的入口。  <code>&lt;br /&gt;</code>main 方法里可以放置程序员需要执行的可执行性语句，例如 System.out.println(“Hello Java!”)，这行语句是 Java 里的输出语句，用于向控制台输岀“Hello Java!”这个字符串内容，输出结束后还输出一个换行符。  <code>&lt;br /&gt;</code>在 Java 程序里执行输岀有两种简单的方式：System.out.print(需要输出的内容) 和 System.out.println (需要输出的内容)，其中前者在输出结束后不会换行，而后者在输出结束后会换行。后面会有关于这两个方法更详细的解释，此处读者只能把这两个方法先记下来。<br><code>&lt;a name=&quot;VgQOB&quot;&gt;&lt;/a&gt;</code></p>
<h2 id="5-String、StringBuffer和StringBuilder类的区别"><a href="#5-String、StringBuffer和StringBuilder类的区别" class="headerlink" title="5.String、StringBuffer和StringBuilder类的区别"></a>5.String、StringBuffer和StringBuilder类的区别</h2><p>在 <a target="_blank" rel="noopener" href="http://c.biancheng.net/java/">Java</a> 中字符串属于对象，Java 提供了 String 类来创建和操作字符串。String 类是不可变类，即一旦一个 String 对象被创建以后，包含在这个对象中的字符序列是不可改变的，直至这个对象被销毁。<code>&lt;br /&gt;</code>StringBuilder 类是 JDK 1.5 新增的类，它也代表可变字符串对象。实际上，StringBuilder 和 StringBuffer 功能基本相似，方法也差不多。不同的是，StringBuffer 是线程安全的，而 StringBuilder 则没有实现线程安全功能，所以性能略高。因此在通常情况下，如果需要创建一个内容可变的字符串对象，则应该优先考虑使用 StringBuilder 类。<br><code>&lt;a name=&quot;InBNA&quot;&gt;&lt;/a&gt;</code></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>String 是 Java 中基础且重要的类，被声明为 final class，是不可变字符串。因为它的不可变性，所以拼接字符串时候会产生很多无用的中间对象，如果频繁的进行这样的操作对性能有所影响。  <code>&lt;br /&gt;</code>StringBuffer 就是为了解决大量拼接字符串时产生很多中间对象问题而提供的一个类。它提供了 append 和 add 方法，可以将字符串添加到已有序列的末尾或指定位置，它的本质是一个线程安全的可修改的字符序列。  <code>&lt;br /&gt;</code>在很多情况下我们的字符串拼接操作不需要线程安全，所以 StringBuilder 登场了。StringBuilder 是 JDK1.5 发布的，它和 StringBuffer 本质上没什么区别，就是去掉了保证线程安全的那部分，减少了开销。<br><code>&lt;a name=&quot;aR8kQ&quot;&gt;&lt;/a&gt;</code></p>
<h4 id="线程安全："><a href="#线程安全：" class="headerlink" title="线程安全："></a>线程安全：</h4><p>StringBuffer：线程安全  <code>&lt;br /&gt;</code>StringBuilder：线程不安全<br><code>&lt;a name=&quot;T9tnt&quot;&gt;&lt;/a&gt;</code></p>
<h4 id="速度："><a href="#速度：" class="headerlink" title="速度："></a>速度：</h4><p>一般情况下，速度从快到慢为 StringBuilder &gt; StringBuffer &gt; String，当然这是相对的，不是绝对的。<br><code>&lt;a name=&quot;gdxSZ&quot;&gt;&lt;/a&gt;</code></p>
<h4 id="使用环境："><a href="#使用环境：" class="headerlink" title="使用环境："></a>使用环境：</h4><p>操作少量的数据使用 String。  <code>&lt;br /&gt;</code>单线程操作大量数据使用 StringBuilder。  <code>&lt;br /&gt;</code>多线程操作大量数据使用 StringBuffer。<code>&lt;br /&gt;</code>Java正则表达式详解<code>&lt;br /&gt;</code>正则表达式是一个强大的字符串处理工具，可以对字符串进行查找、提取、分割、替换等操作，是一种可以用于模式匹配和替换的规范。一个正则表达式就是由普通的字符（如字符 a~z）以及特殊字符（元字符）组成的文字模式，它用以描述在查找文字主体时待匹配的一个或多个字符串<code>&lt;br /&gt;</code>String 类里也提供了如下几个特殊的方法。</p>
<ul>
<li>boolean matches(String regex)：判断该字符串是否匹配指定的正则表达式。</li>
<li>String replaceAll(String regex, String replacement)：将该字符串中所有匹配 regex 的子串替换成 replacement。</li>
<li>String replaceFirst(String regex, String replacement)：将该字符串中第一个匹配 regex 的子串替换成 replacement。</li>
<li>String[] split(String regex)：以 regex 作为分隔符，把该字符串分割成多个子串。</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/33764834/1668330129341-57e584d0-eb34-42c9-985e-9511847b3e08.png#averageHue=%23f8f7f6&crop=0&crop=0&crop=1&crop=1&id=eQYRJ&originHeight=894&originWidth=1156&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><code>&lt;br /&gt;</code>如果需要匹配这些特殊字符，就必须首先将这些字符转义，也就是在前面添加一个反斜线&lt;br &#x2F;&gt;<img src="https://cdn.nlark.com/yuque/0/2022/png/33764834/1668330129792-e308d408-6618-4c8e-ac4b-ee5f41587e3c.png#averageHue=%23f3f2f1&crop=0&crop=0&crop=1&crop=1&id=euFcQ&originHeight=880&originWidth=1226&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><code>&lt;br /&gt;</code><img src="https://cdn.nlark.com/yuque/0/2022/png/33764834/1668330130272-4ae2f1c7-fad4-40b7-ad4b-25b9aafa8cbe.png#averageHue=%23f6f6f5&crop=0&crop=0&crop=1&crop=1&id=iturN&originHeight=611&originWidth=1160&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><code>&lt;br /&gt;</code>Math的方法<code>&lt;br /&gt;</code><img src="https://cdn.nlark.com/yuque/0/2022/png/33764834/1668330130845-13e43d91-6192-4892-9405-e6476266816b.png#averageHue=%23f7f6f5&crop=0&crop=0&crop=1&crop=1&id=C8dFL&originHeight=971&originWidth=1115&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><code>&lt;br /&gt;</code><img src="https://cdn.nlark.com/yuque/0/2022/png/33764834/1668330131357-19465d99-5c64-428a-803e-356a338e61e3.png#averageHue=%23f7f6f6&crop=0&crop=0&crop=1&crop=1&id=fC2ZP&originHeight=682&originWidth=1604&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><code>&lt;br /&gt;</code><img src="https://cdn.nlark.com/yuque/0/2022/png/33764834/1668330131733-ab6da237-7e6a-44f2-ae65-14413e4800cd.png#averageHue=%23f6f5f4&crop=0&crop=0&crop=1&crop=1&id=GzLWQ&originHeight=850&originWidth=1591&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br><code>&lt;a name=&quot;sFidm&quot;&gt;&lt;/a&gt;</code></p>
<h2 id="6-Java生成随机数（random-和Random类）"><a href="#6-Java生成随机数（random-和Random类）" class="headerlink" title="6.Java生成随机数（random()和Random类）"></a>6.Java生成随机数（random()和Random类）</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/33764834/1668330132385-c995f1d2-e4c9-443b-bdd3-89f22e5dc396.png#averageHue=%23f4f3f2&crop=0&crop=0&crop=1&crop=1&id=vG2qS&originHeight=853&originWidth=1305&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br><code>&lt;a name=&quot;WwmUn&quot;&gt;&lt;/a&gt;</code></p>
<h2 id="7-Java数字格式化"><a href="#7-Java数字格式化" class="headerlink" title="7.Java数字格式化"></a>7.Java数字格式化</h2><p><code>&lt;a name=&quot;pwkqM&quot;&gt;&lt;/a&gt;</code></p>
<h3 id="数字的格式在解决实际问题时使用非常普遍，这时可以使用-DedmalFormat-类对结果进行格式化处理"><a href="#数字的格式在解决实际问题时使用非常普遍，这时可以使用-DedmalFormat-类对结果进行格式化处理" class="headerlink" title="数字的格式在解决实际问题时使用非常普遍，这时可以使用 DedmalFormat 类对结果进行格式化处理"></a>数字的格式在解决实际问题时使用非常普遍，这时可以使用 DedmalFormat 类对结果进行格式化处理</h3><p><img src="https://cdn.nlark.com/yuque/0/2022/png/33764834/1668330132773-03067d3d-21f6-4b14-80f9-3cdd4d68d2e7.png#averageHue=%23f7f6f5&crop=0&crop=0&crop=1&crop=1&id=T9hT0&originHeight=715&originWidth=1233&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br><code>&lt;a name=&quot;wLude&quot;&gt;&lt;/a&gt;</code></p>
<h2 id="8-数组的总结"><a href="#8-数组的总结" class="headerlink" title="8.数组的总结"></a>8.数组的总结</h2><p><code>&lt;a name=&quot;O48LM&quot;&gt;&lt;/a&gt;</code></p>
<h3 id="数组操作"><a href="#数组操作" class="headerlink" title="数组操作"></a>数组操作</h3><p><code>&lt;a name=&quot;KyPW6&quot;&gt;&lt;/a&gt;</code></p>
<h4 id="1-比较数组"><a href="#1-比较数组" class="headerlink" title="1. 比较数组"></a>1. 比较数组</h4><p>比较数组元素的个数和对应位置的元素是否相等。<code>&lt;br /&gt;</code>Arrays.equals(arrayA, arrayB);<code>&lt;br /&gt;</code>arrayA 是用于比较的第一个数组，arrayB 是用于比较的第二个数组。<br><code>&lt;a name=&quot;Utxlm&quot;&gt;&lt;/a&gt;</code></p>
<h4 id="2-填充数组"><a href="#2-填充数组" class="headerlink" title="2. 填充数组"></a>2. 填充数组</h4><p>在指定位置进行数值填充。<code>&lt;br /&gt;</code>Arrays.fill(array,value);<code>&lt;br /&gt;</code>array 表示数组，value 表示填充的值。只能使用同一个数值进行填充。<br><code>&lt;a name=&quot;7ynyt&quot;&gt;&lt;/a&gt;</code></p>
<h4 id="3-数组查找"><a href="#3-数组查找" class="headerlink" title="3. 数组查找"></a>3. 数组查找</h4><p>从数组中查询指定位置的元素，或者查询某元素在指定数组中的位置，语法格式如下。  <code>&lt;br /&gt;</code>binarySearch(Object[] a,Object key);<code>&lt;br /&gt;</code>a 表示要搜索的数组，key 表示要搜索的值。  <code>&lt;br /&gt;</code>在数组中指定范围内查找，语法格式如下。<code>&lt;br /&gt;</code>binarySearch(Object[] a,int fromIndex,int toIndex,Object key);<code>&lt;br /&gt;</code>a 表示要进行查找的数组，fromIndex 指定范围的开始处索引（包含开始处），toIndex 指定范围的结束处索引（不包含结束处），key 表示要搜索的元素。<br><code>&lt;a name=&quot;bakDn&quot;&gt;&lt;/a&gt;</code></p>
<h4 id="4-复制数组"><a href="#4-复制数组" class="headerlink" title="4. 复制数组"></a>4. 复制数组</h4><p><code>&lt;a name=&quot;tuqBh&quot;&gt;&lt;/a&gt;</code></p>
<h4 id="1-copyOf"><a href="#1-copyOf" class="headerlink" title="1) copyOf()"></a>1) copyOf()</h4><p>Arrays.copyOf(dataType[] srcArray,int length);<code>&lt;br /&gt;</code>srcArray 表示要进行复制的数组，length 表示复制后的新数组的长度<br><code>&lt;a name=&quot;Boj4k&quot;&gt;&lt;/a&gt;</code></p>
<h4 id="2-CopyOfRange"><a href="#2-CopyOfRange" class="headerlink" title="2) CopyOfRange()"></a>2) CopyOfRange()</h4><p>Arrays.copyOfRange(dataType[] srcArray,int startIndex,int endIndex)<code>&lt;br /&gt;</code>srcArray 表示原数组，startIndex 表示开始复制的起始索引，endIndex 表示终止索引。<br><code>&lt;a name=&quot;65umr&quot;&gt;&lt;/a&gt;</code></p>
<h4 id="3-arraycopy"><a href="#3-arraycopy" class="headerlink" title="3) arraycopy()"></a>3) arraycopy()</h4><p>System.arraycopy(dataType[] srcArray,int srcIndex,int destArray,int destIndex,int length)<code>&lt;br /&gt;</code>srcArray 表示原数组，srcIndex 表示源数组中的起始索引，destArray 表示目标数组，destIndex 表示目标数组中的起始索引，length 表示要复制的数组长度。<br><code>&lt;a name=&quot;HPDWo&quot;&gt;&lt;/a&gt;</code></p>
<h4 id="4-clone"><a href="#4-clone" class="headerlink" title="4) clone()"></a>4) clone()</h4><p>array_name.clone()<br><code>&lt;a name=&quot;CZFk0&quot;&gt;&lt;/a&gt;</code></p>
<h3 id="数组排序"><a href="#数组排序" class="headerlink" title="数组排序"></a>数组排序</h3><p><code>&lt;a name=&quot;JCEYd&quot;&gt;&lt;/a&gt;</code></p>
<h4 id="Java-数组中有-5-种常见排序方法，分别是："><a href="#Java-数组中有-5-种常见排序方法，分别是：" class="headerlink" title="Java 数组中有 5 种常见排序方法，分别是："></a>Java 数组中有 5 种常见排序方法，分别是：</h4><ol>
<li>Arrays.sort()</li>
<li>冒泡排序</li>
<li>快速排序</li>
<li>选择排序</li>
<li>直接插入<br><code>&lt;a name=&quot;hkm5B&quot;&gt;&lt;/a&gt;</code></li>
</ol>
<h3 id="常见问题解答"><a href="#常见问题解答" class="headerlink" title="常见问题解答"></a>常见问题解答</h3><p><code>&lt;a name=&quot;lC32w&quot;&gt;&lt;/a&gt;</code></p>
<h4 id="1-声明数组需要注意什么？"><a href="#1-声明数组需要注意什么？" class="headerlink" title="1. 声明数组需要注意什么？"></a>1. 声明数组需要注意什么？</h4><p>声明数组时，一定要考虑数组的最大容量，防止容量不够的现象。数组一旦被声明，它的容量就固定了，不容改变。如果想在运行程序时改变容量，就需要用到集合。关于集合我们会在教程后面讲解。<br><code>&lt;a name=&quot;CaxrI&quot;&gt;&lt;/a&gt;</code></p>
<h4 id="2-数组在平时的程序代码中使用是否频繁？"><a href="#2-数组在平时的程序代码中使用是否频繁？" class="headerlink" title="2. 数组在平时的程序代码中使用是否频繁？"></a>2. 数组在平时的程序代码中使用是否频繁？</h4><p>数组有一个缺点，就是一旦声明，就不能改变容量，这个也是其使用频率不高的原因。一般存储数据会使用集合或 Vector 来存储数据，后面我们会讲到。</p>
<p><code>&lt;a name=&quot;0F3hA&quot;&gt;&lt;/a&gt;</code></p>
<h2 id="9-super和this的区别"><a href="#9-super和this的区别" class="headerlink" title="9.super和this的区别"></a>9.super和this的区别</h2><p><strong>this 指的是当前对象的引用，super 是当前对象的父对象的引用。下面先简单介绍一下 super 和 this 关键字的用法。</strong><br><code>&lt;a name=&quot;CufaA&quot;&gt;&lt;/a&gt;</code></p>
<h3 id="super-关键字的用法："><a href="#super-关键字的用法：" class="headerlink" title="super 关键字的用法："></a>super 关键字的用法：</h3><p>super 可以用来直接调用父类中的构造方法，使编写代码也更加简洁方便。  <code>&lt;br /&gt;</code>编译器会自动在子类构造方法的第一句加上super();来调用父类的无参构造方法，必须写在子类构造方法的第一句，也可以省略不写。通过 super 来调用父类其它构造方法时，只需要把相应的参数传过去。</p>
<ol>
<li>super.父类属性名：调用父类中的属性</li>
<li>super.父类方法名：调用父类中的方法</li>
<li>super()：调用父类的无参构造方法</li>
<li>super(参数)：调用父类的有参构造方法</li>
<li>如果构造方法的第一行代码不是 this() 和 super()，则系统会默认添加 super()。<br><code>&lt;a name=&quot;a5gXL&quot;&gt;&lt;/a&gt;</code></li>
</ol>
<h3 id="this-关键字的用法："><a href="#this-关键字的用法：" class="headerlink" title="this 关键字的用法："></a>this 关键字的用法：</h3><ol>
<li>this.属性名：表示当前对象的属性</li>
<li>this.方法名(参数)：表示调用当前对象的方法</li>
<li>当局部变量和成员变量发生冲突时，使用this.进行区分。<br><code>&lt;a name=&quot;XGxLk&quot;&gt;&lt;/a&gt;</code></li>
</ol>
<h3 id="关于-Java-super-和-this-关键字的异同，可简单总结为以下几条。"><a href="#关于-Java-super-和-this-关键字的异同，可简单总结为以下几条。" class="headerlink" title="关于 Java super 和 this 关键字的异同，可简单总结为以下几条。"></a>关于 <a target="_blank" rel="noopener" href="http://c.biancheng.net/java/">Java</a> super 和 this 关键字的异同，可简单总结为以下几条。</h3><ol>
<li>子类和父类中变量或方法名称相同时，用 super 关键字来访问。可以理解为 super 是指向自己父类对象的一个指针。在子类中调用父类的构造方法。</li>
<li>this 是自身的一个对象，代表对象本身，可以理解为 this 是指向对象本身的一个指针。在同一个类中调用其它方法。</li>
<li>this 和 super 不能同时出现在一个构造方法里面，因为 this 必然会调用其它的构造方法，其它的构造方法中肯定会有 super 语句的存在，所以在同一个构造方法里面有相同的语句，就失去了语句的意义，编译器也不会通过。</li>
<li>this( ) 和 super( ) 都指的是对象，所以，均不可以在 static 环境中使用，包括 static 变量、static 方法和 static 语句块。</li>
<li>从本质上讲，this 是一个指向对象本身的指针, 然而 super 是一个 Java 关键字。<br><code>&lt;a name=&quot;5ZSX0&quot;&gt;&lt;/a&gt;</code></li>
</ol>
<h1 id="10-Java对象类型转换：向上转型和向下转型"><a href="#10-Java对象类型转换：向上转型和向下转型" class="headerlink" title="10.Java对象类型转换：向上转型和向下转型"></a>10.Java对象类型转换：向上转型和向下转型</h1><p>将一个类型强制转换成另一个类型的过程被称为类型转换。本节所说的对象类型转换，是指存在继承关系的对象，不是任意类型的对象。当对不存在继承关系的对象进行强制类型转换时，会抛出 <a target="_blank" rel="noopener" href="http://c.biancheng.net/java/">Java</a> 强制类型转换（java.lang.ClassCastException）异常<br><code>&lt;a name=&quot;tumYL&quot;&gt;&lt;/a&gt;</code></p>
<h3 id="1）向上转型"><a href="#1）向上转型" class="headerlink" title="1）向上转型"></a>1）向上转型</h3><p>父类引用指向子类对象为向上转型，语法格式如下：<code>&lt;br /&gt;</code>fatherClass obj &#x3D; new sonClass();<br><code>&lt;a name=&quot;wwcgi&quot;&gt;&lt;/a&gt;</code></p>
<h3 id="2）向下转型"><a href="#2）向下转型" class="headerlink" title="2）向下转型"></a>2）向下转型</h3><p>与向上转型相反，子类对象指向父类引用为向下转型，语法格式如下：<code>&lt;br /&gt;</code>sonClass obj &#x3D; (sonClass) fatherClass;<br><code>&lt;a name=&quot;IwO9Z&quot;&gt;&lt;/a&gt;</code></p>
<h2 id="11-异常处理"><a href="#11-异常处理" class="headerlink" title="11.异常处理"></a>11.异常处理</h2><p><code>&lt;a name=&quot;r4V2l&quot;&gt;&lt;/a&gt;</code></p>
<h3 id="在-Java-中一个异常的产生，主要有如下三种原因："><a href="#在-Java-中一个异常的产生，主要有如下三种原因：" class="headerlink" title="在 Java 中一个异常的产生，主要有如下三种原因："></a>在 Java 中一个异常的产生，主要有如下三种原因：</h3><ol>
<li>Java 内部错误发生异常，Java 虚拟机产生的异常。</li>
<li>编写的程序代码中的错误所产生的异常，例如空指针异常、数组越界异常等。</li>
<li>通过 throw 语句手动生成的异常，一般用来告知该方法的调用者一些必要信息。<br><code>&lt;a name=&quot;m4PYZ&quot;&gt;&lt;/a&gt;</code></li>
</ol>
<h2 id="12-继承"><a href="#12-继承" class="headerlink" title="12.继承"></a>12.继承</h2><p>执行顺序：父类静态变量，方法→父类静态代码块→子类静态变量，方法→子类静态代码块→父类非静态代码快→父类构造函数→子类非静态代码快→子类构造函数。注：静态变量，方法按照位置顺序执行。<code>&lt;br /&gt;</code>静态块中的代码按写的顺序首先依次执行，执行于方法前<br><code>&lt;a name=&quot;tDe5s&quot;&gt;&lt;/a&gt;</code></p>
<h2 id="13-构造方法"><a href="#13-构造方法" class="headerlink" title="13.构造方法"></a>13.构造方法</h2><p><code>&lt;a name=&quot;ogmcM&quot;&gt;&lt;/a&gt;</code></p>
<h3 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h3><ul>
<li>构造方法名与类名相同</li>
<li>构造方法没有返回值 类型，也不写void</li>
<li>构造方法可以重载<br><code>&lt;a name=&quot;EEvDx&quot;&gt;&lt;/a&gt;</code></li>
</ul>
<h3 id="构造方法的作用："><a href="#构造方法的作用：" class="headerlink" title="构造方法的作用："></a>构造方法的作用：</h3><ul>
<li>在创建对象时，给属性赋初值</li>
<li>构造方法何时使用</li>
<li>构造方法在创建对象时被调用<br><code>&lt;a name=&quot;bhjeP&quot;&gt;&lt;/a&gt;</code></li>
</ul>
<h3 id="构造方法的分类："><a href="#构造方法的分类：" class="headerlink" title="构造方法的分类："></a>构造方法的分类：</h3><ul>
<li>显示的构造方法和隐式的构造方法</li>
<li>当声明了构造方法时，系统不会提供隐式的默认的无参构造方法\</li>
<li>编译看左边，运行看右边</li>
</ul>
<p><strong>下面的笔记和题目顺序大致一致</strong></p>
<p><code>&lt;a name=&quot;wQZOx&quot;&gt;&lt;/a&gt;</code></p>
<h1 id="java基础复习总结"><a href="#java基础复习总结" class="headerlink" title="java基础复习总结"></a>java基础复习总结</h1><p><code>&lt;a name=&quot;wys1q&quot;&gt;&lt;/a&gt;</code></p>
<h2 id="一-基础概念和常识"><a href="#一-基础概念和常识" class="headerlink" title="一.基础概念和常识"></a>一.基础概念和常识</h2><blockquote>
<p>1） JVM vs JDK vs JRE<code>&lt;br /&gt;</code>2） 为什么说 Java 语言“编译与解释并存”？</p>
</blockquote>
<p><code>&lt;a name=&quot;RWvw4&quot;&gt;&lt;/a&gt;</code></p>
<h3 id="1-JVM-vs-JDK-vs-JRE"><a href="#1-JVM-vs-JDK-vs-JRE" class="headerlink" title="1. JVM vs JDK vs JRE"></a>1. JVM vs JDK vs JRE</h3><ul>
<li>JDK：Java Development Kit</li>
<li>JRE：Java Runtime Environment</li>
</ul>
<p>JRE就是运行Java字节码的虚拟机。但是，如果只有Java源码，要编译成Java字节码，就需要JDK，因为JDK除了包含JRE，还提供了编译器、调试器等开发工具。<code>&lt;br /&gt;</code>二者关系如下：<code>&lt;br /&gt;</code>┌─    ┌──────────────────────────────────┐<code>&lt;br /&gt;</code>│     │     Compiler, debugger, etc.     │<code>&lt;br /&gt;</code>│     └──────────────────────────────────┘<code>&lt;br /&gt;</code>JDK ┌─ ┌──────────────────────────────────┐<code>&lt;br /&gt;</code>│  │  │                                  │<code>&lt;br /&gt;</code>│ JRE │      JVM + Runtime Library       │<code>&lt;br /&gt;</code>│  │  │                                  │<code>&lt;br /&gt;</code>└─ └─ └──────────────────────────────────┘<code>&lt;br /&gt;</code>┌───────┐┌───────┐┌───────┐┌───────┐<code>&lt;br /&gt;</code>│Windows││ Linux ││ macOS ││others │<code>&lt;br /&gt;</code>└───────┘└───────┘└───────┘└───────┘<code>&lt;br /&gt;</code>JDK（Java Development<code>&lt;br /&gt;</code>Kit）是针对Java开发员的产品，是整个Java的核心，包括了Java运行环境JRE、Java工具和Java基础类库。<code>&lt;br /&gt;</code>JRE (Java Runtime Environment)是运行JAVA程序所必须的环境的集合，包含JVM标准实现及Java核心类库。<code>&lt;br /&gt;</code>JVM (Java Virtual<code>&lt;br /&gt;</code>Machine)是Java虚拟机的缩写，是整个java实现跨平台的最核心的部分，能够运行以Java语言写作的软件程序。<code>&lt;br /&gt;</code>三者的关系是JDK包含JRE包含JVM，Java运行步骤：源码—javac编译器—&gt;字节码文件—Java解释器—&gt;机器码文件。<code>&lt;br /&gt;</code>jvm的作用是将字节码文件解释为机器码文件。<code>&lt;br /&gt;</code>源码通过javac编译器转化为字节码文件，字节码文件是一样的。不一样的是jvm，针对不同的系统有不同的 jvm 实现。<code>&lt;br /&gt;</code>总结<code>&lt;br /&gt;</code>JDK是整个Java的核心，包括了Java运行环境JRE、Java工具和Java基础类库。JRE是运行JAVA程序所必须的环境的集合，包含JVM标准实现及Java核心类库。JVM是整个java实现跨平台的最核心的部分，能够运行以Java语言写的程序。<code>&lt;br /&gt;</code>2.</p>
<p><code>&lt;a name=&quot;LZQ6h&quot;&gt;&lt;/a&gt;</code></p>
<h3 id="2-为什么说-Java-语言“编译与解释并存”？"><a href="#2-为什么说-Java-语言“编译与解释并存”？" class="headerlink" title="2. 为什么说 Java 语言“编译与解释并存”？"></a>2. 为什么说 Java 语言“编译与解释并存”？</h3><p><code>&lt;a name=&quot;kSV8W&quot;&gt;&lt;/a&gt;</code></p>
<h4 id="编译型语言"><a href="#编译型语言" class="headerlink" title="编译型语言"></a>编译型语言</h4><p>会通过编译器将源代码翻译成可执行的机器码<code>&lt;br /&gt;</code>这类语言的执行速度比较快,开发效率低<code>&lt;br /&gt;</code>常见的C,C++,Go,Rust都是编译型语言<br><code>&lt;a name=&quot;G9ZNq&quot;&gt;&lt;/a&gt;</code></p>
<h4 id="解释型语言"><a href="#解释型语言" class="headerlink" title="解释型语言"></a>解释型语言</h4><p>会通过解释器将代码一句一句的解释成机器代码然后再去执行<code>&lt;br /&gt;</code>开发效率快,执行速度比较慢<code>&lt;br /&gt;</code>常见的Python,JS,PHP都是解释型语言<br><code>&lt;a name=&quot;b5yUT&quot;&gt;&lt;/a&gt;</code></p>
<h4 id="编译与解释并存"><a href="#编译与解释并存" class="headerlink" title="编译与解释并存"></a>编译与解释并存</h4><p>java具有编译型语言的特征,也具有解释型语言的特征<code>&lt;br /&gt;</code>java程序会经过先编译后解释<code>&lt;br /&gt;</code><img src="https://cdn.nlark.com/yuque/0/2022/png/33764834/1668330133097-42b84326-fc4c-4694-8ea5-4283c0d66a28.png#averageHue=%23c4c672&crop=0&crop=0&crop=1&crop=1&id=LhyQS&originHeight=357&originWidth=609&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br><code>&lt;a name=&quot;TkHzC&quot;&gt;&lt;/a&gt;</code></p>
<h4 id="先编译生成字节码-class文件"><a href="#先编译生成字节码-class文件" class="headerlink" title="先编译生成字节码(.class文件)"></a>先编译生成字节码(.class文件)</h4><p>再将字节码交给java解释器来解释执行<code>&lt;br /&gt;</code>所以先编译后解释<code>&lt;br /&gt;</code>.java经过javac编译器编译之后得到.class文件-&gt;这个就是java文件到虚拟机的中间码-&gt;.class文件只有被JVM加载-&gt;然后通过解释器-逐行解释执行，这种方式的执行速度会相对比较慢。这是属于解释型语言的特点，中间码即.calss文件只是一个中间码，并不算机器码，所以并不满足编译型语言的特点。然而，有些方法和代码块是经常需要被调用的，也就是所谓的热点代码，后面引进了 JIT 编译器，JIT 属于运行时编译。当 JIT 编译器完成第一次编译后，其会将字节码对应的机器码保存下来，下次可以直接使用。这是属于编译型语言的特点，机器码的运行效率肯定是高于 Java 解释器的。这也解释了我们为什么经常会说 <strong>Java 是编译与解释共存的语言。</strong><br><code>&lt;a name=&quot;mnTGs&quot;&gt;&lt;/a&gt;</code></p>
<h2 id="二-基本语法"><a href="#二-基本语法" class="headerlink" title="二.基本语法"></a>二.基本语法</h2><blockquote>
<ol>
<li>1） 注解</li>
<li>2） 字符型常量和字符串常量</li>
<li>3） 标识符和关键字的区别</li>
<li>4） 泛型，类型擦除</li>
<li>5） &#x3D;&#x3D;和equals()</li>
<li>6）  hashCode() 与 equals() 等</li>
</ol>
</blockquote>
<p><code>&lt;a name=&quot;YvJIy&quot;&gt;&lt;/a&gt;</code></p>
<h3 id="Java注解"><a href="#Java注解" class="headerlink" title="Java注解"></a><strong>Java注解</strong></h3><p><strong>是一个很重要的知识点，用于对代码进行说明，可以对包、类、接口、字段、方法参数、局部变量等进行注解。掌握好Java注解有利于学习</strong><a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E6%A1%86%E6%9E%B6&spm=1001.2101.3001.7020"><strong>框架</strong></a><strong>底层实现。</strong><code>&lt;br /&gt;</code><img src="https://cdn.nlark.com/yuque/0/2022/png/33764834/1668330133498-42fbd406-6166-4665-94d3-9fb2bb5330ea.png#averageHue=%23a9bdbb&crop=0&crop=0&crop=1&crop=1&id=gm08R&originHeight=407&originWidth=1487&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br><code>&lt;a name=&quot;xxVOB&quot;&gt;&lt;/a&gt;</code></p>
<h4 id="1、Java自带的标准注解"><a href="#1、Java自带的标准注解" class="headerlink" title="1、Java自带的标准注解"></a>1、Java自带的标准注解</h4><p>包括@Override、@Deprecated、@SuppressWarnings等，使用这些注解后编译器就会进行检查。<br><code>&lt;a name=&quot;ca8D3&quot;&gt;&lt;/a&gt;</code></p>
<h4 id="2、元注解"><a href="#2、元注解" class="headerlink" title="2、元注解"></a>2、元注解</h4><p>元注解是用于定义注解的注解，包括@Retention、@Target、@Inherited、@Documented、@Repeatable 等。  <code>&lt;br /&gt;</code>元注解也是Java自带的标准注解，只不过用于修饰注解，比较特殊。<code>&lt;br /&gt;</code><img src="https://cdn.nlark.com/yuque/0/2022/png/33764834/1668330133836-89ead97a-5fdf-4d79-95b0-2a576079b8c3.png#averageHue=%23f8f7f7&crop=0&crop=0&crop=1&crop=1&id=vL2eF&originHeight=245&originWidth=2028&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><code>&lt;br /&gt;</code><img src="https://cdn.nlark.com/yuque/0/2022/png/33764834/1668330134085-bdfd414b-6d96-4516-8ae2-2d41a78c73eb.png#averageHue=%23f9f8f8&crop=0&crop=0&crop=1&crop=1&id=hEGNu&originHeight=485&originWidth=1910&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><code>&lt;br /&gt;</code><img src="https://cdn.nlark.com/yuque/0/2022/png/33764834/1668330134491-83ee42e5-51f7-4eb4-9f31-266492da95a7.png#averageHue=%23f8f7f7&crop=0&crop=0&crop=1&crop=1&id=akZt3&originHeight=455&originWidth=1362&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><code>&lt;br /&gt;</code><img src="https://cdn.nlark.com/yuque/0/2022/png/33764834/1668330134974-67b03011-d1e6-4664-ba8b-2b078e781235.png#averageHue=%23f8efd7&crop=0&crop=0&crop=1&crop=1&id=UtAdq&originHeight=639&originWidth=1856&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><code>&lt;br /&gt;</code><img src="https://cdn.nlark.com/yuque/0/2022/png/33764834/1668330135505-5bc1fd8a-3ce4-49bf-8b5c-3159567da50d.png#averageHue=%23f1efed&crop=0&crop=0&crop=1&crop=1&id=uC43A&originHeight=68&originWidth=1473&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><code>&lt;br /&gt;</code><img src="https://cdn.nlark.com/yuque/0/2022/png/33764834/1668330135907-72e9100a-46f6-4590-8e1a-09021e4928ab.png#averageHue=%23e3e2e2&crop=0&crop=0&crop=1&crop=1&id=l4O0f&originHeight=1139&originWidth=2180&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><code>&lt;br /&gt;</code><img src="https://cdn.nlark.com/yuque/0/2022/png/33764834/1668330136669-3d8338be-ed40-4a0b-8899-f8f95770e735.png#averageHue=%23ebebea&crop=0&crop=0&crop=1&crop=1&id=ymk84&originHeight=858&originWidth=1446&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><code>&lt;br /&gt;</code><img src="https://cdn.nlark.com/yuque/0/2022/png/33764834/1668330137142-27e053e8-6f34-464a-9b05-35a16ebbd40c.png#averageHue=%23f9f9f8&crop=0&crop=0&crop=1&crop=1&id=HghKn&originHeight=546&originWidth=2098&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br><code>&lt;a name=&quot;bejXA&quot;&gt;&lt;/a&gt;</code></p>
<h3 id="java中字符型常量和字符串常量的区别"><a href="#java中字符型常量和字符串常量的区别" class="headerlink" title="java中字符型常量和字符串常量的区别"></a>java中字符型常量和字符串常量的区别</h3><p><code>&lt;a name=&quot;epLcf&quot;&gt;&lt;/a&gt;</code></p>
<h4 id="1-形式上"><a href="#1-形式上" class="headerlink" title="1.形式上"></a>1.形式上</h4><p>字符常量 是单引号(‘’)引起的一个字符，字符串常量 是双引号引起的若干个字符<br><code>&lt;a name=&quot;CTuWA&quot;&gt;&lt;/a&gt;</code></p>
<h4 id="2-含有上"><a href="#2-含有上" class="headerlink" title="2.含有上"></a>2.含有上</h4><p>字符常量相当于一个整形值(ASCll值)，可以参与表达式的运算。字符串常量代表一个地址值(该字符串在内存中存放的位置）<br><code>&lt;a name=&quot;HNH8Z&quot;&gt;&lt;/a&gt;</code></p>
<h4 id="3-占内存大小"><a href="#3-占内存大小" class="headerlink" title="3.占内存大小"></a>3.占内存大小</h4><p>字符常量占两个字节，字符串常量若干个字节（至少一个字符结束标志）<code>&lt;br /&gt;</code>1） 标识符和关键字的区别<br><code>&lt;a name=&quot;pToyc&quot;&gt;&lt;/a&gt;</code></p>
<h2 id="Java标识符和关键字的区别"><a href="#Java标识符和关键字的区别" class="headerlink" title="Java标识符和关键字的区别"></a>Java标识符和关键字的区别</h2><p><strong>一、主体不同</strong><code>&lt;br /&gt;</code><strong>关键字</strong>属于保留字，是整个语言范围内预先保留的标识符。<strong>一般标识符</strong>是用户编程时使用的名字，用于给变量、常量、函数、语句块等命名，以建立起名称与使用之间的关系。<code>&lt;br /&gt;</code><strong>二、特点不同</strong><code>&lt;br /&gt;</code><strong>关键字</strong>不能声明与关键字同名的标识符。<strong>一般标识符</strong>由字母和数字以及其它字符构成。<code>&lt;br /&gt;</code><strong>三、规则不同</strong><code>&lt;br /&gt;</code><strong>关键字</strong>经过预处理后，关键字从预处理记号(preprocessing-token)中区别出来，剩下的标识符作为记号(token)，用于声明对象、函数、类型、命名空间等。一般标识符长度是由机器上的编译系统决定的，一般的限制为8字符。<br><code>&lt;a name=&quot;jXom2&quot;&gt;&lt;/a&gt;</code></p>
<h4 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h4><p><strong>对编译器有特殊意义的固定单词</strong>，不能在程序中做其他目的使用。关键字具有专门的意义和用途，<strong>和自定义的标识符不同，不能当作一般的标识符来使用</strong>！<code>&lt;br /&gt;</code>Java 语言按其用途划分为如下几组，<strong>这些关键字不能作为变量名、类名和方法名来使用！！（注意：关键字一律用小写字母标识）</strong><code>&lt;br /&gt;</code><strong>1、用于数据类型</strong>：boolean、byte、char、 double、 float、int、long、new、short、void、instanceof。<code>&lt;br /&gt;</code><strong>2、用于语句</strong>：break、case、 catch、 continue、 default 、do、 else、 for、 if、return、switch、try、 while、 finally、 throw、this、 super。<code>&lt;br /&gt;</code><strong>3、用于修饰</strong>：abstract、final、native、private、 protected、public、static、synchronized、transient、 volatile。<code>&lt;br /&gt;</code><strong>4、用于方法、类、接口、包和异常</strong>：class、 extends、 implements、interface、 package、import、throws。<code>&lt;br /&gt;</code><strong>5、还有些关键字</strong>,如 future、 generic、 operator、 outer、rest、var等都是Java保留的没有意义的关键字。<code>&lt;br /&gt;</code><strong>6、另外，Java还有3个保留字</strong>：goto、const、null。它们不是关键字，而是文字。包含Java定义的值。和关键字一样，它们也不可以作为标识符使用。<br><code>&lt;a name=&quot;LRHUF&quot;&gt;&lt;/a&gt;</code></p>
<h4 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h4><p>1、标识符由数字（0<del>9）和字母（A</del>Z 和 a~z）、美元符号（$）、下划线（_）以及 Unicode 字符集中符号大于 0xC0 的所有符号组合构成（各符号之间没有空格）。<code>&lt;br /&gt;</code>2、标识符的第一个符号为字母、下划线和美元符号，后面可以是任何字母、数字、美元符号或下划线。<br><code>&lt;a name=&quot;B8S35&quot;&gt;&lt;/a&gt;</code></p>
<h5 id="标识符的分类"><a href="#标识符的分类" class="headerlink" title="标识符的分类"></a><strong>标识符的分类</strong></h5><p>1、关键字是有特殊含义的标识符，如 true、false 表示逻辑的真假。<code>&lt;br /&gt;</code>2、用户自定义标识符是由用户按标识符构成规则生成的非保留字的标识符，如 abc 就是一个标识符。</p>
<p><code>&lt;a name=&quot;BsEzl&quot;&gt;&lt;/a&gt;</code></p>
<h2 id="泛型，类型擦除"><a href="#泛型，类型擦除" class="headerlink" title="泛型，类型擦除"></a>泛型，类型擦除</h2><ol>
<li>泛型方法不能使用基本数据类型作为参数。</li>
<li>使用泛型进行编程可以提高程序安全性以及可读性。</li>
<li>泛型只存在于编译期间。</li>
<li>通过使用通配符可以放宽对参数的限制增加程序灵活性。</li>
</ol>
<p>1 泛型通配符<br><code>&lt;a name=&quot;ZqPpU&quot;&gt;&lt;/a&gt;</code></p>
<h4 id="1-1-无边界通配符-lt-gt"><a href="#1-1-无边界通配符-lt-gt" class="headerlink" title="1.1 无边界通配符 &lt;?&gt;"></a>1.1 无边界通配符 &lt;?&gt;</h4><p><code>&lt;a name=&quot;rjzRG&quot;&gt;&lt;/a&gt;</code></p>
<h4 id="1-2-固定上边界的通配符-lt-extends-E-gt"><a href="#1-2-固定上边界的通配符-lt-extends-E-gt" class="headerlink" title="1.2 固定上边界的通配符 &lt;? extends E&gt;"></a>1.2 固定上边界的通配符 &lt;? extends E&gt;</h4><p>对于上限通配符需要注意的一点就是使用上限通配符只能从结构中获取值而不能将值放入结构中<br><code>&lt;a name=&quot;Ox98W&quot;&gt;&lt;/a&gt;</code></p>
<h4 id="1-3-固定下边界的通配符-lt-super-E-gt"><a href="#1-3-固定下边界的通配符-lt-super-E-gt" class="headerlink" title="1.3 固定下边界的通配符&lt;? super E&gt;"></a>1.3 固定下边界的通配符&lt;? super E&gt;</h4><p>对于下限通配符同样需要注意的一点就是使用下限通配符只能将值放入结构中或者将读取结果转换为Object<code>&lt;br /&gt;</code>总结</p>
<pre><code>1. 如果要从结构中获取值，使用上限通配符；
     2. 在将值放入结构中时，使用下限通配符。
     3. 可以为通配符指定上限，也可以指定下限，但不能同时指定两者。
</code></pre>
<p>反编译命令 javap -c [Class名称] 就可以编译class文件。<br><code>&lt;a name=&quot;zJ1k0&quot;&gt;&lt;/a&gt;</code></p>
<h3 id="1、泛型不是协变的"><a href="#1、泛型不是协变的" class="headerlink" title="1、泛型不是协变的"></a>1、<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E6%B3%9B%E5%9E%8B&spm=1001.2101.3001.7020">泛型</a>不是协变的</h3><p>_协变_：能在使用父类型的场景中改用子类型<code>&lt;br /&gt;</code>_逆变_：能在使用子类型的场景中改用父类型<code>&lt;br /&gt;</code>_不变_：不能做到以上两点<br><code>&lt;a name=&quot;LkHZR&quot;&gt;&lt;/a&gt;</code></p>
<h3 id="2-泛型的特性所引起的问题"><a href="#2-泛型的特性所引起的问题" class="headerlink" title="2 泛型的特性所引起的问题"></a>2 泛型的特性所引起的问题</h3><p>泛型类型变量不能是基本数据类型<code>&lt;br /&gt;</code>因为当类型擦除后会变为Object等引用类型，因此基本数据类型不能用于定义泛型类型变量。<code>&lt;br /&gt;</code>使用instanceof注意点<code>&lt;br /&gt;</code>instanceof 是用来测试一个对象是否为一个类的实例，而对于泛型在类型擦除后会变为Object等引用类型，因此instanceof检测和类型转换工作只对原始类型进行.<code>&lt;br /&gt;</code>泛型在静态方法和静态类中的问题<code>&lt;br /&gt;</code>泛型类中的静态方法和静态变量不能使用泛型类所声明的泛型类型参数，因为泛型类中的泛型参数的实例化是在定义对象的时候指定的，而静态变量和静态方法不需要使用对象来调用，因此对象没有创建也就无法确定这个泛型参数是何种类型。另外由于类型擦除的原因，实际上多个泛型方法只存在一个对应的原始类，因此静态变量在这多个泛型类实例之间是共享的。<code>&lt;br /&gt;</code><strong>不能创建一个泛型类型的实例</strong><code>&lt;br /&gt;</code><strong>没有泛型数组</strong>由于数组是协变的加上泛型最终会被类型擦除，因此泛型数组违背了泛型的设计初衷是被禁止的<code>&lt;br /&gt;</code>Java泛型实际上是“伪泛型”，它只是在编译期存在当程序到运行时则会被Java虚拟机进行类型擦除，同时Java虚拟机通过桥接的方式将编译期和运行期的程序（泛型类和原始类）连接了起来，从而实现了泛型的整个过程。另外对于Java泛型的许多限制都可以通过类型擦除和泛型的设计初衷来解释（将可能出现的运行时异常移至编译其解决）。<br><code>&lt;a name=&quot;ZmDtz&quot;&gt;&lt;/a&gt;</code></p>
<h2 id="x3D-x3D-和equals"><a href="#x3D-x3D-和equals" class="headerlink" title="&#x3D;&#x3D;和equals()"></a>&#x3D;&#x3D;和equals()</h2><p>一、对字符串而言，&#x3D;&#x3D;和equals()的区别</p>
<ul>
<li>“&#x3D;&#x3D;” 比较的是两个对象的引用（内存地址）是否相同，也用来比较两个基本数据类型的变量值是否相等。</li>
<li>equals() 比较的是两个对象的值（内容）是否相同。</li>
<li>对于&#x3D;&#x3D;：在简单类型中(int等)，这能使用该方法进行比较，这种类型没有equals方法，int的值是存在栈中的，&#x3D;&#x3D;比较的是栈的内容是否相同。在String类型中，比较特殊，用String&#x3D;“<strong>”；这种进行赋值时，两个相同的值用&#x3D;&#x3D;比较也是相同的。但是用new String()，赋值就不相同。说明String&#x3D;“”时，java会检查在堆中是否由相同的值，如果有，把新对象的地址也同老对象的地址赋为相同，因此&#x3D;&#x3D;比较会相同（“</strong>”存储在常量区内存中）。但是new String()开辟的就是两个栈，因此用&#x3D;&#x3D;比较不会相同。对于包装类，如Integer num&#x3D;127；时，进行自动装箱操作。如果数值在-128-127会有缓存，此时&#x3D;&#x3D;是相同的；如果数值不在-128～127之间，则&#x3D;&#x3D;不相同。</li>
<li>对于equals：当时String类型或者是包装类（如Integer），比较的就是堆中的值。对于用户自定义的普通类，equals比较的内存的首地址，这时候和&#x3D;&#x3D;是一样的，即比较两边指向的是不是同一个对象。<br><code>&lt;a name=&quot;WNWUV&quot;&gt;&lt;/a&gt;</code></li>
</ul>
<h3 id="关于hashcode，我们一定要知道一个口诀："><a href="#关于hashcode，我们一定要知道一个口诀：" class="headerlink" title="关于hashcode，我们一定要知道一个口诀："></a>关于hashcode，我们一定要知道一个口诀：</h3><ul>
<li>hashcode相等，两个对象不一定相等，需要通过equals方法进一步判断；</li>
<li>hashcode不相等，两个对象一定不相等；</li>
<li>equals方法为true，则hashcode肯定一样；</li>
<li>equals方法为false，则hashcode不一定不一样<br><code>&lt;a name=&quot;U6Oaa&quot;&gt;&lt;/a&gt;</code></li>
</ul>
<h2 id="hashCode-与-equals"><a href="#hashCode-与-equals" class="headerlink" title="hashCode()与 equals()"></a>hashCode()与 equals()</h2><p>hashCode()和<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=equals&spm=1001.2101.3001.7020">equals</a>()都是Object类中的方法<code>&lt;br /&gt;</code>(1).如果类中不<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E9%87%8D%E5%86%99&spm=1001.2101.3001.7020">重写</a>方法：<code>&lt;br /&gt;</code>hashCode()：属于本地方法，返回的是对象的哈希码值，也称为<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E6%95%A3%E5%88%97&spm=1001.2101.3001.7020">散列</a>码，实际返回的是一个int的整数。<code>&lt;br /&gt;</code>equals()：用来比较两个对象的地址值是否相等<code>&lt;br /&gt;</code>(2)如果类中重写方法：  <code>&lt;br /&gt;</code>hashCode()：返回的是根据对象的成员变量，计算出的一个整数  <code>&lt;br /&gt;</code>通过hashCode()和equals()搭配使用比较对象是否相等，是如何提高效率的？<code>&lt;br /&gt;</code>问题：对于一个对象中有大量的成员信息，用equals比较会降低效率<code>&lt;br /&gt;</code>解决：可以先通过hashCode()进行比较，如果不相同则两个对象一定不同，如果相同，再通过eauqls()进行比较，这样既可以判断对象是否相同，又可以提高效率<code>&lt;br /&gt;</code>通过hashCode()和equals()搭配使用比较对象是否相等，是如何提高效率的？<code>&lt;br /&gt;</code>问题：对于一个对象中有大量的成员信息，用equals比较会降低效率<code>&lt;br /&gt;</code>解决：可以先通过hashCode()进行比较，如果不相同则两个对象一定不同，如果相同，再通过eauqls()进行比较，这样既可以判断对象是否相同，又可以提高效率</p>
<ol>
<li>基本数据类型</li>
</ol>
<p>1） 基本数据类所占字节数<code>&lt;br /&gt;</code>2） 自动装箱和拆箱 <code>&lt;br /&gt;</code>3） 数据类型的封装类，以及中间的区别<code>&lt;br /&gt;</code>Java基本数据类型及所占字节大小<code>&lt;br /&gt;</code>一、Java基本数据类型<code>&lt;br /&gt;</code>　　基本数据类型有8种：byte、short、int、long、float、double、boolean、char<code>&lt;br /&gt;</code>分为4类：整数型、浮点型、布尔型、字符型。<code>&lt;br /&gt;</code>整数型：byte、short、int、long<code>&lt;br /&gt;</code>浮点型：float、double<code>&lt;br /&gt;</code>布尔型：boolean<code>&lt;br /&gt;</code>字符型：char<code>&lt;br /&gt;</code>二、各数据类型所占字节大小<code>&lt;br /&gt;</code>1个字节8位<code>&lt;br /&gt;</code>　　计算机的基本单位：bit .　　一个bit代表一个0或1<code>&lt;br /&gt;</code>byte：1byte &#x3D; 8bit　　　　 1个字节是8个bit<code>&lt;br /&gt;</code>short：2byte<code>&lt;br /&gt;</code>int：4byte<code>&lt;br /&gt;</code>long：8byte<code>&lt;br /&gt;</code>float：4byte<code>&lt;br /&gt;</code>double：8byte<code>&lt;br /&gt;</code>boolean：1byte<code>&lt;br /&gt;</code>char：2byte<code>&lt;br /&gt;</code>————————————————</p>
<p>自动拆箱和装箱<code>&lt;br /&gt;</code><strong>什么是自动装箱拆箱？</strong><code>&lt;br /&gt;</code><strong>装箱就是自动将基本数据类型转换为包装器类型；拆箱就是自动将包装器类型转换为基本数据类型。</strong><br><code>&lt;a name=&quot;zKmrw&quot;&gt;&lt;/a&gt;</code></p>
<h1 id="Java基本数据类型与封装类的区别"><a href="#Java基本数据类型与封装类的区别" class="headerlink" title="Java基本数据类型与封装类的区别"></a>Java基本数据类型与封装类的区别</h1><p>1.基本数据类型是值传递，封装类是引用传递<code>&lt;br /&gt;</code>2.基本数据类型是存放在栈中的，而封装类是存放于堆中的<code>&lt;br /&gt;</code>3.基本数据类型初始值如:int&#x3D;0,而封装类Integer&#x3D;null<code>&lt;br /&gt;</code>4.集合中添加的元素一定是封装类引用数据类型<code>&lt;br /&gt;</code>5.声明基本数据类型不需要实例化可直接赋值，而封装类必须申请一个存储空间实例化才可赋值。<code>&lt;br /&gt;</code>————————————————<br><code>&lt;a name=&quot;DJm6x&quot;&gt;&lt;/a&gt;</code></p>
<h2 id="三-方法"><a href="#三-方法" class="headerlink" title="三.方法"></a>三.方法</h2><blockquote>
<ol>
<li>方法的几种类型</li>
<li>什么是返回值</li>
<li>静态方法的特殊性</li>
<li>实例方法以及和静态方法的区别</li>
</ol>
</blockquote>
<p><code>&lt;a name=&quot;m8eev&quot;&gt;&lt;/a&gt;</code></p>
<h3 id="1-java中方法的分类和性质"><a href="#1-java中方法的分类和性质" class="headerlink" title="1.java中方法的分类和性质"></a>1.java中方法的分类和性质</h3><p>1.无参数无返回值的方法（只执行方法体）<code>&lt;br /&gt;</code>2.无参数有返回值的方法（执行完方法后，需接收返回的数据）<code>&lt;br /&gt;</code>3.有参数无返回值的方法（访问方法时，需传入指定数据类型的值）<code>&lt;br /&gt;</code>4.有参数有返回值的方法（访问方法时，需传入指定数据类型的值，执行完方法后，需接收返回的数据）<code>&lt;br /&gt;</code>形参(形式参数)：<strong>定义方法时</strong>，指定的参数，用于<strong>接收实参数据</strong>，也就是在写方法代码的时候，我们指定的参数。实参(实际参数)：<strong>访问方法时</strong>，传入的实际数据。<code>&lt;br /&gt;</code>构造方法:<code>&lt;br /&gt;</code>1.构造方法又称为<strong>构造器</strong>，是<strong>用于构建对象的</strong>，和对象的关系相当于模具和产品，构造方法会确定构造某些对象的基本属性和规则。<code>&lt;br /&gt;</code>2.结合<strong>new关键字</strong>进行创建对象的时候使用<code>&lt;br /&gt;</code>3.不能被对象显示的调用，构造方法是用来构造对象的，不能被对象调用，好比模具和产品，构造方法就是模具，对象就是产品。<code>&lt;br /&gt;</code>4.方法名必须和类名一样，构造方法的方法名必须和当下的类名一模一样（包括字母大小写）。<code>&lt;br /&gt;</code>5.无返回值，也不用加void。构造方法是默认无返回值的方法，也不需要专门加void表示无返回值。<code>&lt;br /&gt;</code>6.当类的定义者（就是我们写代码的人），未提供构造方法时，系统默认提供一个无参数的构造方法。<code>&lt;br /&gt;</code>7.当类的定义者（就是我们写代码的人），一旦提供了构造方法，系统就不再提供默认的构造方法。<code>&lt;br /&gt;</code>————————————————<br><code>&lt;a name=&quot;nPJg6&quot;&gt;&lt;/a&gt;</code></p>
<h3 id="2-返回值"><a href="#2-返回值" class="headerlink" title="2.返回值:"></a>2.返回值:</h3><p>普通类的情况下，就是你在定义java方法时，必需要定义一个返回值类型或者使用void占位符占位，然后在方法体末端return一个返回值，需要与定义时候的返回值类型一致，然后在调用此方法时，就会把返回值传输到调用处。<br><code>&lt;a name=&quot;MsX7o&quot;&gt;&lt;/a&gt;</code></p>
<h3 id="3-静态方法的特殊性"><a href="#3-静态方法的特殊性" class="headerlink" title="3. 静态方法的特殊性"></a>3. 静态方法的特殊性</h3><p>静态成员随着类的加载而加载；<code>&lt;br /&gt;</code>静态成员优先于对象存在；<code>&lt;br /&gt;</code>静态成员被所有对象所共享；<code>&lt;br /&gt;</code>静态成员多了一个中调用方式，可以被类名直接调用。<code>&lt;br /&gt;</code>利：<code>&lt;br /&gt;</code>对对象的共享数据进行单独空间的存储，节省空间，没有必要每一个对象中都存储一份；<code>&lt;br /&gt;</code>可以直接被类名调用。<code>&lt;br /&gt;</code>弊：<code>&lt;br /&gt;</code>生命周期过长；<code>&lt;br /&gt;</code>访问出现局限性，只能访问静态。<br><code>&lt;a name=&quot;w8mJ5&quot;&gt;&lt;/a&gt;</code></p>
<h3 id="4-简述静态方法和实例方法的区别"><a href="#4-简述静态方法和实例方法的区别" class="headerlink" title="4.简述静态方法和实例方法的区别"></a>4.简述静态方法和实例方法的区别</h3><p>1.静态方法在编译时就加载了，而实例方法是实例化后加载，在调用静态方法时还没实例化，所以静态方法不能调用实例化方法。<code>&lt;br /&gt;</code>2.静态方法可以直接类名.方法名或者对象名.方法名调用；实例方法只能实例化后，通过对象名.方法名调用。<code>&lt;br /&gt;</code>3.静态方法只能调用类中静态属性和静态方法，不能调用类中实例属性和实例方法；实例方法可以调用静态属性和静态方法，也可以调用实例属性和实例方法。<code>&lt;br /&gt;</code>————————————————<code>&lt;br /&gt;</code>1) 值传递和引用传递的区别<br><code>&lt;a name=&quot;IBHA1&quot;&gt;&lt;/a&gt;</code></p>
<h2 id="一、值传递：是指在调用函数时将实际参数复制一份传递到函数中，这样在函数中如果对参数进行修改，将不会影响到实际参数。"><a href="#一、值传递：是指在调用函数时将实际参数复制一份传递到函数中，这样在函数中如果对参数进行修改，将不会影响到实际参数。" class="headerlink" title="一、值传递：是指在调用函数时将实际参数复制一份传递到函数中，这样在函数中如果对参数进行修改，将不会影响到实际参数。"></a>一、<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E5%80%BC%E4%BC%A0%E9%80%92&spm=1001.2101.3001.7020">值传递</a>：是指在调用函数时将实际参数复制一份传递到函数中，这样在函数中如果对参数进行修改，将不会影响到实际参数。</h2><p>对于基本数据类型的参数，形式参数的改变，不影响实际参数的值。<br><code>&lt;a name=&quot;Hkati&quot;&gt;&lt;/a&gt;</code></p>
<h2 id="二、引用传递：是指在调用函数时将实际参数的地址传递到函数中，那么在函数中对参数所进行的修改，将影响到实际参数。"><a href="#二、引用传递：是指在调用函数时将实际参数的地址传递到函数中，那么在函数中对参数所进行的修改，将影响到实际参数。" class="headerlink" title="二、引用传递：是指在调用函数时将实际参数的地址传递到函数中，那么在函数中对参数所进行的修改，将影响到实际参数。"></a>二、<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92&spm=1001.2101.3001.7020">引用传递</a>：是指在调用函数时将实际参数的地址传递到函数中，那么在函数中对参数所进行的修改，将影响到实际参数。</h2><p><code>&lt;a name=&quot;M86lB&quot;&gt;&lt;/a&gt;</code></p>
<h3 id="对于引用类型的参数传递，形式参数的改变，影响实际参数的值。"><a href="#对于引用类型的参数传递，形式参数的改变，影响实际参数的值。" class="headerlink" title="对于引用类型的参数传递，形式参数的改变，影响实际参数的值。"></a>对于引用类型的参数传递，形式参数的改变，影响实际参数的值。</h3><ol>
<li>重载和重写<br><code>&lt;a name=&quot;NWbgj&quot;&gt;&lt;/a&gt;</code></li>
</ol>
<h1 id="Java方法重载"><a href="#Java方法重载" class="headerlink" title="Java方法重载"></a>Java方法重载</h1><p><a target="_blank" rel="noopener" href="http://c.biancheng.net/java/">Java</a> 允许同一个类中定义多个同名方法，只要它们的形参列表不同即可。如果同一个类中包含了两个或两个以上方法名相同的方法，但形参列表不同，这种情况被称为方法重载（overload）。<code>&lt;br /&gt;</code>方法重载的要求是两同一不同：同一个类中方法名相同，参数列表不同。至于方法的其他部分，如方法返回值类型、修饰符等，与方法重载没有任何关系。<br><code>&lt;a name=&quot;Izqgr&quot;&gt;&lt;/a&gt;</code></p>
<h1 id="Java方法重写"><a href="#Java方法重写" class="headerlink" title="Java方法重写"></a>Java方法重写</h1><p>在子类中如果创建了一个与父类中相同名称、相同返回值类型、相同参数列表的方法，只是方法体中的实现不同，以实现不同于父类的功能，这种方式被称为方法重写（override），又称为方法覆盖。当父类中的方法无法满足子类需求或子类具有特有功能的时候，需要方法重写。<code>&lt;br /&gt;</code>在重写方法时，需要遵循下面的规则：</p>
<ul>
<li>参数列表必须完全与被重写的方法参数列表相同。</li>
<li>返回的类型必须与被重写的方法的返回类型相同（<a target="_blank" rel="noopener" href="http://c.biancheng.net/java/">Java</a>1.5 版本之前返回值类型必须一样，之后的 Java 版本放宽了限制，返回值类型必须小于或者等于父类方法的返回值类型）。</li>
<li>访问权限不能比父类中被重写方法的访问权限更低（public&gt;protected&gt;default&gt;private）。</li>
<li>重写方法一定不能抛出新的检査异常或者比被重写方法声明更加宽泛的检査型异常。例如，父类的一个方法声明了一个检査异常 IOException，在重写这个方法时就不能抛出 Exception，只能拋出 IOException 的子类异常，可以抛出非检査异常。</li>
</ul>
<p>另外还要注意以下几条：</p>
<ul>
<li>重写的方法可以使用 @Override 注解来标识。</li>
<li>父类的成员方法只能被它的子类重写。</li>
<li>声明为 final 的方法不能被重写。</li>
<li>声明为 static 的方法不能被重写，但是能够再次声明。</li>
<li>构造方法不能被重写。</li>
<li>子类和父类在同一个包中时，子类可以重写父类的所有方法，除了声明为 private 和 final 的方法。</li>
<li>子类和父类不在同一个包中时，子类只能重写父类的声明为 public 和 protected 的非 final 方法。</li>
<li>如果不能继承一个方法，则不能重写这个方法。</li>
</ul>
<p>一、重载和重写的概念：<code>&lt;br /&gt;</code>重载的概念 ：<code>&lt;br /&gt;</code>在同一个类中，允许存在一个以上的同名方法，只要它们的参数个数或者参数 类型不同即可。<code>&lt;br /&gt;</code>重写的概念：<code>&lt;br /&gt;</code>在子类中可以根据需要对从父类中继承来的方法进行改造，也称 为方法的重置、覆盖。在程序执行时，子类的方法将覆盖父类的方法。<code>&lt;br /&gt;</code>二、重载和重写的特点：<code>&lt;br /&gt;</code>重载的特点：<code>&lt;br /&gt;</code>与返回值类型无关，只看参数列表，且参数列表必须不同。(参数个数或参数类 型)。调用时，根据方法参数列表的不同来区别。<code>&lt;br /&gt;</code>重写的特点：<code>&lt;br /&gt;</code>1.子类重写的方法必须和父类被重写的方法具有相同的方法名称、参数列表 。<code>&lt;br /&gt;</code>2.子类重写的方法的返回值类型不能大于父类被重写的方法的返回值类型 （返回类型为类）。<code>&lt;br /&gt;</code>3.子类重写的方法使用的访问权限不能小于父类被重写的方法的访问权限 。<code>&lt;br /&gt;</code>4.子类不能重写父类中声明为private权限的方法 。<code>&lt;br /&gt;</code>5.子类方法抛出的异常不能大于父类被重写方法的异常 （父类异常的子类）。<code>&lt;br /&gt;</code>———————————————<code>&lt;br /&gt;</code>区别:<code>&lt;br /&gt;</code>重写，overriding,是指在继承的情况下，子类中定义了与父类中具有相同型构的新方法，也就是子类重写了父类的方法。<code>&lt;br /&gt;</code>重载，overloading，是在同一个类中，定义了一个以上具有相同名称，但是有着不同型构的方法，在同一个类中是不允许定义多于一个具有相同型构的方法的。<code>&lt;br /&gt;</code>构造器也是可以重载的，实际上，构造器就是一个方法，构造器的名称就是方法的名称。<code>&lt;br /&gt;</code>———————————————<code>&lt;br /&gt;</code>深拷贝和浅拷贝<code>&lt;br /&gt;</code><strong>概念：</strong><code>&lt;br /&gt;</code><strong>浅拷贝</strong> ：只复制指向某个对象的指针，而不复制对象本身，相当于是新建了一个对象，该对象复制了原对象的指针，新旧对象还是共用一个内存块<code>&lt;br /&gt;</code><strong>深拷贝</strong>：是新建一个一模一样的对象，该对象与原对象不共享内存，修改新对象也不会影响原对象</p>
<ol>
<li>面向对象</li>
</ol>
<p>1） 面向对象和面向过程<code>&lt;br /&gt;</code>2） 成员变量与局部变量的区别有哪些？<code>&lt;br /&gt;</code>3） 对象实体和对象引用的区别<code>&lt;br /&gt;</code>4） 构造方法的作用，特点<code>&lt;br /&gt;</code>5） 三大特性<code>&lt;br /&gt;</code>面向对象和面向过程<code>&lt;br /&gt;</code>优缺点对比<code>&lt;br /&gt;</code>面向过程：<code>&lt;br /&gt;</code>优点：效率高，因为不需要实例化对象。<code>&lt;br /&gt;</code>缺点：耦合度高，扩展性差，不易维护（例如：每个步骤都要有，不然就不行）<code>&lt;br /&gt;</code>面向对象：<code>&lt;br /&gt;</code>优点：耦合低（易复用），扩展性强，易维护，由于面向对象有封装、继承、多态性的特点，可以设计出低耦合的系统，使系统更加灵活、更加易于维护。<code>&lt;br /&gt;</code>缺点：效率比面向过程低。<code>&lt;br /&gt;</code>————————————————<br><code>&lt;a name=&quot;7A8n4&quot;&gt;&lt;/a&gt;</code></p>
<h1 id="成员变量与局部变量的区别有哪些？"><a href="#成员变量与局部变量的区别有哪些？" class="headerlink" title="成员变量与局部变量的区别有哪些？"></a>成员变量与局部变量的区别有哪些？</h1><p>类中定义的变量是成员变量，而方法中定义的变量是局部变量<code>&lt;br /&gt;</code>1.从语法形式上看，成员变量属于类，而局部变量是在方法中定义的变量或是方法的参数。<code>&lt;br /&gt;</code>成员变量可被修饰符修饰，而局部变量则不能被访问控制修饰符及static所修饰；成员变量和局部变量 都可以被final所修饰。<code>&lt;br /&gt;</code>2.从变量在内存中的储存方式上看，成员变量是对象的一部分，而对象是存在于堆内存的，而局部变量 是存在于栈内存的。<code>&lt;br /&gt;</code>3.从变量在内存中的生存时间上看，成员变量是对象的一部分，而对象是存在于堆内存的，而局部变量是存在于栈内存的。<code>&lt;br /&gt;</code>4.成员变量如果没有被赋初值，则会自动以类型的默认值赋值（例外：被final修饰但没有被static修饰的成员变量必须显式地赋值）；而局部变量则不会自动赋值，必须显式地赋值后才能使用。<code>&lt;br /&gt;</code>———————————————<br><code>&lt;a name=&quot;GK2ZD&quot;&gt;&lt;/a&gt;</code></p>
<h1 id="java中对象实体与对象的引用有何不同？"><a href="#java中对象实体与对象的引用有何不同？" class="headerlink" title="java中对象实体与对象的引用有何不同？"></a>java中对象实体与对象的引用有何不同？</h1><p>对象实体:就是类的这时体现，每个对象都是独立的内存。  <code>&lt;br /&gt;</code>引用就是表示的对象所在内存的位置。其实就是对象的线索。<code>&lt;br /&gt;</code>对象引用的目的地才是对象的实体。<code>&lt;br /&gt;</code>1） 构造方法的作用，特点<code>&lt;br /&gt;</code>1.构造方法的定义与说明<code>&lt;br /&gt;</code>构造方法 : 用来初始化对象的方法<code>&lt;br /&gt;</code>(1)  构造方法名与类名相同 , 且没有返回值,且不需要使用void修饰 。<code>&lt;br /&gt;</code>(2)  作用:在构造方法中为创建的对象初始化赋值,<code>&lt;br /&gt;</code>(3)  在创建一个对象的时候，至少要调用一个构造方法。<code>&lt;br /&gt;</code>(4) 每个类都有构造方法。如果没有显式地为类定义构造方法,Java将会为该类提供一个默认构造方法,但是只要在一个Java类中定义了一个构造方法后，默认的无参构造方法即失效。<code>&lt;br /&gt;</code>我们说构造方法是用来初始化对象的,那么它是怎样去初始化的呢,回想我们创建对象的语法<code>&lt;br /&gt;</code>例 : Car car&#x3D; new Car();<code>&lt;br /&gt;</code>我们可以看到new关键字右边的这一块 ,这其实就是调用了Car类的构造方法来创建此对象的<code>&lt;br /&gt;</code>2.构造方法的声明与使用<code>&lt;br /&gt;</code>构造方法也分为有参和无参的,如果没有显示的定义构造方法,默认是无参的<code>&lt;br /&gt;</code>构造方法之所以可以分为有参和无参,原因就是方法是可以去重载的<code>&lt;br /&gt;</code>当然我们也可以去为一个类设计更多的构造方法,参数不同即可<code>&lt;br /&gt;</code>1） 三大特性<code>&lt;br /&gt;</code>java三大特性：1、封装，是指隐藏对象的属性和实现细节，仅对外提供公共访问方式；2、继承，从已有的类中派生出新的类，新的类能吸收已有类的数据属性和行为，并能扩展新的能力；3、多态，一个方法可以有多种实现版本，即“一种定义， 多种实现”。<br><code>&lt;a name=&quot;Pz7rQ&quot;&gt;&lt;/a&gt;</code></p>
<h3 id="封装-Encapsulation-："><a href="#封装-Encapsulation-：" class="headerlink" title="封装(Encapsulation) ："></a>封装(Encapsulation) ：</h3><p>封装：是指隐藏对象的属性和实现细节，仅对外提供公共访问方式。<code>&lt;br /&gt;</code>好处：</p>
<ul>
<li>将变化隔离。</li>
<li>便于使用。</li>
<li>提高重用性。</li>
<li>提高安全性。</li>
<li>封装原则：</li>
<li>将不需要对外提供的内容都隐藏起来。</li>
<li>把属性都隐藏，提供公共方法对其访问 。</li>
</ul>
<p>private关键字：</p>
<ul>
<li>是一个权限修饰符。</li>
<li>用于修饰成员(成员变量和成员函数)</li>
<li>被私有化的成员只在本类中有效。</li>
</ul>
<p>继承<code>&lt;br /&gt;</code>Java 不支持多继承，只允许一个类直接继承另一个类，即子类只能有一个直接父类，<code>&lt;br /&gt;</code>使用继承的注意点：</p>
<ol>
<li>子类一般比父类包含更多的属性和方法。</li>
<li>父类中的 private 成员在子类中是不可见的，因此在子类中不能直接使用它们。</li>
<li>父类和其子类间必须存在“是一个”即“is-a”的关系，否则不能用继承。但也并不是所有符合“is-a”关系的都应该用继承。例如，正方形是一个矩形，但不能让正方形类来继承矩形类，因为正方形不能从矩形扩展得到任何东西。正确的继承关系是正方形类继承图形类。</li>
<li>Java 只允许单一继承（即一个子类只能有一个直接父类），C++ 可以多重继承（即一个子类有多个直接父类）。<br><code>&lt;a name=&quot;FYFX7&quot;&gt;&lt;/a&gt;</code></li>
</ol>
<h4 id="继承的优缺点"><a href="#继承的优缺点" class="headerlink" title="继承的优缺点"></a>继承的优缺点</h4><p>在面向对象语言中，继承是必不可少的、非常优秀的语言机制，它有如下优点：</p>
<ol>
<li>实现代码共享，减少创建类的工作量，使子类可以拥有父类的方法和属性。</li>
<li>提高代码维护性和可重用性。</li>
<li>提高代码的可扩展性，更好的实现父类的方法。</li>
</ol>
<p>自然界的所有事物都是优点和缺点并存的，继承的缺点如下：</p>
<ol>
<li>继承是侵入性的。只要继承，就必须拥有父类的属性和方法。</li>
<li>降低代码灵活性。子类拥有父类的属性和方法后多了些约束。</li>
<li>增强代码耦合性（开发项目的原则为高内聚低耦合）。当父类的常量、变量和方法被修改时，需要考虑子类的修改，有可能会导致大段的代码需要重构。</li>
</ol>
<p>Java多态性：Java什么是多态？<code>&lt;br /&gt;</code>多态性是面向对象编程的又一个重要特征，它是指在父类中定义的属性和方法被子类继承之后，可以具有不同的数据类型或表现出不同的行为，这使得同一个属性或方法在父类及其各个子类中具有不同的含义<code>&lt;br /&gt;</code>对面向对象来说，多态分为编译时多态和运行时多态。其中编译时多态是静态的，主要是指方法的重载，它是根据参数列表的不同来区分不同的方法。通过编译之后会变成两个不同的方法，在运行时谈不上多态。而运行时多态是动态的，它是通过动态绑定来实现的，也就是大家通常所说的多态性。<code>&lt;br /&gt;</code><a target="_blank" rel="noopener" href="http://c.biancheng.net/java/">Java</a> 实现多态有 3 个必要条件：继承、重写和向上转型。</p>
<ul>
<li>继承：在多态中必须存在有继承关系的子类和父类。</li>
<li>重写：子类对父类中某些方法进行重新定义，在调用这些方法时就会调用子类的方法。</li>
<li>向上转型：在多态中需要将子类的引用赋给父类对象，只有这样该引用才既能可以调用父类的方法，又能调用子类的方法。</li>
</ul>
<p>3.反射<code>&lt;br /&gt;</code>1） 什么是反射<code>&lt;br /&gt;</code>2） 优缺点<code>&lt;br /&gt;</code>3） 使用场景<code>&lt;br /&gt;</code>什么是反射？<code>&lt;br /&gt;</code>反射就是Reflection，Java的反射是指程序在运行期可以拿到一个对象的所有信息。<code>&lt;br /&gt;</code>正常情况下，如果我们要调用一个对象的方法，或者访问一个对象的字段，通常会传入对象实例<code>&lt;br /&gt;</code><img src="https://cdn.nlark.com/yuque/0/2022/png/33764834/1668330137754-9f579263-79ef-448c-b936-986f5a9d54bb.png#averageHue=%23e4e3e3&crop=0&crop=0&crop=1&crop=1&id=BSzas&originHeight=1030&originWidth=2054&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><code>&lt;br /&gt;</code><img src="https://cdn.nlark.com/yuque/0/2022/png/33764834/1668330138272-befffe0c-bb77-47ed-b980-5e0e82b306ca.png#averageHue=%23e3e3e3&crop=0&crop=0&crop=1&crop=1&id=NQJWO&originHeight=821&originWidth=1348&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><code>&lt;br /&gt;</code><img src="https://cdn.nlark.com/yuque/0/2022/png/33764834/1668330138784-357198e1-e840-433d-a747-456dc76c9a44.png#averageHue=%23f6f6f5&crop=0&crop=0&crop=1&crop=1&id=xZUIL&originHeight=497&originWidth=1662&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><code>&lt;br /&gt;</code>一个类在内存中只有一个Class对象<code>&lt;br /&gt;</code>一个类被加载后,类的整个结构都会被封装在Class对象中<code>&lt;br /&gt;</code><img src="https://cdn.nlark.com/yuque/0/2022/png/33764834/1668330139670-2a65d9d4-0d13-45ed-8a92-67dfbea66f2d.png#averageHue=%23e7e5e5&crop=0&crop=0&crop=1&crop=1&id=DvuCJ&originHeight=1192&originWidth=2255&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><code>&lt;br /&gt;</code><img src="https://cdn.nlark.com/yuque/0/2022/png/33764834/1668330140491-81e63274-6db8-4af6-8c3f-5907bdec8473.png#averageHue=%23b9c0e4&crop=0&crop=0&crop=1&crop=1&id=txm1s&originHeight=1159&originWidth=2195&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><code>&lt;br /&gt;</code><img src="https://cdn.nlark.com/yuque/0/2022/png/33764834/1668330141330-6419408f-6dc1-473a-82a0-a3e48e58aaad.png#averageHue=%23f6f6f6&crop=0&crop=0&crop=1&crop=1&id=MdiIO&originHeight=919&originWidth=1839&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><code>&lt;br /&gt;</code>如何获取一个class的Class实例？有三个方法：<code>&lt;br /&gt;</code>方法一：直接通过一个class的静态变量class获取：<code>&lt;br /&gt;</code>方法二：如果我们有一个实例变量，可以通过该实例变量提供的getClass()方法获取：<code>&lt;br /&gt;</code>方法三：如果知道一个class的完整类名，可以通过静态方法Class.forName()获取：<code>&lt;br /&gt;</code>JVM为每个加载的class及interface创建了对应的Class实例来保存class及interface的所有信息；<code>&lt;br /&gt;</code>获取一个class对应的Class实例后，就可以获取该class的所有信息；<code>&lt;br /&gt;</code>通过Class实例获取class信息的方法称为反射（Reflection）；<code>&lt;br /&gt;</code>JVM总是动态加载class，可以在运行期根据条件来控制加载class。<code>&lt;br /&gt;</code>Java的反射API提供的Field类封装了字段的所有信息：<code>&lt;br /&gt;</code>通过Class实例的方法可以获取Field实例：getField()，getFields()，getDeclaredField()，getDeclaredFields()；<code>&lt;br /&gt;</code>通过Field实例可以获取字段信息：getName()，getType()，getModifiers()；<code>&lt;br /&gt;</code>通过Field实例可以读取或设置某个对象的字段，如果存在访问限制，要首先调用setAccessible(true)来访问非public字段。<code>&lt;br /&gt;</code>通过反射读写字段是一种非常规方法，它会破坏对象的封装。</p>
<ol>
<li>I\O流</li>
</ol>
<p>1） 序列化和反序列化的作用<code>&lt;br /&gt;</code>2） 键盘输入的实现方式<code>&lt;br /&gt;</code>3） 避免序列化的方法<code>&lt;br /&gt;</code>4） 字节流和字符流<code>&lt;br /&gt;</code> 序列化和反序列化的作用</p>
<ul>
<li>序列化：把对象转换为字节序列的过程称为对象的序列化.</li>
<li>反序列化：把字节序列恢复为对象的过程称为对象的反序列化.</li>
</ul>
<p>序列化是指把一个Java对象变成二进制内容，本质上就是一个byte[]数组。<code>&lt;br /&gt;</code>为什么要把Java对象序列化呢？<code>&lt;br /&gt;</code>因为序列化后可以把byte[]保存到文件中，或者把byte[]通过网络传输到远程，这样，就相当于把Java对象存储到文件或者通过网络传输出去了。<code>&lt;br /&gt;</code>有序列化，就有反序列化，即把一个二进制内容（也就是byte[]数组）变回Java对象。有了反序列化，保存到文件中的byte[]数组又可以“变回”Java对象，或者从网络上读取byte[]并把它“变回”Java对象。<code>&lt;br /&gt;</code>————————————————<code>&lt;br /&gt;</code>所以序列化和反序列化的作用是：<code>&lt;br /&gt;</code>1、把对象转成JSON、xml 的时候，往往这些接口、方法 都实现了序列化，因为网络传输也是一个二进制的过程，需要进行转换<code>&lt;br /&gt;</code>所以只要我们对内存中的对象进行持久化或网络传输， 这个时候都需要序列化和反序列化.<code>&lt;br /&gt;</code>2、还有一个作用就是把对象的字节序列永久地保存到硬盘上 ，比如通过mybatis可持久化到MySQL，也是实现了序列化的。<code>&lt;br /&gt;</code>————————————————<code>&lt;br /&gt;</code>序列化最重要的作用：在传递和保存对象时.保证对象的完整性和可传递性。对象转换为有序字节流,以便在网络上传输或者保存在本地文件中。<code>&lt;br /&gt;</code>反序列化的最重要的作用：根据字节流中保存的对象状态及描述信息，通过反序列化重建对象。<code>&lt;br /&gt;</code>总结：核心作用就是对象状态的保存和重建。（整个过程核心点就是字节流中所保存的对象状态及描述信息）<code>&lt;br /&gt;</code>————————————————<br><code>&lt;a name=&quot;fpil7&quot;&gt;&lt;/a&gt;</code></p>
<h2 id="序列化的其他特性"><a href="#序列化的其他特性" class="headerlink" title="序列化的其他特性"></a>序列化的其他特性</h2><p><code>&lt;a name=&quot;RbZoI&quot;&gt;&lt;/a&gt;</code></p>
<h3 id="1、static-属性不会被序列化"><a href="#1、static-属性不会被序列化" class="headerlink" title="1、static 属性不会被序列化"></a>1、static 属性不会被序列化</h3><p><code>&lt;a name=&quot;3oJG5&quot;&gt;&lt;/a&gt;</code></p>
<h3 id="2、transient-修饰的属性，也不会被序列化"><a href="#2、transient-修饰的属性，也不会被序列化" class="headerlink" title="2、transient 修饰的属性，也不会被序列化"></a>2、transient 修饰的属性，也不会被序列化</h3><p>二、Java实现序列化和反序列化的过程<code>&lt;br /&gt;</code>1、实现序列化的必备要求：<code>&lt;br /&gt;</code>只有实现了Serializable或者Externalizable接口的类的对象才能被序列化为字节序列。（不是则会抛出异常） <code>&lt;br /&gt;</code>2、JDK中序列化和反序列化的API：<code>&lt;br /&gt;</code>①java.io.ObjectInputStream：对象输入流。<code>&lt;br /&gt;</code>该类的readObject()方法从输入流中读取字节序列，然后将字节序列反序列化为一个对象并返回。<code>&lt;br /&gt;</code>②java.io.ObjectOutputStream：对象输出流。<code>&lt;br /&gt;</code>该类的writeObject(Object obj)方法将将传入的obj对象进行序列化，把得到的字节序列写入到目标输出流中进行输出。<code>&lt;br /&gt;</code>3、实现序列化和反序列化的三种实现：<code>&lt;br /&gt;</code>①若Student类仅仅实现了Serializable接口，则可以按照以下方式进行序列化和反序列化。<code>&lt;br /&gt;</code>ObjectOutputStream采用默认的序列化方式，对Student对象的非transient的实例变量进行序列化。 <code>&lt;br /&gt;</code>ObjcetInputStream采用默认的反序列化方式，对Student对象的非transient的实例变量进行反序列化。<code>&lt;br /&gt;</code>②若Student类仅仅实现了Serializable接口，并且还定义了readObject(ObjectInputStream in)和writeObject(ObjectOutputSteam out)，则采用以下方式进行序列化与反序列化。<code>&lt;br /&gt;</code>ObjectOutputStream调用Student对象的writeObject(ObjectOutputStream out)的方法进行序列化。 <code>&lt;br /&gt;</code>ObjectInputStream会调用Student对象的readObject(ObjectInputStream in)的方法进行反序列化。<code>&lt;br /&gt;</code>③若Student类实现了Externalnalizable接口，且Student类必须实现readExternal(ObjectInput in)和writeExternal(ObjectOutput out)方法，则按照以下方式进行序列化与反序列化。<code>&lt;br /&gt;</code>ObjectOutputStream调用Student对象的writeExternal(ObjectOutput out))的方法进行序列化。 <code>&lt;br /&gt;</code>ObjectInputStream会调用Student对象的readExternal(ObjectInput in)的方法进行反序列化。<code>&lt;br /&gt;</code>三、序列化和反序列化的注意点：<code>&lt;br /&gt;</code>①序列化时，只对对象的状态进行保存，而不管对象的方法。<code>&lt;br /&gt;</code>②当一个父类实现序列化，子类自动实现序列化，不需要显式实现Serializable接口。<code>&lt;br /&gt;</code>③当一个对象的实例变量引用其他对象，序列化该对象时也把引用对象进行序列化。<code>&lt;br /&gt;</code>④并非所有的对象都可以序列化，至于为什么不可以，有很多原因了，比如：<code>&lt;br /&gt;</code>安全方面的原因，比如一个对象拥有private，public等field，对于一个要传输的对象，比如写到文件，或者进行RMI传输等等，在序列化进行传输的过程中，这个对象的private等域是不受保护的；<code>&lt;br /&gt;</code>资源分配方面的原因，比如socket，thread类，如果可以序列化，进行传输或者保存，也无法对他们进行重新的资源分配，而且，也是没有必要这样实现；<code>&lt;br /&gt;</code>⑤声明为static和transient类型的成员数据不能被序列化。因为static代表类的状态，transient代表对象的临时数据。<code>&lt;br /&gt;</code>⑥序列化运行时使用一个称为 serialVersionUID 的版本号与每个可序列化类相关联，该序列号在反序列化过程中用于验证序列化对象的发送者和接收者是否为该对象加载了与序列化兼容的类。为它赋予明确的值。显式地定义serialVersionUID有两种用途。<code>&lt;br /&gt;</code>在某些场合，希望类的不同版本对序列化兼容，因此需要确保类的不同版本具有相同的serialVersionUID。<code>&lt;br /&gt;</code>在某些场合，不希望类的不同版本对序列化兼容，因此需要确保类的不同版本具有不同的serialVersionUID。<code>&lt;br /&gt;</code>⑦Java有很多基础类已经实现了serializable接口，比如String,Vector等。但是也有一些没有实现serializable接口的。<code>&lt;br /&gt;</code>⑧如果一个对象的成员变量是一个对象，那么这个对象的数据成员也会被保存！这是能用序列化解决深拷贝的重要原因。<code>&lt;br /&gt;</code>————————————————<code>&lt;br /&gt;</code> 键盘输入的实现方式</p>
<ul>
<li>System.in和System.out方法</li>
<li><ul>
<li>缺点一: 该方法能获取从键盘输入的字符，但只能针对一个字符的获取 * 缺点二: 获取的只是char类型的。如果想获得int,float等类型的输入,比较麻烦。</li>
</ul>
</li>
<li><br /></li>
<li>InputStreamReader和BufferedReader方法<ul>
<li>优点: 可以获取键盘输入的字符串</li>
<li>缺点: 如何要获取的是int,float等类型的仍然需要转换</li>
</ul>
</li>
<li>Scanner类中的方法<ul>
<li>优点一: 可以获取键盘输入的字符串</li>
<li>优点二: 有现成的获取int,float等类型数据，非常强大，也非常方便；</li>
</ul>
</li>
</ul>
<p> 避免序列化的方法<br><code>&lt;a name=&quot;DwYth&quot;&gt;&lt;/a&gt;</code></p>
<h4 id="方式一：transient-关键字"><a href="#方式一：transient-关键字" class="headerlink" title="方式一：transient 关键字"></a>方式一：transient 关键字</h4><p>对于不想进行序列化的变量，使用 transient 关键字修饰。<code>&lt;br /&gt;</code>transient 关键字的作用是：<code>&lt;br /&gt;</code>阻止实例中那些用此关键字修饰的的变量序列化；  <code>&lt;br /&gt;</code>当对象被反序列化时，被 transient 修饰的变量值不会被持久化和恢复。  <code>&lt;br /&gt;</code>transient 只能修饰变量，不能修饰类和方法。<code>&lt;br /&gt;</code>使用 transient 来描述字段，将不能被序列化和反序列化’<br><code>&lt;a name=&quot;DT2Hq&quot;&gt;&lt;/a&gt;</code></p>
<h4 id="方式二：-Expose注解"><a href="#方式二：-Expose注解" class="headerlink" title="方式二：@Expose注解"></a>方式二：@Expose注解</h4><p>当你不需要完全<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/ab9147150a83">序列化</a>model字段时，我们就可以使用 @Expose 来解决。<code>&lt;br /&gt;</code>@Expose 默认有两个属性：serialize 和 deserialize，默认值都为 true，如果你给字段设置了 @Expose 注解，但是没有设置serialize 和 deserialize，那 model 的字段都将会输出。<br><code>&lt;a name=&quot;nWNSr&quot;&gt;&lt;/a&gt;</code></p>
<h2 id="什么是字节流，什么是字符流"><a href="#什么是字节流，什么是字符流" class="headerlink" title="什么是字节流，什么是字符流"></a>什么是字节流，什么是<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E5%AD%97%E7%AC%A6%E6%B5%81&spm=1001.2101.3001.7020">字符流</a></h2><p>字节流： 它处理单元为1个字节（byte），操作字节和字节数组，存储的是二进制文件，如果是音频文件、图片、歌曲，就用字节流好点（1byte &#x3D; 8位）；<code>&lt;br /&gt;</code>字符流： 它处理的单元为2个字节的Unicode字符，分别操作字符、字符数组或字符串，字符流是由Java虚拟机将字节转化为2个字节的Unicode字符为单位的字符而成的，如果是关系到中文（文本）的，用字符流好点（1Unicode &#x3D; 2字节 &#x3D; 16位）；<code>&lt;br /&gt;</code>所有文件的储存是都是字节（byte）的储存，在磁盘上保留的并不是文件的字符而是先把字符编码成字节，再储存这些字节到磁盘。在读取文件（特别是文本文件）时，也是一个字节一个字节地读取以形成字节序列。<code>&lt;br /&gt;</code>字节流可用于任何类型的对象，包括二进制对象，而字符流只能处理字符或者字符串； 2. 字节流提供了处理任何类型的IO操作的功能，但它不能直接处理Unicode字符，而字符流就可以。<code>&lt;br /&gt;</code>字节流是最基本的，所有的InputStrem和OutputStream的子类都是,主要用在处理二进制数据，它是按字节来处理的 但实际中很多的数据是文本，又提出了字符流的概念，它是按虚拟机的encode来处理，也就是要进行字符集的转化 这两个之间通过 InputStreamReader,OutputStreamWriter来关联，实际上是通过byte[]和String来关联 在实际开发中出现的汉字问题实际上都是在字符流和字节流之间转化不统一而造成的<code>&lt;br /&gt;</code>————————————————<code>&lt;br /&gt;</code><strong>最简单的区分字节流和字符流</strong><code>&lt;br /&gt;</code>万物皆文件，那就将文件在记事本里面打开，如果打开后能看的懂的就是字符流，如果看不懂那就是字节流<code>&lt;br /&gt;</code><img src="https://cdn.nlark.com/yuque/0/2022/png/33764834/1668330141837-ac999bfb-3998-47a2-95d6-80023a8f9118.png#averageHue=%231e1c1c&crop=0&crop=0&crop=1&crop=1&id=RUS5d&originHeight=1061&originWidth=1145&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<ul>
<li>字符流是以Reader，Writer结尾的</li>
<li>字符节流是以InputStream或OutputStream结尾的</li>
<li>字符流是以Reader，Writer结尾的</li>
<li>字符节流是以InputStream或OutputStream结尾的</li>
</ul>
<p>什么是缓存区？<code>&lt;br /&gt;</code>定义：缓存区相当于缓存，它是存在内存中的<code>&lt;br /&gt;</code>写操作：<code>&lt;br /&gt;</code>没有使用缓存区：CPU读取每个字节之后直接操作磁盘（性能比较底）进行写完，写操作的瓶颈就会出现，因为每个字节都会操作一次磁盘<code>&lt;br /&gt;</code>使用缓冲区：那么每次会将字符放入缓存区（内存），等缓冲区满了之后，才一次性写入磁盘<code>&lt;br /&gt;</code>因为内存的操作速度远远大于磁盘，因此带缓冲区的输入流和输出流实现的效率就非常高（比如扔垃圾，一次性扔完和一次次扔肯定消耗的时间是有很大差距的）<code>&lt;br /&gt;</code>————————————————<br><code>&lt;a name=&quot;x7VJj&quot;&gt;&lt;/a&gt;</code></p>
<h4 id="5-1-普通的字符流操作"><a href="#5-1-普通的字符流操作" class="headerlink" title="5.1.普通的字符流操作"></a>5.1.普通的字符流操作</h4><p>在程序中一个字符等于两个字节，那么java提供了Reader、Writer两个专门操作字符流的类。<code>&lt;br /&gt;</code>字符输出流：Writer。  <code>&lt;br /&gt;</code>字符输入流：Reader<code>&lt;br /&gt;</code>字节流操作的基本单元是字节；字符流操作的基本单元为Unicode码元。<code>&lt;br /&gt;</code>字节流在操作的时候本身不会用到缓冲区的，是与文件本身直接操作的；而字符流在操作的时候使用到缓冲区的。<code>&lt;br /&gt;</code>所有文件的存储都是字节(byte)的存储，在磁盘上保留的是字节。<code>&lt;br /&gt;</code>在使用字节流操作中，即使没有关闭资源（close方法），也能输出；而字符流不使用close方法的话，不会输出任何内容<code>&lt;br /&gt;</code>————————————————<code>&lt;br /&gt;</code>io流<code>&lt;br /&gt;</code>IO是指Input&#x2F;Output，即输入和输出。以内存为中心：</p>
<ul>
<li>Input指从外部读入数据到内存，例如，把文件从磁盘读取到内存，从网络读取数据到内存等等。</li>
<li>Output指把数据从内存输出到外部，例如，把数据从内存写入到文件，把数据从内存输出到网络等等。</li>
</ul>
<p>为什么要把数据读到内存才能处理这些数据？<code>&lt;br /&gt;</code>因为代码是在内存中运行的，数据也必须读到内存，最终的表示方式无非是byte数组，字符串等，都必须存放在内存里。<code>&lt;br /&gt;</code>在Java中，InputStream代表输入字节流，OuputStream代表输出字节流，这是最基本的两种IO流<code>&lt;br /&gt;</code>IO流是一种流式的数据输入&#x2F;输出模型：</p>
<ul>
<li>二进制数据以byte为最小单位在InputStream&#x2F;OutputStream中单向流动；</li>
<li>字符数据以char为最小单位在Reader&#x2F;Writer中单向流动。</li>
</ul>
<p>Java标准库的java.io包提供了同步IO功能：</p>
<ul>
<li>字节流接口：InputStream&#x2F;OutputStream；</li>
<li>字符流接口：Reader&#x2F;Writer。</li>
</ul>
<p>File对象有3种形式表示的路径，一种是getPath()，返回构造方法传入的路径，一种是getAbsolutePath()，返回绝对路径，一种是getCanonicalPath，它和绝对路径类似，但是返回的是规范路径。<code>&lt;br /&gt;</code>ile对象既可以表示文件，也可以表示目录。特别要注意的是，构造一个File对象，即使传入的文件或目录不存在，代码也不会出错，因为构造一个File对象，并不会导致任何磁盘操作。只有当我们调用File对象的某些方法的时候，才真正进行磁盘操作。<code>&lt;br /&gt;</code>例如，调用isFile()，判断该File对象是否是一个已存在的文件，调用isDirectory()，判断该File对象是否是一个已存在的目录：<code>&lt;br /&gt;</code>用File对象获取到一个文件时，还可以进一步判断文件的权限和大小：</p>
<ul>
<li>boolean canRead()：是否可读；</li>
<li>boolean canWrite()：是否可写；</li>
<li>boolean canExecute()：是否可执行；</li>
<li>long length()：文件字节大小。</li>
</ul>
<p>对目录而言，是否可执行表示能否列出它包含的文件和子目录。<br><code>&lt;a name=&quot;OA13U&quot;&gt;&lt;/a&gt;</code></p>
<h3 id="创建和删除文件"><a href="#创建和删除文件" class="headerlink" title="创建和删除文件"></a>创建和删除文件</h3><p>当File对象表示一个文件时，可以通过createNewFile()创建一个新文件，用delete()删除该文件：<code>&lt;br /&gt;</code>有些时候，程序需要读写一些临时文件，File对象提供了createTempFile()来创建一个临时文件，以及deleteOnExit()在JVM退出时自动删除该文件。<br><code>&lt;a name=&quot;bb5G5&quot;&gt;&lt;/a&gt;</code></p>
<h3 id="遍历文件和目录"><a href="#遍历文件和目录" class="headerlink" title="遍历文件和目录"></a>遍历文件和目录</h3><p>当File对象表示一个目录时，可以使用list()和listFiles()列出目录下的文件和子目录名。listFiles()提供了一系列重载方法，可以过滤不想要的文件和目录：</p>
<ol>
<li>新特性</li>
</ol>
<p>1） Java8的新特性<code>&lt;br /&gt;</code>2） Streams流<code>&lt;br /&gt;</code>3） Lambda表达式<code>&lt;br /&gt;</code>Java8新特性<code>&lt;br /&gt;</code><img src="https://cdn.nlark.com/yuque/0/2022/png/33764834/1668330142217-e29871e5-f70a-487e-82d2-e6fa42028774.png#averageHue=%23f7f7f7&crop=0&crop=0&crop=1&crop=1&id=uBZ5t&originHeight=957&originWidth=646&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<ul>
<li>速度更快</li>
<li>代码更少(增加了新的语法：<strong>Lambda</strong> <strong>表达式</strong>)</li>
<li>强大的 <strong>Stream API</strong></li>
<li>便于并行</li>
<li>最大化减少空指针异常：Optional</li>
<li>Nashorn引擎，允许在JVM上运行JS应用</li>
</ul>
<p>Lambda 表达式：在Java 8 语言中引入的一种新的语法元素和操作符。这个操作符为 “-&gt;” ， 该操作符被称为 Lambda 操作符 或箭头操作符。它将 Lambda 分为两个部分：<code>&lt;br /&gt;</code>左侧：指定了 Lambda 表达式需要的参数列表 （其实就是接口中的抽象方法的形参列表）<code>&lt;br /&gt;</code><strong>右侧：</strong>指定了 Lambda 体，是抽象方法的实现逻辑，（其实就是重写的抽象方法的方法体）<code>&lt;br /&gt;</code>————————————————<code>&lt;br /&gt;</code>-&gt;左边：lambda形参列表的参数类型可以省略(类型推断)；如果lambda形参列表只有一个参数，其一对()也可以省略<code>&lt;br /&gt;</code>-&gt;右边：lambda体应该使用一对{}包裹；如果lambda体只有一条执行语句（可能是return语句），省略这一对{}和return关键字<code>&lt;br /&gt;</code>Lambda表达式的本质：作为函数式接口的实例<code>&lt;br /&gt;</code>如果一个接口中，只声明了一个抽象方法，则此接口就称为函数式接口。我们可以在一个接口上使用 @FunctionalInterface 注解，这样做可以检查它是否是一个函数式接口。<code>&lt;br /&gt;</code>以前用匿名实现类表示的现在都可以用Lambda表达式来写。<code>&lt;br /&gt;</code>————————————————<code>&lt;br /&gt;</code>类型推断<code>&lt;br /&gt;</code>在Lambda 表达式中的参数类型都是由编译器推断得出的。Lambda 表达式中无需指定类型，程序依然可以编译，这是因为 javac 根据程序的上下文，在后台推断出了参数的类型。Lambda 表达式的类型依赖于上下文环境，是由编译器推断出来的。这就是所谓的“类型推断”。<code>&lt;br /&gt;</code>————————————————<code>&lt;br /&gt;</code><strong>什么是 Stream</strong><code>&lt;br /&gt;</code>Stream到底是什么呢？是数据渠道，用于操作数据源（集合、数组等）所生成的元素序列。<code>&lt;br /&gt;</code>“集合讲的是数据，Stream讲的是计算！”<code>&lt;br /&gt;</code>注意：<code>&lt;br /&gt;</code>①Stream 自己不会存储元素。<code>&lt;br /&gt;</code>②Stream 不会改变源对象。相反，他们会返回一个持有结果的新Stream。<code>&lt;br /&gt;</code>③Stream 操作是延迟执行的。这意味着他们会等到需要结果的时候才执行。<code>&lt;br /&gt;</code>————————————————<code>&lt;br /&gt;</code><img src="https://cdn.nlark.com/yuque/0/2022/png/33764834/1668330142771-2e2e385f-82b1-4bd1-abfb-49372be35578.png#averageHue=%23f3f3f2&crop=0&crop=0&crop=1&crop=1&id=Eu1Uf&originHeight=956&originWidth=1407&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><code>&lt;br /&gt;</code>5.3 Stream创建方式<code>&lt;br /&gt;</code>创建 Stream方式一：通过集合<code>&lt;br /&gt;</code>Java8 中的 Collection 接口被扩展，提供了两个获取流<code>&lt;br /&gt;</code>的方法：<code>&lt;br /&gt;</code>default Stream stream() : 返回一个顺序流<code>&lt;br /&gt;</code>default Stream parallelStream() : 返回一个并行流<code>&lt;br /&gt;</code>————————————————<code>&lt;br /&gt;</code>创建 Stream方式二：通过数组<code>&lt;br /&gt;</code>Java8 中的 Arrays 的静态方法 stream() 可以获取数组流：<code>&lt;br /&gt;</code>static Stream stream(T[] array): 返回一个流<code>&lt;br /&gt;</code>重载形式，能够处理对应基本类型的数组：<code>&lt;br /&gt;</code>public static IntStream stream(int[] array)<code>&lt;br /&gt;</code>public static LongStream stream(long[] array)<code>&lt;br /&gt;</code>public static DoubleStream stream(double[] array)<code>&lt;br /&gt;</code>————————————————<code>&lt;br /&gt;</code><strong>创建 Stream方式三：通过Stream的of()</strong><code>&lt;br /&gt;</code><strong>可以调用Stream类静态方法 of(), 通过显示值创建一个流。它可以接收任意数量的参数。</strong></p>
<ul>
<li><strong>public static Stream of(T… values) :</strong> <strong>返回一个流</strong></li>
</ul>
<p>可以使用静态方法 Stream.iterate() 和 Stream.generate(),创建无限流。<code>&lt;br /&gt;</code>迭代<code>&lt;br /&gt;</code>public static Stream iterate(final T seed, final UnaryOperator f)<code>&lt;br /&gt;</code>生成<code>&lt;br /&gt;</code>public static Stream generate(Supplier s)<code>&lt;br /&gt;</code>————————————————<code>&lt;br /&gt;</code><img src="https://cdn.nlark.com/yuque/0/2022/png/33764834/1668330143281-598d9c0c-c6ee-4f6e-beb6-59dc79f86cfe.png#averageHue=%23bdad93&crop=0&crop=0&crop=1&crop=1&id=v1dLd&originHeight=878&originWidth=1909&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><code>&lt;br /&gt;</code><img src="https://cdn.nlark.com/yuque/0/2022/png/33764834/1668330143962-7c9ebd53-6c36-448e-b917-090d12d7301f.png#averageHue=%23c0cfda&crop=0&crop=0&crop=1&crop=1&id=pwQuc&originHeight=744&originWidth=1481&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><code>&lt;br /&gt;</code><img src="https://cdn.nlark.com/yuque/0/2022/png/33764834/1668330144437-95dd3461-1b0b-4c27-a552-036683df62c7.png#averageHue=%23c6d2d5&crop=0&crop=0&crop=1&crop=1&id=l0ZWX&originHeight=473&originWidth=1340&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><code>&lt;br /&gt;</code><img src="https://cdn.nlark.com/yuque/0/2022/png/33764834/1668330144958-8ba8060d-8dcd-4738-8b32-3191e43479f8.png#averageHue=%23f3f2f2&crop=0&crop=0&crop=1&crop=1&id=MTYjc&originHeight=261&originWidth=1543&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><code>&lt;br /&gt;</code><img src="https://cdn.nlark.com/yuque/0/2022/png/33764834/1668330145378-3af384fa-fe36-4f7f-b226-22df5edbd2cf.png#averageHue=%23c2d1da&crop=0&crop=0&crop=1&crop=1&id=UA5wM&originHeight=1059&originWidth=1468&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><code>&lt;br /&gt;</code><img src="https://cdn.nlark.com/yuque/0/2022/png/33764834/1668330146141-a924105c-073e-4cf8-a224-d8717c5d7450.png#averageHue=%23c2c9c7&crop=0&crop=0&crop=1&crop=1&id=L5rAR&originHeight=431&originWidth=1459&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><code>&lt;br /&gt;</code><img src="https://cdn.nlark.com/yuque/0/2022/png/33764834/1668330146701-2466240f-ee3f-4c65-9924-767e34878834.png#averageHue=%23dee7e7&crop=0&crop=0&crop=1&crop=1&id=wODWq&originHeight=1150&originWidth=1488&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><code>&lt;br /&gt;</code>Date类<code>&lt;br /&gt;</code><img src="https://cdn.nlark.com/yuque/0/2022/png/33764834/1668330147377-b7aa1ffa-2224-495e-af3d-4badabe5e6f8.png#averageHue=%23b0c3dd&crop=0&crop=0&crop=1&crop=1&id=vHZhi&originHeight=776&originWidth=1180&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br><code>&lt;a name=&quot;3mGrc&quot;&gt;&lt;/a&gt;</code></p>
<h2 id="Instant-时间戳"><a href="#Instant-时间戳" class="headerlink" title="Instant 时间戳"></a>Instant 时间戳</h2><p>用于“时间戳”的运算。它是以Unix元年(传统的设定为UTC时区1970年1月1日午夜时分)开始所经历的描述进行运算<br><code>&lt;a name=&quot;3Y9Ex&quot;&gt;&lt;/a&gt;</code></p>
<h2 id="7-3Duration-和-Period"><a href="#7-3Duration-和-Period" class="headerlink" title="7.3Duration 和 Period"></a>7.3Duration 和 Period</h2><p>⚫ Duration:用于计算两个“时间”间隔<code>&lt;br /&gt;</code>⚫ Period:用于计算两个“日期”间隔<br><code>&lt;a name=&quot;vTdzD&quot;&gt;&lt;/a&gt;</code></p>
<h2 id="7-4日期的操纵"><a href="#7-4日期的操纵" class="headerlink" title="7.4日期的操纵"></a>7.4日期的操纵</h2><p>⚫ TemporalAdjuster : 时间校正器。有时我们可能需要获取例如：将日期调整到“下个周日”等操作。<code>&lt;br /&gt;</code>⚫ TemporalAdjusters: 该类通过静态方法提供了大量的常用 TemporalAdjuster 的实现。<br><code>&lt;a name=&quot;dAE4d&quot;&gt;&lt;/a&gt;</code></p>
<h2 id="7-5解析与格式化"><a href="#7-5解析与格式化" class="headerlink" title="7.5解析与格式化"></a>7.5解析与格式化</h2><p>java.time.format.DateTimeFormatter类：该类提供了三种格式化方法：<code>&lt;br /&gt;</code>⚫ 预定义的标准格式<code>&lt;br /&gt;</code>⚫ 语言环境相关的格式<code>&lt;br /&gt;</code>⚫ 自定义的格式<code>&lt;br /&gt;</code>7.6时区的处理<code>&lt;br /&gt;</code>⚫ Java8 中加入了对时区的支持，带时区的时间为分别为：ZonedDate、ZonedTime、ZonedDateTime<code>&lt;br /&gt;</code>其中每个时区都对应着 ID，地区ID都为 “{区域}&#x2F;{城市}”的格式<code>&lt;br /&gt;</code>例如 ：Asia&#x2F;Shanghai 等<code>&lt;br /&gt;</code>ZoneId：该类中包含了所有的时区信息<code>&lt;br /&gt;</code>getAvailableZoneIds() : 可以获取所有时区时区信息<code>&lt;br /&gt;</code>of(id) : 用指定的时区信息获取ZoneId 对象<code>&lt;br /&gt;</code>————————————————<code>&lt;br /&gt;</code><img src="https://cdn.nlark.com/yuque/0/2022/png/33764834/1668330148209-3ff9fd27-6654-45a0-86c8-5d6fb9306ac8.png#averageHue=%23a9bbd6&crop=0&crop=0&crop=1&crop=1&id=sbUhA&originHeight=1159&originWidth=1749&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br><code>&lt;a name=&quot;xYdCw&quot;&gt;&lt;/a&gt;</code></p>
<h1 id="Java8新特性"><a href="#Java8新特性" class="headerlink" title="Java8新特性"></a>Java8新特性</h1><p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6962035387787116551">Java之Java 8新特性 - 掘金 (juejin.cn)</a><code>&lt;br /&gt;</code>——Map的新方法<code>&lt;br /&gt;</code>Map 类型不支持 streams，不过Map提供了一些新的有用的方法来处理一些日常任务。Map接口本身没有可用的 stream（）方法，但是你可以在键，值上创建专门的流或者通过 map.keySet().stream(),map.values().stream()和map.entrySet().stream()。<code>&lt;br /&gt;</code>此外,Maps 支持各种新的和有用的方法来执行常见任务。<code>&lt;br /&gt;</code>————————————————<code>&lt;br /&gt;</code><img src="https://cdn.nlark.com/yuque/0/2022/png/33764834/1668330148717-5656f774-cc0f-46b8-b53d-1a5a64a61c69.png#averageHue=%23f9f8f7&crop=0&crop=0&crop=1&crop=1&id=gyDN5&originHeight=1130&originWidth=1398&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<ol>
<li>异常体系</li>
</ol>
<p>1） 异常层次<code>&lt;br /&gt;</code>2） Throwable 类<code>&lt;br /&gt;</code>3） 异常和错误<br><code>&lt;a name=&quot;7W9Uk&quot;&gt;&lt;/a&gt;</code></p>
<h1 id="什么是异常"><a href="#什么是异常" class="headerlink" title="什么是异常"></a>什么是异常</h1><p><strong>定义：</strong>在程序运行过程中出现的错误，称为异常。异常就是程序运行过程中出现了不正常现象导致程序的中断。<code>&lt;br /&gt;</code>在Java中，把各种异常现象进行了抽象形成了异常类。<code>&lt;br /&gt;</code><img src="https://cdn.nlark.com/yuque/0/2022/png/33764834/1668330149223-73d8d5ad-9f6d-4b0c-8b67-7d13837635bd.png#averageHue=%23fbf7f2&crop=0&crop=0&crop=1&crop=1&id=iL9OJ&originHeight=787&originWidth=1135&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><code>&lt;br /&gt;</code><img src="https://cdn.nlark.com/yuque/0/2022/png/33764834/1668330149744-4e96f416-67b0-44b1-9ea1-6716574adeb9.png#averageHue=%23f7f6f5&crop=0&crop=0&crop=1&crop=1&id=H2Phn&originHeight=824&originWidth=1405&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><code>&lt;br /&gt;</code><img src="https://cdn.nlark.com/yuque/0/2022/png/33764834/1668330150203-d7e2a887-bbee-47a8-a8a5-db72f5ff7c51.png#averageHue=%23c0c0b0&crop=0&crop=0&crop=1&crop=1&id=YXHQs&originHeight=871&originWidth=1562&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><code>&lt;br /&gt;</code><img src="https://cdn.nlark.com/yuque/0/2022/png/33764834/1668330150789-999d19d2-f790-4875-a2db-fe241f3e8ff1.png#averageHue=%234a5a6a&crop=0&crop=0&crop=1&crop=1&id=mvVuV&originHeight=804&originWidth=1551&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br><code>&lt;a name=&quot;OBAS9&quot;&gt;&lt;/a&gt;</code></p>
<h3 id="4-1-3-异常的捕获顺序"><a href="#4-1-3-异常的捕获顺序" class="headerlink" title="4.1.3 异常的捕获顺序"></a>4.1.3 异常的捕获顺序</h3><p>异常的捕获：一般按照由小到大的顺序，也就是先截获子异常，再截获父异常<code>&lt;br /&gt;</code>4.2 throws抛出处理<code>&lt;br /&gt;</code>在定义方法时，如果方法体中有受检（编译时）异常需要预处理，可以捕获处理，也可以抛出处理。<code>&lt;br /&gt;</code>处理异常时，使用throws抛出处理：<code>&lt;br /&gt;</code>谁调用这个方法，谁负责处理该异常<code>&lt;br /&gt;</code>在定义方法时，把异常抛出就是为了提醒方法的使用者，有异常需要预处理<code>&lt;br /&gt;</code>在处理异常时，是选择捕获处理还是抛出处理<code>&lt;br /&gt;</code>一般情况下，在调用其他方法时，如果被调用的方法有受检（编译时）异常需要预处理，选择捕获处理，因为你调用了方法， 你负责处理该异常。<code>&lt;br /&gt;</code>在定义方法时，如果方法体中有受检异常需要预处理，可以选择捕获 ，也可以选择抛出处理。如果方法体中通过throw语句抛出了一个异常对象，所在的方法应该使用throws声明该异常。<code>&lt;br /&gt;</code>————————————————<code>&lt;br /&gt;</code>4.3 getMessage()和printStackTrace()<code>&lt;br /&gt;</code>如何取得异常对象的具体信息，常用的方法主要有两种：<code>&lt;br /&gt;</code>获取异常描述信息<code>&lt;br /&gt;</code>使用异常对象的getMessage()方法，通常用于打印日志时<code>&lt;br /&gt;</code>取得异常的堆栈信息<code>&lt;br /&gt;</code>使用异常对象的printStackTrace()方法，比较适合于程序调试阶段<code>&lt;br /&gt;</code>————————————————<code>&lt;br /&gt;</code>4.4 方法覆盖中的异常处理<code>&lt;br /&gt;</code>方法覆盖(重写)规则：<code>&lt;br /&gt;</code>方法签名必须相同，方法名与参数列表就是方法签名<code>&lt;br /&gt;</code>方法的返回值类型可以相同 ，子类方法的返回值类型也可以是父类方法返回值类型的子类型<code>&lt;br /&gt;</code>子类方法的访问权限可以更宽泛(更大)<code>&lt;br /&gt;</code>a、如果父类方法使用public修饰，子类方法只能是public修饰<code>&lt;br /&gt;</code>b、如果父类方法使用protected修饰，子类方法可以是protected或者public修饰<code>&lt;br /&gt;</code>子类方法的异常要比父类方法的异常更小<code>&lt;br /&gt;</code>a、如果父类方法没有抛出异常，子类重写后也不能抛出异常<code>&lt;br /&gt;</code>b、如果父类方法抛出了异常，子类方法可以抛出相同的异常，也可以抛出父类异常的子异常，也可以不抛出异常<code>&lt;br /&gt;</code>————————————————<br><code>&lt;a name=&quot;MRNvG&quot;&gt;&lt;/a&gt;</code></p>
<h1 id="异常相关的面试题"><a href="#异常相关的面试题" class="headerlink" title="异常相关的面试题"></a>异常相关的面试题</h1><p><code>&lt;a name=&quot;FjgMe&quot;&gt;&lt;/a&gt;</code></p>
<h2 id="5-1-谈谈你Java异常处理机制的理解？"><a href="#5-1-谈谈你Java异常处理机制的理解？" class="headerlink" title="5.1 谈谈你Java异常处理机制的理解？"></a>5.1 谈谈你Java异常处理机制的理解？</h2><p>Java对异常进行了分类，不同类型的异常分别用不同的Java类表示，所有异常的根类为 java.lang.Throwable，Throwable下面又派生了两个子类：Error和Exception。<code>&lt;br /&gt;</code>Error： 表示应用程序本身无法克服和恢复的一种严重问题。<code>&lt;br /&gt;</code>Exception： 表示程序还能够克服和恢复的问题，其中又分为系统异常和普通异常。<code>&lt;br /&gt;</code>系统异常<code>&lt;br /&gt;</code>系统异常是软件本身缺陷所导致的问题，也就是软件开发人员考虑不周所导致的问题，软件使用者无法克服和恢复这种问题，但在这种问题下还可以让软件系统继续运行或者让软件死掉，例如，数组下标越界（ArrayIndexOutOfBoundsException），空指针异常（NullPointerException）、类转换异常（ClassCastException）。<code>&lt;br /&gt;</code>普通异常<code>&lt;br /&gt;</code>普通异常是运行环境的变化或异常所导致的问题，是用户能够克服的问题，例如，网络断线，硬盘空间不够，发生这样的异常后，程序不应该死掉。<code>&lt;br /&gt;</code>————————————————<code>&lt;br /&gt;</code>Java为系统异常和普通异常提供了不同的解决方案，编译器强制普通异常必须try…catch处理或用throws声明继续抛给上层调用方法处理，所以普通异常也称为checked异常，而系统异常可以处理也可以不处理，所以编译器不强制用try…catch处理或用throws声明，所以系统异常也称为unchecked异常。<code>&lt;br /&gt;</code>5.2 throw 和 throws 的区别？<code>&lt;br /&gt;</code>throw<code>&lt;br /&gt;</code>throw 语句用在方法体内，表示抛出异常，由方法体内的语句处理。<code>&lt;br /&gt;</code>throw是具体向外抛出异常的动作，所以它抛出的是一个异常实例，执行throw一定是抛出了某种异常。<code>&lt;br /&gt;</code>throw一般用于抛出自定义异常。<code>&lt;br /&gt;</code>throws<code>&lt;br /&gt;</code>throws语句是用在方法声明后面，表示如果抛出异常，由该方法的调用者来进行异常的处理。<code>&lt;br /&gt;</code>throws主要是声明这个方法会抛出某种类型的异常，让它的使用者要知道需要捕获的异常的类型。<code>&lt;br /&gt;</code>throws表示出现异常的一种可能性，并不一定会发生这种异常。<code>&lt;br /&gt;</code>————————————————<code>&lt;br /&gt;</code>网络图片：<a target="_blank" rel="noopener" href="https://uploadfiles.nowcoder.com/images/20180704/3807435_1530666258064_20577AE82E2EC5D6D44DD2CA01C99BBA">https://uploadfiles.nowcoder.com/images/20180704/3807435_1530666258064_20577AE82E2EC5D6D44DD2CA01C99BBA</a><br><code>&lt;a name=&quot;ka4CG&quot;&gt;&lt;/a&gt;</code></p>
<h2 id="5-3-final、finally、finalize-的区别？"><a href="#5-3-final、finally、finalize-的区别？" class="headerlink" title="5.3 final、finally、finalize 的区别？"></a>5.3 final、finally、finalize 的区别？</h2><p>*<code>&lt;br /&gt;</code>final<code>&lt;br /&gt;</code>用于声明属性，方法和类，分别表示属性不可变，方法不可覆盖，被其修饰的类不可继承。<code>&lt;br /&gt;</code>finally<code>&lt;br /&gt;</code>异常处理语句结构的一部分，表示总是执行。<code>&lt;br /&gt;</code>finalize<code>&lt;br /&gt;</code>finalize 是Object 类的一个方法，所以Java对象都有这个方法，当某Java对象没有更多的引用指向的时候，会被垃圾回收器回收，该对象被回收之前，由垃圾回收器来负责调用此方法，通常在该方法中进行回收前的准备工作。该方法更像是一个对象生命周期的临终方法，当该方法被系统调用则代表该对象即将“死亡”，但是需要注意的是，我们主动行为上去调用该方法并不会导致该对象“死亡”，<code>&lt;br /&gt;</code>————————————————<code>&lt;br /&gt;</code>5.4 Java中异常分为哪些种类？<code>&lt;br /&gt;</code>按照异常需要处理的时机，分为编译时异常(也叫受控异常)也叫 CheckedException 和运行时异常(也叫非受控异常)也叫 UnCheckedException。Java认为Checked异常都是可以被处理的异常，所以Java程序必须显式处理Checked异常。如果程序没有处理Checked 异常，该程序在编译时就会发生错误无法编译。这体现了Java 的设计哲学：没有完善错误处理的代码根本没有机会被执行。<code>&lt;br /&gt;</code>对Checked异常处理方法有两种：<code>&lt;br /&gt;</code>当前方法知道如何处理该异常，则用try…catch块来处理该异常。<code>&lt;br /&gt;</code>当前方法不知道如何处理，则在定义该方法时声明抛出该异常。<code>&lt;br /&gt;</code>对于运行时异常，只有当代码在运行时才发行的异常，编译的时候不需要try…catch。<code>&lt;br /&gt;</code>比如：除数是0和数组下标越界等，其产生频繁，处理麻烦，若显示申明或者捕获将会对程序的可读性和运行效率影响很大。所以由系统自动检测并将它们交给缺省的异常处理程序。当然如果你有处理要求也可以显示捕获它们。<code>&lt;br /&gt;</code>————————————————<code>&lt;br /&gt;</code>5.5 error和exception的区别？<code>&lt;br /&gt;</code>Error类和Exception类的父类都是Throwable类，他们的区别如下：<code>&lt;br /&gt;</code>Error类一般是指与虚拟机相关的问题，如系统崩溃，虚拟机错误，内存空间不足，方法调用栈溢出等。对于这类错误的导致的应用程序中断，仅靠程序本身无法恢复和预防，遇到这样的错误，建议让程序终止。<code>&lt;br /&gt;</code>Exception类表示程序可以处理的异常，可以捕获且可能恢复。这种异常是由与程序设计的不完善而出现的问题，遇到这类异常，应该尽可能处理异常，使程序恢复运行，而不应该随意终止异常。<code>&lt;br /&gt;</code>Exception类又分为未检查异常（UnCheckedException）和受检查的异常(CheckedException)。<code>&lt;br /&gt;</code>运行时异常ArithmeticException，IllegalArgumentException编译能通过，但是一运行就终止了，程序不会处理运行时异常，出现这类异常，程序会终止。<code>&lt;br /&gt;</code>而受检查的异常，要么用 try…catch 捕获，要么用throws字句声明抛出，交给它的父类处理，否则编译不会通过。<code>&lt;br /&gt;</code>————————————————<code>&lt;br /&gt;</code>5.6 说出最常见的5个RuntimeException？<code>&lt;br /&gt;</code>常见的异常有：<code>&lt;br /&gt;</code>java.lang.NullPointerException 空指针异常；出现原因：调用了未经初始化的对象或者是不存在的对象<code>&lt;br /&gt;</code>java.lang.ClassCastException 数据类型转换异常<code>&lt;br /&gt;</code>java.lang.ClassNotFoundException 指定的类找不到；出现原因：类的名称和路径加载错误；通常都是程序试图通过字符串来加载某个类时可能引发异常<code>&lt;br /&gt;</code>java.lang.NoSuchMethodException 方法不存在异常<code>&lt;br /&gt;</code>java.lang.NumberFormatException 字符串转换为数字异常；出现原因：字符型数据中包含非数字型字符<code>&lt;br /&gt;</code>java.lang.IndexOutOfBoundsException 数组角标越界异常，常见于操作数组对象时发生<code>&lt;br /&gt;</code>java.lang.IllegalArgumentException 方法传递参数错误<code>&lt;br /&gt;</code>java.lang.NoClassDefFoundException 未找到类定义错误<code>&lt;br /&gt;</code>SQLException SQL 异常，常见于操作数据库时的 SQL 语句错误<code>&lt;br /&gt;</code>java.lang.InstantiationException 实例化异常<code>&lt;br /&gt;</code>————————————————<br><code>&lt;a name=&quot;qK8RF&quot;&gt;&lt;/a&gt;</code></p>
<h1 id="6-总结"><a href="#6-总结" class="headerlink" title="6 总结"></a>6 总结</h1><p>本文主要对Java中的异常相关的知识，进行了一下总结。</p>
<ul>
<li>异常的分类</li>
<li>受控异常和非受控异常的区别</li>
<li>异常的捕获和抛出处理</li>
<li>异常的捕获顺序，先捕获小的，再捕获大的</li>
<li>方法覆盖和异常的关系</li>
<li>异常的5个关键字try、catch、finally、throws、throw</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/33764834/1668330151238-81c787aa-e2b8-4a1b-97c0-166bd60aee96.png#averageHue=%23fcfbf1&crop=0&crop=0&crop=1&crop=1&id=rppdX&originHeight=394&originWidth=554&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><code>&lt;br /&gt;</code><a target="_blank" rel="noopener" href="https://www.yuque.com/attachments/yuque/0/2022/docx/33764834/1668332908589-eb9de2f3-079d-4b8b-876e-ce1902f16041.docx">Java基础.docx</a></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://xyylegend.github.io">邦尼</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://xyylegend.github.io/2022/12/01/java%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A0/">https://xyylegend.github.io/2022/12/01/java%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A0/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://xyylegend.github.io" target="_blank">邦尼的博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/java/">java</a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/xyylegend/picgo_photo/imgs/05.webp" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/12/01/Java%E7%AC%94%E8%AE%B0/"><img class="prev-cover" src="/./img/04.webp" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">java复习笔记</div></div></a></div><div class="next-post pull-right"><a href="/2022/12/01/%E5%9F%BA%E7%A1%80%E7%AF%87%E8%AE%B2%E4%B9%89/"><img class="next-cover" src="https://cdn.jsdelivr.net/gh/xyylegend/picgo_photo/imgs/09.jpeg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">java宝典基础篇</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2022/12/01/Java%E7%AC%94%E8%AE%B0/" title="java复习笔记"><img class="cover" src="/./img/04.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-12-01</div><div class="title">java复习笔记</div></div></a></div><div><a href="/2022/12/01/%E5%9F%BA%E7%A1%80%E7%AF%87%E8%AE%B2%E4%B9%89/" title="java宝典基础篇"><img class="cover" src="https://cdn.jsdelivr.net/gh/xyylegend/picgo_photo/imgs/09.jpeg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-12-01</div><div class="title">java宝典基础篇</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/./img/toux.webp" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">邦尼</div><div class="author-info__description">太阳尚远，但一定会有</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">12</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">6</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://cdn.jsdelivr.net/gh/xyylegend/picgo_photo/imgs/qq.png" target="_blank" title="QQ"><i class="fab fa-qq"></i></a><a class="social-icon" href="https://cdn.jsdelivr.net/gh/xyylegend/picgo_photo/imgs/wx.png" target="_blank" title="微信"><i class="fab fa-weixin"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">欢迎来到邦尼的博客</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#java%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A0"><span class="toc-number">1.</span> <span class="toc-text">java基础复习</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.1.</span> <span class="toc-text">1. 面向对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.2.</span> <span class="toc-text">2. 多线程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-java%E4%B8%ADjvm-jre-jdk%E4%B8%89%E8%80%85%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">1.3.</span> <span class="toc-text">3.java中jvm ,jre,jdk三者有什么区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-java%E5%88%9D%E5%AD%A6%E8%80%85%E5%AE%B9%E6%98%93%E7%8A%AF%E7%9A%84%E5%87%A0%E4%B8%AA%E9%97%AE%E9%A2%98"><span class="toc-number">1.4.</span> <span class="toc-text">4.java初学者容易犯的几个问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%EF%BC%89%E5%A4%A7%E5%B0%8F%E5%86%99%E9%97%AE%E9%A2%98"><span class="toc-number">1.4.0.1.</span> <span class="toc-text">1）大小写问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%EF%BC%89%E8%B7%AF%E5%BE%84%E9%87%8C%E5%8C%85%E5%90%AB%E7%A9%BA%E6%A0%BC%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">1.4.0.2.</span> <span class="toc-text">2）路径里包含空格的问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%EF%BC%89main-%E6%96%B9%E6%B3%95%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">1.4.0.3.</span> <span class="toc-text">3）main 方法的问题</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-String%E3%80%81StringBuffer%E5%92%8CStringBuilder%E7%B1%BB%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.5.</span> <span class="toc-text">5.String、StringBuffer和StringBuilder类的区别</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">1.5.1.</span> <span class="toc-text">总结</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%EF%BC%9A"><span class="toc-number">1.5.1.1.</span> <span class="toc-text">线程安全：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%9F%E5%BA%A6%EF%BC%9A"><span class="toc-number">1.5.1.2.</span> <span class="toc-text">速度：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E7%8E%AF%E5%A2%83%EF%BC%9A"><span class="toc-number">1.5.1.3.</span> <span class="toc-text">使用环境：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-Java%E7%94%9F%E6%88%90%E9%9A%8F%E6%9C%BA%E6%95%B0%EF%BC%88random-%E5%92%8CRandom%E7%B1%BB%EF%BC%89"><span class="toc-number">1.6.</span> <span class="toc-text">6.Java生成随机数（random()和Random类）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-Java%E6%95%B0%E5%AD%97%E6%A0%BC%E5%BC%8F%E5%8C%96"><span class="toc-number">1.7.</span> <span class="toc-text">7.Java数字格式化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E5%AD%97%E7%9A%84%E6%A0%BC%E5%BC%8F%E5%9C%A8%E8%A7%A3%E5%86%B3%E5%AE%9E%E9%99%85%E9%97%AE%E9%A2%98%E6%97%B6%E4%BD%BF%E7%94%A8%E9%9D%9E%E5%B8%B8%E6%99%AE%E9%81%8D%EF%BC%8C%E8%BF%99%E6%97%B6%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8-DedmalFormat-%E7%B1%BB%E5%AF%B9%E7%BB%93%E6%9E%9C%E8%BF%9B%E8%A1%8C%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%A4%84%E7%90%86"><span class="toc-number">1.7.1.</span> <span class="toc-text">数字的格式在解决实际问题时使用非常普遍，这时可以使用 DedmalFormat 类对结果进行格式化处理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-%E6%95%B0%E7%BB%84%E7%9A%84%E6%80%BB%E7%BB%93"><span class="toc-number">1.8.</span> <span class="toc-text">8.数组的总结</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E6%93%8D%E4%BD%9C"><span class="toc-number">1.8.1.</span> <span class="toc-text">数组操作</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%AF%94%E8%BE%83%E6%95%B0%E7%BB%84"><span class="toc-number">1.8.1.1.</span> <span class="toc-text">1. 比较数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%A1%AB%E5%85%85%E6%95%B0%E7%BB%84"><span class="toc-number">1.8.1.2.</span> <span class="toc-text">2. 填充数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E6%95%B0%E7%BB%84%E6%9F%A5%E6%89%BE"><span class="toc-number">1.8.1.3.</span> <span class="toc-text">3. 数组查找</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E5%A4%8D%E5%88%B6%E6%95%B0%E7%BB%84"><span class="toc-number">1.8.1.4.</span> <span class="toc-text">4. 复制数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-copyOf"><span class="toc-number">1.8.1.5.</span> <span class="toc-text">1) copyOf()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-CopyOfRange"><span class="toc-number">1.8.1.6.</span> <span class="toc-text">2) CopyOfRange()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-arraycopy"><span class="toc-number">1.8.1.7.</span> <span class="toc-text">3) arraycopy()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-clone"><span class="toc-number">1.8.1.8.</span> <span class="toc-text">4) clone()</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E6%8E%92%E5%BA%8F"><span class="toc-number">1.8.2.</span> <span class="toc-text">数组排序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Java-%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9C%89-5-%E7%A7%8D%E5%B8%B8%E8%A7%81%E6%8E%92%E5%BA%8F%E6%96%B9%E6%B3%95%EF%BC%8C%E5%88%86%E5%88%AB%E6%98%AF%EF%BC%9A"><span class="toc-number">1.8.2.1.</span> <span class="toc-text">Java 数组中有 5 种常见排序方法，分别是：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E8%A7%A3%E7%AD%94"><span class="toc-number">1.8.3.</span> <span class="toc-text">常见问题解答</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%A3%B0%E6%98%8E%E6%95%B0%E7%BB%84%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.8.3.1.</span> <span class="toc-text">1. 声明数组需要注意什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%95%B0%E7%BB%84%E5%9C%A8%E5%B9%B3%E6%97%B6%E7%9A%84%E7%A8%8B%E5%BA%8F%E4%BB%A3%E7%A0%81%E4%B8%AD%E4%BD%BF%E7%94%A8%E6%98%AF%E5%90%A6%E9%A2%91%E7%B9%81%EF%BC%9F"><span class="toc-number">1.8.3.2.</span> <span class="toc-text">2. 数组在平时的程序代码中使用是否频繁？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-super%E5%92%8Cthis%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.9.</span> <span class="toc-text">9.super和this的区别</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#super-%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E7%94%A8%E6%B3%95%EF%BC%9A"><span class="toc-number">1.9.1.</span> <span class="toc-text">super 关键字的用法：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#this-%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E7%94%A8%E6%B3%95%EF%BC%9A"><span class="toc-number">1.9.2.</span> <span class="toc-text">this 关键字的用法：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E4%BA%8E-Java-super-%E5%92%8C-this-%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E5%BC%82%E5%90%8C%EF%BC%8C%E5%8F%AF%E7%AE%80%E5%8D%95%E6%80%BB%E7%BB%93%E4%B8%BA%E4%BB%A5%E4%B8%8B%E5%87%A0%E6%9D%A1%E3%80%82"><span class="toc-number">1.9.3.</span> <span class="toc-text">关于 Java super 和 this 关键字的异同，可简单总结为以下几条。</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#10-Java%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%EF%BC%9A%E5%90%91%E4%B8%8A%E8%BD%AC%E5%9E%8B%E5%92%8C%E5%90%91%E4%B8%8B%E8%BD%AC%E5%9E%8B"><span class="toc-number">2.</span> <span class="toc-text">10.Java对象类型转换：向上转型和向下转型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%EF%BC%89%E5%90%91%E4%B8%8A%E8%BD%AC%E5%9E%8B"><span class="toc-number">2.0.1.</span> <span class="toc-text">1）向上转型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%EF%BC%89%E5%90%91%E4%B8%8B%E8%BD%AC%E5%9E%8B"><span class="toc-number">2.0.2.</span> <span class="toc-text">2）向下转型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="toc-number">2.1.</span> <span class="toc-text">11.异常处理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8-Java-%E4%B8%AD%E4%B8%80%E4%B8%AA%E5%BC%82%E5%B8%B8%E7%9A%84%E4%BA%A7%E7%94%9F%EF%BC%8C%E4%B8%BB%E8%A6%81%E6%9C%89%E5%A6%82%E4%B8%8B%E4%B8%89%E7%A7%8D%E5%8E%9F%E5%9B%A0%EF%BC%9A"><span class="toc-number">2.1.1.</span> <span class="toc-text">在 Java 中一个异常的产生，主要有如下三种原因：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-%E7%BB%A7%E6%89%BF"><span class="toc-number">2.2.</span> <span class="toc-text">12.继承</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="toc-number">2.3.</span> <span class="toc-text">13.构造方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%B9%E7%82%B9%EF%BC%9A"><span class="toc-number">2.3.1.</span> <span class="toc-text">特点：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E7%9A%84%E4%BD%9C%E7%94%A8%EF%BC%9A"><span class="toc-number">2.3.2.</span> <span class="toc-text">构造方法的作用：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E7%9A%84%E5%88%86%E7%B1%BB%EF%BC%9A"><span class="toc-number">2.3.3.</span> <span class="toc-text">构造方法的分类：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#java%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A0%E6%80%BB%E7%BB%93"><span class="toc-number">3.</span> <span class="toc-text">java基础复习总结</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E5%92%8C%E5%B8%B8%E8%AF%86"><span class="toc-number">3.1.</span> <span class="toc-text">一.基础概念和常识</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-JVM-vs-JDK-vs-JRE"><span class="toc-number">3.1.1.</span> <span class="toc-text">1. JVM vs JDK vs JRE</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%AF%B4-Java-%E8%AF%AD%E8%A8%80%E2%80%9C%E7%BC%96%E8%AF%91%E4%B8%8E%E8%A7%A3%E9%87%8A%E5%B9%B6%E5%AD%98%E2%80%9D%EF%BC%9F"><span class="toc-number">3.1.2.</span> <span class="toc-text">2. 为什么说 Java 语言“编译与解释并存”？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%96%E8%AF%91%E5%9E%8B%E8%AF%AD%E8%A8%80"><span class="toc-number">3.1.2.1.</span> <span class="toc-text">编译型语言</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E9%87%8A%E5%9E%8B%E8%AF%AD%E8%A8%80"><span class="toc-number">3.1.2.2.</span> <span class="toc-text">解释型语言</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%96%E8%AF%91%E4%B8%8E%E8%A7%A3%E9%87%8A%E5%B9%B6%E5%AD%98"><span class="toc-number">3.1.2.3.</span> <span class="toc-text">编译与解释并存</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%88%E7%BC%96%E8%AF%91%E7%94%9F%E6%88%90%E5%AD%97%E8%8A%82%E7%A0%81-class%E6%96%87%E4%BB%B6"><span class="toc-number">3.1.2.4.</span> <span class="toc-text">先编译生成字节码(.class文件)</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95"><span class="toc-number">3.2.</span> <span class="toc-text">二.基本语法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Java%E6%B3%A8%E8%A7%A3"><span class="toc-number">3.2.1.</span> <span class="toc-text">Java注解</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81Java%E8%87%AA%E5%B8%A6%E7%9A%84%E6%A0%87%E5%87%86%E6%B3%A8%E8%A7%A3"><span class="toc-number">3.2.1.1.</span> <span class="toc-text">1、Java自带的标准注解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81%E5%85%83%E6%B3%A8%E8%A7%A3"><span class="toc-number">3.2.1.2.</span> <span class="toc-text">2、元注解</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#java%E4%B8%AD%E5%AD%97%E7%AC%A6%E5%9E%8B%E5%B8%B8%E9%87%8F%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">3.2.2.</span> <span class="toc-text">java中字符型常量和字符串常量的区别</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%BD%A2%E5%BC%8F%E4%B8%8A"><span class="toc-number">3.2.2.1.</span> <span class="toc-text">1.形式上</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%90%AB%E6%9C%89%E4%B8%8A"><span class="toc-number">3.2.2.2.</span> <span class="toc-text">2.含有上</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%8D%A0%E5%86%85%E5%AD%98%E5%A4%A7%E5%B0%8F"><span class="toc-number">3.2.2.3.</span> <span class="toc-text">3.占内存大小</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E6%A0%87%E8%AF%86%E7%AC%A6%E5%92%8C%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">3.3.</span> <span class="toc-text">Java标识符和关键字的区别</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">3.3.0.1.</span> <span class="toc-text">关键字</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%87%E8%AF%86%E7%AC%A6"><span class="toc-number">3.3.0.2.</span> <span class="toc-text">标识符</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A0%87%E8%AF%86%E7%AC%A6%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-number">3.3.0.2.1.</span> <span class="toc-text">标识符的分类</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%EF%BC%8C%E7%B1%BB%E5%9E%8B%E6%93%A6%E9%99%A4"><span class="toc-number">3.4.</span> <span class="toc-text">泛型，类型擦除</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-%E6%97%A0%E8%BE%B9%E7%95%8C%E9%80%9A%E9%85%8D%E7%AC%A6-lt-gt"><span class="toc-number">3.4.0.1.</span> <span class="toc-text">1.1 无边界通配符 &lt;?&gt;</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-%E5%9B%BA%E5%AE%9A%E4%B8%8A%E8%BE%B9%E7%95%8C%E7%9A%84%E9%80%9A%E9%85%8D%E7%AC%A6-lt-extends-E-gt"><span class="toc-number">3.4.0.2.</span> <span class="toc-text">1.2 固定上边界的通配符 &lt;? extends E&gt;</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-%E5%9B%BA%E5%AE%9A%E4%B8%8B%E8%BE%B9%E7%95%8C%E7%9A%84%E9%80%9A%E9%85%8D%E7%AC%A6-lt-super-E-gt"><span class="toc-number">3.4.0.3.</span> <span class="toc-text">1.3 固定下边界的通配符&lt;? super E&gt;</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E6%B3%9B%E5%9E%8B%E4%B8%8D%E6%98%AF%E5%8D%8F%E5%8F%98%E7%9A%84"><span class="toc-number">3.4.1.</span> <span class="toc-text">1、泛型不是协变的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%B3%9B%E5%9E%8B%E7%9A%84%E7%89%B9%E6%80%A7%E6%89%80%E5%BC%95%E8%B5%B7%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">3.4.2.</span> <span class="toc-text">2 泛型的特性所引起的问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#x3D-x3D-%E5%92%8Cequals"><span class="toc-number">3.5.</span> <span class="toc-text">&#x3D;&#x3D;和equals()</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E4%BA%8Ehashcode%EF%BC%8C%E6%88%91%E4%BB%AC%E4%B8%80%E5%AE%9A%E8%A6%81%E7%9F%A5%E9%81%93%E4%B8%80%E4%B8%AA%E5%8F%A3%E8%AF%80%EF%BC%9A"><span class="toc-number">3.5.1.</span> <span class="toc-text">关于hashcode，我们一定要知道一个口诀：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#hashCode-%E4%B8%8E-equals"><span class="toc-number">3.6.</span> <span class="toc-text">hashCode()与 equals()</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Java%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%B0%81%E8%A3%85%E7%B1%BB%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">4.</span> <span class="toc-text">Java基本数据类型与封装类的区别</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89-%E6%96%B9%E6%B3%95"><span class="toc-number">4.1.</span> <span class="toc-text">三.方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-java%E4%B8%AD%E6%96%B9%E6%B3%95%E7%9A%84%E5%88%86%E7%B1%BB%E5%92%8C%E6%80%A7%E8%B4%A8"><span class="toc-number">4.1.1.</span> <span class="toc-text">1.java中方法的分类和性质</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-number">4.1.2.</span> <span class="toc-text">2.返回值:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E7%9A%84%E7%89%B9%E6%AE%8A%E6%80%A7"><span class="toc-number">4.1.3.</span> <span class="toc-text">3. 静态方法的特殊性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E7%AE%80%E8%BF%B0%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E5%92%8C%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">4.1.4.</span> <span class="toc-text">4.简述静态方法和实例方法的区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E5%80%BC%E4%BC%A0%E9%80%92%EF%BC%9A%E6%98%AF%E6%8C%87%E5%9C%A8%E8%B0%83%E7%94%A8%E5%87%BD%E6%95%B0%E6%97%B6%E5%B0%86%E5%AE%9E%E9%99%85%E5%8F%82%E6%95%B0%E5%A4%8D%E5%88%B6%E4%B8%80%E4%BB%BD%E4%BC%A0%E9%80%92%E5%88%B0%E5%87%BD%E6%95%B0%E4%B8%AD%EF%BC%8C%E8%BF%99%E6%A0%B7%E5%9C%A8%E5%87%BD%E6%95%B0%E4%B8%AD%E5%A6%82%E6%9E%9C%E5%AF%B9%E5%8F%82%E6%95%B0%E8%BF%9B%E8%A1%8C%E4%BF%AE%E6%94%B9%EF%BC%8C%E5%B0%86%E4%B8%8D%E4%BC%9A%E5%BD%B1%E5%93%8D%E5%88%B0%E5%AE%9E%E9%99%85%E5%8F%82%E6%95%B0%E3%80%82"><span class="toc-number">4.2.</span> <span class="toc-text">一、值传递：是指在调用函数时将实际参数复制一份传递到函数中，这样在函数中如果对参数进行修改，将不会影响到实际参数。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92%EF%BC%9A%E6%98%AF%E6%8C%87%E5%9C%A8%E8%B0%83%E7%94%A8%E5%87%BD%E6%95%B0%E6%97%B6%E5%B0%86%E5%AE%9E%E9%99%85%E5%8F%82%E6%95%B0%E7%9A%84%E5%9C%B0%E5%9D%80%E4%BC%A0%E9%80%92%E5%88%B0%E5%87%BD%E6%95%B0%E4%B8%AD%EF%BC%8C%E9%82%A3%E4%B9%88%E5%9C%A8%E5%87%BD%E6%95%B0%E4%B8%AD%E5%AF%B9%E5%8F%82%E6%95%B0%E6%89%80%E8%BF%9B%E8%A1%8C%E7%9A%84%E4%BF%AE%E6%94%B9%EF%BC%8C%E5%B0%86%E5%BD%B1%E5%93%8D%E5%88%B0%E5%AE%9E%E9%99%85%E5%8F%82%E6%95%B0%E3%80%82"><span class="toc-number">4.3.</span> <span class="toc-text">二、引用传递：是指在调用函数时将实际参数的地址传递到函数中，那么在函数中对参数所进行的修改，将影响到实际参数。</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E4%BA%8E%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92%EF%BC%8C%E5%BD%A2%E5%BC%8F%E5%8F%82%E6%95%B0%E7%9A%84%E6%94%B9%E5%8F%98%EF%BC%8C%E5%BD%B1%E5%93%8D%E5%AE%9E%E9%99%85%E5%8F%82%E6%95%B0%E7%9A%84%E5%80%BC%E3%80%82"><span class="toc-number">4.3.1.</span> <span class="toc-text">对于引用类型的参数传递，形式参数的改变，影响实际参数的值。</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Java%E6%96%B9%E6%B3%95%E9%87%8D%E8%BD%BD"><span class="toc-number">5.</span> <span class="toc-text">Java方法重载</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Java%E6%96%B9%E6%B3%95%E9%87%8D%E5%86%99"><span class="toc-number">6.</span> <span class="toc-text">Java方法重写</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E4%B8%8E%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%9A%84%E5%8C%BA%E5%88%AB%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">7.</span> <span class="toc-text">成员变量与局部变量的区别有哪些？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#java%E4%B8%AD%E5%AF%B9%E8%B1%A1%E5%AE%9E%E4%BD%93%E4%B8%8E%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%BC%95%E7%94%A8%E6%9C%89%E4%BD%95%E4%B8%8D%E5%90%8C%EF%BC%9F"><span class="toc-number">8.</span> <span class="toc-text">java中对象实体与对象的引用有何不同？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%81%E8%A3%85-Encapsulation-%EF%BC%9A"><span class="toc-number">8.0.1.</span> <span class="toc-text">封装(Encapsulation) ：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">8.0.1.1.</span> <span class="toc-text">继承的优缺点</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BA%8F%E5%88%97%E5%8C%96%E7%9A%84%E5%85%B6%E4%BB%96%E7%89%B9%E6%80%A7"><span class="toc-number">8.1.</span> <span class="toc-text">序列化的其他特性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81static-%E5%B1%9E%E6%80%A7%E4%B8%8D%E4%BC%9A%E8%A2%AB%E5%BA%8F%E5%88%97%E5%8C%96"><span class="toc-number">8.1.1.</span> <span class="toc-text">1、static 属性不会被序列化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81transient-%E4%BF%AE%E9%A5%B0%E7%9A%84%E5%B1%9E%E6%80%A7%EF%BC%8C%E4%B9%9F%E4%B8%8D%E4%BC%9A%E8%A2%AB%E5%BA%8F%E5%88%97%E5%8C%96"><span class="toc-number">8.1.2.</span> <span class="toc-text">2、transient 修饰的属性，也不会被序列化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E5%BC%8F%E4%B8%80%EF%BC%9Atransient-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">8.1.2.1.</span> <span class="toc-text">方式一：transient 关键字</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E5%BC%8F%E4%BA%8C%EF%BC%9A-Expose%E6%B3%A8%E8%A7%A3"><span class="toc-number">8.1.2.2.</span> <span class="toc-text">方式二：@Expose注解</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%AD%97%E8%8A%82%E6%B5%81%EF%BC%8C%E4%BB%80%E4%B9%88%E6%98%AF%E5%AD%97%E7%AC%A6%E6%B5%81"><span class="toc-number">8.2.</span> <span class="toc-text">什么是字节流，什么是字符流</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-1-%E6%99%AE%E9%80%9A%E7%9A%84%E5%AD%97%E7%AC%A6%E6%B5%81%E6%93%8D%E4%BD%9C"><span class="toc-number">8.2.0.1.</span> <span class="toc-text">5.1.普通的字符流操作</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%92%8C%E5%88%A0%E9%99%A4%E6%96%87%E4%BB%B6"><span class="toc-number">8.2.1.</span> <span class="toc-text">创建和删除文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%81%8D%E5%8E%86%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95"><span class="toc-number">8.2.2.</span> <span class="toc-text">遍历文件和目录</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Instant-%E6%97%B6%E9%97%B4%E6%88%B3"><span class="toc-number">8.3.</span> <span class="toc-text">Instant 时间戳</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-3Duration-%E5%92%8C-Period"><span class="toc-number">8.4.</span> <span class="toc-text">7.3Duration 和 Period</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-4%E6%97%A5%E6%9C%9F%E7%9A%84%E6%93%8D%E7%BA%B5"><span class="toc-number">8.5.</span> <span class="toc-text">7.4日期的操纵</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-5%E8%A7%A3%E6%9E%90%E4%B8%8E%E6%A0%BC%E5%BC%8F%E5%8C%96"><span class="toc-number">8.6.</span> <span class="toc-text">7.5解析与格式化</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Java8%E6%96%B0%E7%89%B9%E6%80%A7"><span class="toc-number">9.</span> <span class="toc-text">Java8新特性</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%BC%82%E5%B8%B8"><span class="toc-number">10.</span> <span class="toc-text">什么是异常</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-3-%E5%BC%82%E5%B8%B8%E7%9A%84%E6%8D%95%E8%8E%B7%E9%A1%BA%E5%BA%8F"><span class="toc-number">10.0.1.</span> <span class="toc-text">4.1.3 异常的捕获顺序</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E7%9B%B8%E5%85%B3%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-number">11.</span> <span class="toc-text">异常相关的面试题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#5-1-%E8%B0%88%E8%B0%88%E4%BD%A0Java%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9F"><span class="toc-number">11.1.</span> <span class="toc-text">5.1 谈谈你Java异常处理机制的理解？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-3-final%E3%80%81finally%E3%80%81finalize-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">11.2.</span> <span class="toc-text">5.3 final、finally、finalize 的区别？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6-%E6%80%BB%E7%BB%93"><span class="toc-number">12.</span> <span class="toc-text">6 总结</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/12/08/redis%E5%BB%B6%E6%97%B6%E5%8F%8C%E5%88%A0/" title="redis延时双删"><img src="https://cdn.jsdelivr.net/gh/xyylegend/picgo_photo/imgs/05.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="redis延时双删"/></a><div class="content"><a class="title" href="/2022/12/08/redis%E5%BB%B6%E6%97%B6%E5%8F%8C%E5%88%A0/" title="redis延时双删">redis延时双删</a><time datetime="2022-12-08T13:38:33.000Z" title="发表于 2022-12-08 21:38:33">2022-12-08</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/12/07/springboot%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E5%8E%9F%E7%90%86/" title="springboot自动装配原理"><img src="https://cdn.jsdelivr.net/gh/xyylegend/picgo_photo/imgs/08.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="springboot自动装配原理"/></a><div class="content"><a class="title" href="/2022/12/07/springboot%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E5%8E%9F%E7%90%86/" title="springboot自动装配原理">springboot自动装配原理</a><time datetime="2022-12-07T11:17:33.000Z" title="发表于 2022-12-07 19:17:33">2022-12-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/12/06/redis%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F/" title="reids缓存"><img src="https://cdn.jsdelivr.net/gh/xyylegend/picgo_photo/imgs/05.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="reids缓存"/></a><div class="content"><a class="title" href="/2022/12/06/redis%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F/" title="reids缓存">reids缓存</a><time datetime="2022-12-06T12:47:33.000Z" title="发表于 2022-12-06 20:47:33">2022-12-06</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/12/06/%E4%BB%80%E4%B9%88%E6%98%AF%20Redis%EF%BC%9F/" title="reids常见的应用场景"><img src="/./img/04.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="reids常见的应用场景"/></a><div class="content"><a class="title" href="/2022/12/06/%E4%BB%80%E4%B9%88%E6%98%AF%20Redis%EF%BC%9F/" title="reids常见的应用场景">reids常见的应用场景</a><time datetime="2022-12-06T12:47:33.000Z" title="发表于 2022-12-06 20:47:33">2022-12-06</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/12/04/Redis/" title="redis学习笔记"><img src="/./img/04.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="redis学习笔记"/></a><div class="content"><a class="title" href="/2022/12/04/Redis/" title="redis学习笔记">redis学习笔记</a><time datetime="2022-12-04T14:55:33.000Z" title="发表于 2022-12-04 22:55:33">2022-12-04</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2022 - 2023 By 邦尼</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><script src="/js/search/local-search.js"></script><div class="js-pjax"></div><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/fireworks.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>