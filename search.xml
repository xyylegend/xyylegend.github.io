<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>redis延时双删</title>
      <link href="/2022/12/08/redis%E5%BB%B6%E6%97%B6%E5%8F%8C%E5%88%A0/"/>
      <url>/2022/12/08/redis%E5%BB%B6%E6%97%B6%E5%8F%8C%E5%88%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="redis延时双删"><a href="#redis延时双删" class="headerlink" title="redis延时双删"></a>redis延时双删</h1><pre><code>**在使用redis时，需要保持redis和数据库数据的一致性，最流行的解决方案之一就是延时双删策略，今天我们就来详细刨析一下</code></pre><p>注意：要知道经常修改的数据表不适合使用redis，因为双删策略执行的结果是把redis中保存的那条数据删除了，以后的查询就都会去查询数据库。所以redis使用的是读远远大于改的数据缓存。**</p><p><strong>1，首先要理解在并发环境下redis数据一致性的问题所在</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">在多线程并发情况下，假设有两个数据库修改请求，为保证数据库与redis的数据一致性，</span><br><span class="line">修改请求的实现中需要修改数据库后，级联修改redis中的数据。</span><br><span class="line">请求一：<span class="number">1.1</span>修改数据库数据<span class="number">1.2</span> 修改redis数据</span><br><span class="line">请求二：<span class="number">2.1</span>修改数据库数据<span class="number">2.2</span> 修改redis数据</span><br><span class="line">并发情况下就会存在<span class="number">1.1</span> ---&gt; <span class="number">2.1</span> ---&gt; <span class="number">2.2</span> ---&gt; <span class="number">1.2</span>的情况 </span><br><span class="line">（一定要理解线程并发执行多组原子操作执行顺序是可能存在交叉现象的）</span><br><span class="line"></span><br><span class="line">此时存在的问题就是：</span><br><span class="line"><span class="number">1.1</span>修改数据库的数据最终保存到了redis中，<span class="number">2.1</span>在<span class="number">1.1</span>之后也修改了数据库数据。</span><br><span class="line">此时出现了redis中数据和数据库数据不一致的情况，在后面的查询过程中就会长时间去先查redis，</span><br><span class="line">从而出现查询到的数据并不是数据库中的真实数据的严重问题。</span><br><span class="line">问题解决：</span><br><span class="line">修改数据库级联修改redis数据改为  修改数据库数据后级联删除redis数据</span><br><span class="line">至于是先执行<span class="number">1.2</span>的redis删除，还是限制性<span class="number">2.2</span>的redis删除，无关紧要。</span><br><span class="line">结果都是redis中数据已被删除。之后的查询就会由于redis中没有数据而去查数据库，</span><br><span class="line">此时即不会存在查询到的数据和数据库的数据不一致的情况。</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>2，上面详解了redis数据一致性的问题所在，并提供了单删策略来解决问题但此时依然存在比较严重的问题</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">上面的单删策略情况如下：</span><br><span class="line">修改请求的实现中需要修改数据库后，级联删除redis中的数据。</span><br><span class="line">请求一：<span class="number">1.1</span>修改数据库数据<span class="number">1.2</span> 删除redis数据</span><br><span class="line">请求二：<span class="number">2.1</span>修改数据库数据<span class="number">2.2</span> 删除redis数据</span><br><span class="line"></span><br><span class="line">假设现在并发存在一个查询请求</span><br><span class="line">请求三：<span class="number">3.1</span>查询redis中数据   <span class="number">3.2</span>查询数据库数据    <span class="number">3.3</span> 新查到的数据写入redis</span><br><span class="line">（一定要理解带redis的查询请求实现逻辑，先查redis，数据不存在查数据库，</span><br><span class="line">查到的数据写入redis以便以后的查询不去直接查数据库）</span><br><span class="line"></span><br><span class="line">此时并发情况下就会存在<span class="number">1.1</span> ---&gt; <span class="number">1.2</span> ---&gt; <span class="number">3.1</span> ---&gt; <span class="number">3.2</span> ---&gt; <span class="number">2.1</span> ---&gt; <span class="number">2.2</span> ---&gt; <span class="number">3.3</span>的情况 </span><br><span class="line"></span><br><span class="line">此时存在的问题就是：</span><br><span class="line">此时数据库中的数据保存的是<span class="number">2.1</span>修改后的数据，而redis中保存的数据是<span class="number">3.2</span>中在<span class="number">1.1</span>修改数据后的结果，</span><br><span class="line">此时出现了redis中数据和数据库数据不一致的情况，在后面的查询过程中就会长时间去先查redis，</span><br><span class="line">从而出现查询到的数据并不是数据库中的真实数据的严重问题。</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>3，上面刨析到了单删策略来解决redis数据一致性存在的问题，下面我们来说双删策略</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">上面的单删策略存在问题的情况如下：</span><br><span class="line">请求一：<span class="number">1.1</span>修改数据库数据<span class="number">1.2</span> 删除redis数据</span><br><span class="line">请求二：<span class="number">2.1</span>修改数据库数据<span class="number">2.2</span> 删除redis数据</span><br><span class="line">请求三：<span class="number">3.1</span>查询redis中数据   <span class="number">3.2</span>查询数据库数据    <span class="number">3.3</span> 新查到的数据写入redis</span><br><span class="line"></span><br><span class="line">添加延时双删策略后的情况</span><br><span class="line">请求一：<span class="number">1.1</span>修改数据库数据<span class="number">1.2</span> 删除redis数据    <span class="number">1.3</span> 延时<span class="number">3</span>--5s再去删除redis中数据</span><br><span class="line">请求二：<span class="number">2.1</span>修改数据库数据<span class="number">2.2</span> 删除redis数据    <span class="number">2.3</span> 延时<span class="number">3</span>--5s再去删除redis中数据</span><br><span class="line">请求三：<span class="number">3.1</span>查询redis中数据     <span class="number">3.2</span> 查询数据库数据    <span class="number">3.3</span> 新查到的数据写入redis</span><br><span class="line"></span><br><span class="line">双删策略为什么能解决问题：</span><br><span class="line">因为存在了延时时间，故<span class="number">1.3</span>或<span class="number">2.3</span> 一定是最后执行的一步操作（并发中的延时一定要理解）</span><br><span class="line">延时的根本目的就是为了让程序先把<span class="number">3.3</span>执行完，再去删除redis</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>4，如何实现延时3–5s的操作</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">比较好的：   项目整合quartz等定时任务框架，去实现延时<span class="number">3</span>--5s再去执行最后一步任务</span><br><span class="line">比较一般的：  创建线程池，线程池中拿一个线程，线程体中延时<span class="number">3</span>-5s再去执行最后一步任务（不能忘了启动线程）</span><br><span class="line">比较差的：   单独创建一个线程去实现延时执行</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>springboot自动装配原理</title>
      <link href="/2022/12/07/springboot%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E5%8E%9F%E7%90%86/"/>
      <url>/2022/12/07/springboot%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="springboot自动装配原理"><a href="#springboot自动装配原理" class="headerlink" title="springboot自动装配原理"></a>springboot自动装配原理</h1><h2 id="1-什么是springboot自动装配"><a href="#1-什么是springboot自动装配" class="headerlink" title="1.什么是springboot自动装配"></a>1.什么是springboot自动装配</h2><pre><code>SpringBoot的自动装配是指：SpringBoot会自动将一些配置类的bean注册到ioc容器，我们可以在需要的地方使用@Autowired或@Resource等注解来使用它。</code></pre><p>其实自动装配可以简单的理解为：<strong>通过注解或者一些简单的配置就能在spring boot的帮助下实现某款功能。</strong></p><h2 id="2-自动装配原理"><a href="#2-自动装配原理" class="headerlink" title="2.自动装配原理"></a>2.自动装配原理</h2><p>1.@@SpringBootApplication 是一个组合注解，由 @ComponentScan、@EnableAutoConfiguration 和 @SpringBootConfiguration 组成</p><ul><li><p>@SpringBootConfiguration 与普通 @Configuration 相比，唯一区别是前者要求整个 app 中只出现一次</p></li><li><p>@ComponentScan</p><ul><li>excludeFilters - 用来在组件扫描时进行排除，也会排除自动配置类</li></ul></li><li><p>@EnableAutoConfiguration 也是一个组合注解，由下面注解组成（<strong>重头戏——自动装配核心</strong>）</p><ul><li>@AutoConfigurationPackage – 用来记住扫描的起始包</li><li>@Import(AutoConfigurationImportSelector.class) 用来加载 <code>META-INF/spring.factories</code> 中的自动配置类</li></ul></li></ul><p>@EnableAutoConfiguration 作用</p><ul><li>一旦加上此注解，那么将会开启自动装配功能，简单点讲，Spring会试图在自己的classpath（类路径）下找到所有配置的Bean然后进行装配。</li><li>装配Bean时，会根据若干个(Conditional)定制规则来进行初始化。我们看一下它的源码</li></ul><p><img src="https://cdn.jsdelivr.net/gh/xyylegend/picgo_photo/imgs/1670412558293.png"></p><p><strong>通过@Import注解导入AutoConfigurationImportSelector.class自动装配类</strong></p><p><img src="https://cdn.jsdelivr.net/gh/xyylegend/picgo_photo/imgs/1670405876464.png"></p><p><strong>该类实现了DeferredImportSelector接口</strong></p><p><img src="https://cdn.jsdelivr.net/gh/xyylegend/picgo_photo/imgs/1670405965267.png"></p><p><strong>DeferredImportSelector接口继承了 ImportSelector接口</strong></p><ul><li>该接口主要是为了导入@Configuration的配置项，而DeferredImportSelector是延期导入，当所有的@Configuration都处理过后才会执行。</li><li>回过头来我们看一下<strong>AutoConfigurationImportSelector的自动配备核心方法 selectImport</strong></li></ul><p><img src="https://cdn.jsdelivr.net/gh/xyylegend/picgo_photo/imgs/1670406301700.png"></p><ul><li>该方法刚开始会先判断是否进行自动装配，而后会从META-INF&#x2F;spring-autoconfigure-metadata.properties读取元数据与元数据的相关属性，紧接着会调用getCandidateConfigurations方法</li></ul><p><img src="https://cdn.jsdelivr.net/gh/xyylegend/picgo_photo/imgs/1670406462502.png"></p><ul><li>在这里又遇到我们的老熟人了<strong>SpringFactoryiesLoader</strong>, 它会读取META-INF&#x2F;spring.factories下的EnableAutoConfiguration的配置，紧接着在进行排除与过滤，进而得到需要装配的类。最后让所有配置在META-INF&#x2F;spring.factories下的AutoConfigurationImportListener执行AutoConfigurationImportEvent事件，代码如下：</li></ul><p><img src="https://cdn.jsdelivr.net/gh/xyylegend/picgo_photo/imgs/1670406657250.png"></p><h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>自动装配还是利用了SpringFactoriesLoader来加载META-INF&#x2F;spring.factoires文件里所有配置的EnableAutoConfgruation，它会经过exclude和filter等操作，最终确定要装配的类</p><h2 id="为什么不使用-Import-直接引入自动配置类"><a href="#为什么不使用-Import-直接引入自动配置类" class="headerlink" title="为什么不使用 @Import 直接引入自动配置类"></a>为什么不使用 @Import 直接引入自动配置类</h2><p>有两个原因：</p><ol><li>让主配置类和自动配置类变成了强耦合，主配置类不应该知道有哪些从属配置</li><li>直接用 <code>@Import(自动配置类.class)</code>，引入的配置解析优先级较高，自动配置类的解析应该在主配置没提供时作为默认配置</li></ol><p>因此，采用了 <code>@Import(AutoConfigurationImportSelector.class)</code></p><ul><li>由 <code>AutoConfigurationImportSelector.class</code> 去读取 <code>META-INF/spring.factories</code> 中的自动配置类，实现了弱耦合。</li><li>另外 <code>AutoConfigurationImportSelector.class</code> 实现了 DeferredImportSelector 接口，让自动配置的解析晚于主配置的解析</li></ul>]]></content>
      
      
      <categories>
          
          <category> springboot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springboot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>reids缓存</title>
      <link href="/2022/12/06/redis%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F/"/>
      <url>/2022/12/06/redis%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="1-redis缓存穿透"><a href="#1-redis缓存穿透" class="headerlink" title="1.redis缓存穿透"></a>1.redis缓存穿透</h1><p> 缓存穿透指的是缓存查询的key不存在，数据库也无数据（即缓存中没有数据，数据库中也没有数据）</p><p><strong>产生原因：</strong></p><ul><li>业务层误操作：缓存中的数据和数据库中的数据被误删除了，所以缓存和数据库中都没有数据；</li><li>恶意攻击：专门访问数据库中没有的数据。</li></ul><p><strong>解决方法：</strong></p><p>（1）DB中查询不到数据的情况，可以将该key对应的value设为null值，或其他特殊值，同时设置短一点的过过期时间，以免影响正常情况。该方法可以防止短时间内同一个key进行暴力攻击。</p><p>（2）布隆过滤器，利用高效的数据结构和算法快速判断该key是否存在数据库，不存在就return，存在就去查询DB数据库刷新KV再return。</p><p>（3）若只是恶意者故意攻击，可以在nginx配置对攻击者ip设置访问阈值。</p><h1 id="2-redis缓存击穿"><a href="#2-redis缓存击穿" class="headerlink" title="2.redis缓存击穿"></a>2.redis缓存击穿</h1><p> 缓存击穿是指，针对某个访问非常频繁的热点数据的请求，无法在缓存中进行处理，紧接着，访问该数据的大量请求，一下子都发送到了后端数据库，导致了数据库压力激增，会影响数据库处理其他请求。（即缓存中没有数据，数据库中有数据。）</p><p><strong>产生原因：</strong> 经常发生在热点数据过期失效</p><p><strong>解决方法：</strong></p><p>（1）为了避免缓存击穿给数据库带来的激增压力，我们的解决方法也比较直接，对于访问特别频繁的热点数据，我们就不设置过期时间了。这样一来，对热点数据的访问请求，都可以在缓存中进行处理，而 Redis 数万级别的高吞吐量可以很好地应对大量的并发请求访问。</p><p>（2）加互斥锁（缓存中没有数据，第1个进入的线程，获取锁并从数据库去取数据，没释放锁之前，其他并行进入的线程会等待100ms，再重新去缓存取数据。这样就防止都去数据库重复取数据，重复往缓存中更新数据情况出现）</p><h1 id="3-redis缓存雪崩"><a href="#3-redis缓存雪崩" class="headerlink" title="3.redis缓存雪崩"></a>3.redis缓存雪崩</h1><p>缓存雪崩是指大量的应用请求无法在 Redis 缓存中进行处理，紧接着，应用将大量请求发送到数据库层，导致数据库层的压力激增。</p><p><strong>产生原因：</strong></p><ul><li>缓存中有大量数据同时过期，导致大量请求无法得到处理</li><li>Redis 缓存实例发生故障宕机了</li></ul><p><strong>解决方法：</strong></p><p> 1.使用缓存集群，保证缓存高可用。<br>2.使用Hystrix，通过熔断、降级、限流三个手段降低雪崩后发生的损失。<br>3.设置不同的过期时间。<br>4.数据预热。在正式部署前，先把可能的数据预先访问一遍，将可能被访问到的数据提前加载到缓存。</p>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>reids常见的应用场景</title>
      <link href="/2022/12/06/%E4%BB%80%E4%B9%88%E6%98%AF%20Redis%EF%BC%9F/"/>
      <url>/2022/12/06/%E4%BB%80%E4%B9%88%E6%98%AF%20Redis%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是-Redis？Redis-有哪些特点？Redis-有哪些常见的应用场景？"><a href="#什么是-Redis？Redis-有哪些特点？Redis-有哪些常见的应用场景？" class="headerlink" title="什么是 Redis？Redis 有哪些特点？Redis 有哪些常见的应用场景？"></a>什么是 Redis？Redis 有哪些特点？Redis 有哪些常见的应用场景？</h2><p>Redis是一个基于Key-Value存储结构的Nosql开源内存数据库。<br>它提供了5种常用的数据类型，string、list、set、zset、hash。<br>针对不同的结构，可以解决不同场景的问题。<br>因此它可以覆盖应用开发中大部分的业务场景，比如top10问题(zset)、好友关注列表(set)、热点话题(string)等。<br>其次，由于Redis是基于内存存储，并且在数据结构上做了大量的优化所以IO<br>性能比较好，在实际开发中，会把它作为应用与数据库之间的一个分布式缓存组<br>件。<br>并且它又是一个非关系型数据的存储，不存在表之间的关联查询问题，所以它可<br>以很好的提升应用程序的数据IO效率。<br>最后，作为企业级开发来说，它又提供了主从复制+哨兵、以及集群方式实现高<br>可用，在Redis集群里面，通过slot槽的方式实现了数据分片，进一步提升了性<br>能。</p><p>补充一下redis的五大基本数据类型包括string、list、set、zset（sorted set）、hash；另外，三大特殊数据类型包括bitmap、geosaptial、HyperLoLog。<br><strong>string</strong>的数据结构是简单的<strong>key-value类型</strong>。<br>常用命令：set、get、mset（批量设置）、mget（批量获取）、exists（判断key存在与否）、incr（自增）、decr（自减）、setex（为key设置过期时间）、setnx（若不存在，则创建key）<br>应用场景： 一般常用在需要<strong>计数</strong>的场景，比如用户的<strong>访问次数</strong>、热点文章的<strong>点赞转发</strong>数量等<br>list： Redis的list是双向链表，可实现栈、队列、阻塞队列的数据结构。<br>常用命令：lpush、lpop（左进左出）、rpush、rpop（右进右出）、lrange（list获取范围内的元素）、llen（查看元素个数）、linsert（插入）<br>应用场景：<strong>发布与订阅</strong>或者说<strong>消息队列</strong>、<strong>慢查询</strong><br>set： set类似于java中的HashSet，集合内的元素无序不可重复。相对于list，set集合提供了判断某个成员是否存在的重要接口，并可实现交集、并集、差集操作。<br>常用命令：sadd、spop（添加、弹出）、smembers（查看所有成员）、sismember（判断某个成员是否存在）、scard（元素个数）、sinter、sunion、sdiff（交并差操作）等<br>应用场景：可实现<strong>共同</strong>粉丝、共同关注、共同爱好等功能<br>szet： 和set相比，sorted set多了个权重参数score ，使得集合中的元素能够按score进行有序排序，还可通过score的范围获取元素的列表。<br>常用命令：zadd、zrem（增加删除）、zcard（元素个数）、zrange（获取某一范围的元素）、zrevrange（升序获取）<br>应用场景：需要对数据根据权重进行排序的场景，如直播系统中，<strong>实时排行</strong>信息包括在线用户列表， 礼物排行榜、<strong>弹幕消息</strong>等<br>hash： hash类似jdk1.8之前的HashMap，是一个string类型的key和value的映射表，特别适合存储对象。<br>常用命令：hset、hget、hmset、hmget（批量设置获取）、hkeys（获取所有key）、hvals（获取所有value）、hgetall（获取所有键值对）<br>应用场景：系统中关于<strong>对象的存储</strong>，如<strong>用户信息</strong>、<strong>商品信息</strong>等。</p>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis学习笔记</title>
      <link href="/2022/12/04/Redis/"/>
      <url>/2022/12/04/Redis/</url>
      
        <content type="html"><![CDATA[</center><h1 id="一、Redis持久化"><a href="#一、Redis持久化" class="headerlink" title="一、Redis持久化"></a>一、Redis持久化</h1><h2 id="1-RDB-持久化"><a href="#1-RDB-持久化" class="headerlink" title="1.RDB 持久化"></a>1.RDB 持久化</h2><p>(1) RDB 持久化在四种情况下会执行</p><ul><li>执行 save 命令</li><li>执行 bgsave 命令</li><li>Redis 停机时</li><li>触发 RDB 条件时</li></ul><p>(2)RDB 方式 bgsave 的基本流程？</p><ul><li>fork主进程得到一个子进程，共享内存空间</li><li>子进程读取内存数据并写入新 的RDB 文件</li><li>用新 RDB 文件替换旧的 RDB 文件</li></ul><p><strong>bgsave 开始时会 fork主进程得到子进程，子进程共享主进程的内存数据。完成 fork 后读取内存数据并写入 RDB 文件。fork 采用的是 copy-on-write技术：当主进程执行读操作时，访问共享内存；当主进程执行写操作时，则会拷贝一份数据，执行写操作。</strong></p><p><img src="https://cdn.jsdelivr.net/gh/xyylegend/picgo_photo/imgs/202206142216920.png"></p><p>(3)RDB 的缺点</p><ul><li>RDB 执行间隔时间长，两次 RDB 之间写入数据有丢失的风险</li><li>fork 子进程、压缩、写出 RDB 文件都比较耗时</li></ul><h2 id="2-AOF持久化"><a href="#2-AOF持久化" class="headerlink" title="2.AOF持久化"></a>2.AOF持久化</h2><p>（1）介绍：AOF全称为 Append Only File（追加文件），Redis 处理的每一个写命令都会记录在 AOF 文件，可以看做是命令日志文件。</p><p>（2）AOF文件重写</p><p>因为是记录命令，AOF 文件会比 RDB 文件大的多。而且 AOF 会记录对同一个 key 的多次写操作，但只有最后一次写操作才有意义。通过执行 bgrewriteaof 命令，可以让 AOF 文件执行重写功能，用最少的命令达到相同效果</p><h1 id="二、Redis主从复制"><a href="#二、Redis主从复制" class="headerlink" title="二、Redis主从复制"></a>二、Redis主从复制</h1><p>单节点 Redis的并发能力是有上限的，要进一步提高 Redis 的并发能力，就需要搭建主从集群，实现读写分离</p><p><img src="https://cdn.jsdelivr.net/gh/xyylegend/picgo_photo/imgs/redis.png"></p><h3 id="同步原理"><a href="#同步原理" class="headerlink" title="同步原理"></a>同步原理</h3><h4 id="1-全量同步"><a href="#1-全量同步" class="headerlink" title="1.全量同步"></a>1.全量同步</h4><ul><li><strong>Replication      Id</strong>：简称      replid，是数据集的标记，id 一致则说明是同一数据集。每一个 master 都有唯一的replid，slave 则会继承 master 节点的      replid；</li><li><strong>offset</strong>：偏移量，随着记录在      repl_baklog 中的数据增多而逐渐增大。slave 完成同步时也会记录当前同步的offset，即 slave 的 offset 永远小于等于      master 的 offset；当 slave 的 offset 小于 master 的 offset，说明 slave 数据落后于      master，需要更新。</li></ul><p>完整流程描述：</p><ul><li>slave 节点请求增量同步</li><li>master 节点判断      replid，发现不一致，拒绝增量同步，选择全量同步</li><li>master 将完整内存数据生成      RDB，发送 RDB 到 slave</li><li>slave 清空本地数据，加载      master 的 RDB</li><li>master 将 RDB      期间的命令记录在 repl_baklog，并持续将 log 中的命令发送给 slave</li><li>slave 执行接收到的命令，保持与      master 之间的同步</li></ul><h4 id="2-增量同步"><a href="#2-增量同步" class="headerlink" title="2.增量同步"></a>2.增量同步</h4><p><img src="https://cdn.jsdelivr.net/gh/xyylegend/picgo_photo/imgs/redis2.png"></p><p><strong>repl_backlog 原理</strong></p><p>master 怎么知道 slave 与自己的数据差异在哪里？</p><p>这就要说到全量同步时的 repl_baklog 文件了。</p><p>这个文件是一个固定大小的数组，只不过数组是环形，也就是说<strong>角标到达数组末尾后，会再次从 0 开始读写</strong>，这样数组头部的数据就会被覆盖。repl_baklog 中会记录 Redis 处理过的命令日志及 offset，包括 master 当前的 offset 和 slave 已经拷贝到的 offset</p><h4 id="3-主从同步优化"><a href="#3-主从同步优化" class="headerlink" title="3.主从同步优化"></a>3.主从同步优化</h4><p>主从同步可以保证主从数据的一致性，非常重要。可以从以下几个方面来优化 Redis 主从集群</p><ul><li>在 master 中配置 repl-diskless-sync      yes 启用无磁盘复制，避免全量同步时的磁盘      IO</li><li>Redis      单节点上的内存占用不要太大，减少 RDB 导致的过多磁盘IO</li><li>适当提高 repl_baklog      的大小，发现 slave 宕机时尽快实现故障恢复，尽可能避免全量同步</li><li>限制一个 master 上的      slave 节点数量，如果实在是太多 slave，则可以采用<strong>主-从-从</strong>链式结构，减少 master 压力</li></ul><h1 id="三、Redis哨兵"><a href="#三、Redis哨兵" class="headerlink" title="三、Redis哨兵"></a>三、Redis哨兵</h1><p>Redis<br>提供了哨兵(Sentinel) 机制来实现主从集群的自动故障恢复</p><p><img src="https://cdn.jsdelivr.net/gh/xyylegend/picgo_photo/imgs/redis3.png"></p><ul><li><strong>监控</strong>：Sentinel 会不断检查您的      master 和 slave 是否按预期工作。</li><li><strong>自动故障恢复</strong>：如果 master 故障，<strong>Sentinel      会将一个 slave 提升为 master</strong>。当故障实例恢复后也以新的 master 为主。</li><li><strong>通知</strong>：Sentinel 充当 Redis      客户端的服务发现来源，当集群发生故障转移时，会将最新信息推送给 Redis 客户端。</li></ul><h2 id="1-集群监控原理"><a href="#1-集群监控原理" class="headerlink" title="1.集群监控原理"></a>1.集群监控原理</h2><p>Sentinel 基于心跳机制监测服务状态，每隔 1 秒向集群的每个实例发送 ping 命令</p><ul><li>主观下线：如果某 Sentinel      节点发现某实例未在规定时间响应，则认为该实例<strong>主观下线</strong>。</li><li>客观下线：<strong>若超过指定数量(quorum)      的 Sentinel 都认为该实例主观下线</strong>，则该实例<strong>客观下线</strong>。quorum 值最好超过 Sentinel 实例数量的一半。</li></ul><h2 id="2-集群故障恢复原理"><a href="#2-集群故障恢复原理" class="headerlink" title="2.集群故障恢复原理"></a>2.集群故障恢复原理</h2><p>一旦发现 master 故障，sentinel 需要在 salve 中选择一个作为新的 master，步骤如下：</p><ol><li>首先会判断 slave 节点与 master 节点断开时间长短，如果超过指定值(down-after-milliseconds * 10)，则会排除该 slave 节点</li><li>然后判断      slave 节点的 slave-priority 值，<strong>越小优先级越高</strong>，如果是 0 则永不参与选举</li><li>如果      slave-prority 一样，则判断 slave 节点的      offset 值，越大说明数据越新，优先级越高</li><li>最后是判断      slave 节点的运行 id 大小，越小优先级越高</li></ol><p>当选出一个新的 master 后，去实现切换：</p><ol><li>sentinel 给备选的 slave1 节点发送 slaveof no one 命令，让该节点成为 master</li><li>sentinel      给所有其它 slave 发送      slaveof 192.168.150.101 7002 之类的命令，让这些      slave 成为新 master 的从节点，开始从新的      master 上同步数据</li><li>最后，sentinel      将故障节点标记为 slave，当故障节点恢复后会自动成为新的      master 的 slave 节点</li></ol><h1 id="三、-redis分片集群"><a href="#三、-redis分片集群" class="headerlink" title="三、 redis分片集群"></a>三、 redis分片集群</h1><p>主从和哨兵可以解决高可用、<a href="https://so.csdn.net/so/search?q=%E9%AB%98%E5%B9%B6%E5%8F%91&spm=1001.2101.3001.7020">高并发</a>读的问题。但是依然有两个问题没有解决：</p><ul><li>海量数据存储问题</li><li>高并发写的问题</li></ul><p>集群中有多个master，每个master保存不同数据</p><p>每个master都可以有多个slave节点</p><p>master之间通过ping监测彼此健康状态</p><p>客户端请求可以访问集群任意节点，最终都会被转发到正确节点</p><p>散列插槽</p><p>Redis会把每一个master节点映射到0~16383共16384个插槽（hash slot）上</p><h2 id="1-redis如何判断某个key应在哪个实例？"><a href="#1-redis如何判断某个key应在哪个实例？" class="headerlink" title="1.redis如何判断某个key应在哪个实例？"></a>1.redis如何判断某个key应在哪个实例？</h2><p>1.将16384个插槽分配到不同的实例</p><p>2.根据key的有效部分计算哈希值，对16384取余</p><p>3.余数作为插槽，寻找插槽所在的实例即可</p><p><strong>redis如何将同一类数据固定保存在同一个redis实例？</strong></p><p>这一类书记使用相同的有效部分，例如都以｛typeid｝为前缀</p>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>github+picgo搭建个人图床</title>
      <link href="/2022/12/03/picgo%E4%B8%AA%E4%BA%BA%E5%9B%BE%E5%BA%8A%E6%90%AD%E5%BB%BA/"/>
      <url>/2022/12/03/picgo%E4%B8%AA%E4%BA%BA%E5%9B%BE%E5%BA%8A%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<p><code>&lt;center&gt;</code>github+picgo搭建个人图床</p><h1 id="一、创建仓库"><a href="#一、创建仓库" class="headerlink" title="一、创建仓库"></a>一、创建仓库</h1><p><strong>在GitHub中新建 public 仓库 -&gt; 创建 token -&gt; 复制 token 备用</strong></p><p>1.在github新建仓库，权限为公开，勾选Add a README file ，仓库名自己写。</p><p>2.仓库建立后，右上角图像下方 settings -&gt;在页面左边选择 Developer settings -&gt;页面左边Personal access tokens -&gt; 页面右上 Generate new token （token description 随便填一下，勾选repo）-&gt; 创建</p><p>3.会生成一个token码，需要保存。（关闭页面后会消失）</p><p>4.生成如下仓库（img不用管）</p><p>![](<a href="https://cdn.jsdelivr.net/gh/xyylegend/picgo_photo/imgs/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE">https://cdn.jsdelivr.net/gh/xyylegend/picgo_photo/imgs/屏幕截图</a> 2022-12-03 213215.jpg)</p><h1 id="二、下载picgo并配置"><a href="#二、下载picgo并配置" class="headerlink" title="二、下载picgo并配置"></a>二、下载picgo并配置</h1><p>1.进入picgo<a href="https://picgo.github.io/PicGo-Doc/zh/">官网</a>，下载自己电脑适配的稳定版本。按照步骤点下一步就行。</p><p>2.图床设置 -&gt; 选择github -&gt; 进行如下配置</p><p><img src="https://cdn.jsdelivr.net/gh/xyylegend/picgo_photo/imgs/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202022-12-03%20214116.jpg"></p><ul><li>自定义域名除仓库名外为固定写法<a href="https://cdn.jsdelivr.net/gh+%E4%BB%93%E5%BA%93%E5%90%8D">https://cdn.jsdelivr.net/gh+仓库名</a></li><li>配置完成后确定并设为默认图床</li></ul><p>3.使用</p><ul><li>直接将文件拖至上传区即可上传完成</li><li>点击相册使用图片</li></ul>]]></content>
      
      
      <categories>
          
          <category> picgo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> picgo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql笔记</title>
      <link href="/2022/12/01/mysql/"/>
      <url>/2022/12/01/mysql/</url>
      
        <content type="html"><![CDATA[<h1 id="基础篇"><a href="#基础篇" class="headerlink" title="基础篇"></a>基础篇</h1><h2 id="通用语法及分类"><a href="#通用语法及分类" class="headerlink" title="通用语法及分类"></a>通用语法及分类</h2><ul><li>DDL: 数据定义语言，用来定义数据库对象（数据库、表、字段）</li><li>DML: 数据操作语言，用来对数据库表中的数据进行增删改</li><li>DQL: 数据查询语言，用来查询数据库中表的记录</li><li>DCL: 数据控制语言，用来创建数据库用户、控制数据库的控制权限</li></ul><h3 id="DDL（数据定义语言）"><a href="#DDL（数据定义语言）" class="headerlink" title="DDL（数据定义语言）"></a>DDL（数据定义语言）</h3><p>数据定义语言</p><h4 id="数据库操作"><a href="#数据库操作" class="headerlink" title="数据库操作"></a>数据库操作</h4><p>查询所有数据库:<br><code>SHOW DATABASES;</code><br>查询当前数据库：<br><code>SELECT DATABASE();</code><br>创建数据库：<br><code>CREATE DATABASE [ IF NOT EXISTS ] 数据库名 [ DEFAULT CHARSET 字符集] [COLLATE 排序规则 ];</code><br>删除数据库:<br><code>DROP DATABASE [ IF EXISTS ] 数据库名;</code><br>使用数据库：<br><code>USE 数据库名;</code></p><h5 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h5><ul><li>UTF8字符集长度为3字节，有些符号占4字节，所以推荐用utf8mb4字符集</li></ul><h4 id="表操作"><a href="#表操作" class="headerlink" title="表操作"></a>表操作</h4><p>查询当前数据库所有表：<br><code>SHOW TABLES;</code><br>查询表结构：<br><code>DESC 表名;</code><br>查询指定表的建表语句：<br><code>SHOW CREATE TABLE 表名;</code></p><p>创建表：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE 表名(</span><br><span class="line">字段1 字段1类型 [COMMENT 字段1注释],</span><br><span class="line">字段2 字段2类型 [COMMENT 字段2注释],</span><br><span class="line">字段3 字段3类型 [COMMENT 字段3注释],</span><br><span class="line">...</span><br><span class="line">字段n 字段n类型 [COMMENT 字段n注释]</span><br><span class="line">)[ COMMENT 表注释 ];</span><br></pre></td></tr></table></figure><p>所有的要用英文的格式<br><strong>最后一个字段后面没有逗号</strong></p><p>添加字段：<br><code>ALTER TABLE 表名 ADD 字段名 类型(长度) [COMMENT 注释] [约束];</code><br>例：<code>ALTER TABLE emp ADD nickname varchar(20) COMMENT &#39;昵称&#39;;</code></p><p>修改数据类型：<br><code>ALTER TABLE 表名 MODIFY 字段名 新数据类型(长度);</code></p><p>修改字段名和字段类型：<br><code>ALTER TABLE 表名 CHANGE 旧字段名 新字段名 类型(长度) [COMMENT 注释] [约束];</code></p><p>例：将emp表的nickname字段修改为username，类型为varchar(30)<br><code>ALTER TABLE emp CHANGE nickname username varchar(30) COMMENT &#39;昵称&#39;;</code></p><p>删除字段：<br><code>ALTER TABLE 表名 DROP 字段名;</code></p><p>修改表名：<br><code>ALTER TABLE 表名 RENAME TO 新表名</code></p><p>删除表：<br><code>DROP TABLE [IF EXISTS] 表名;</code></p><p>删除表，并重新创建该表：<br><code>TRUNCATE TABLE 表名;</code></p><h3 id="DML（数据操作语言）"><a href="#DML（数据操作语言）" class="headerlink" title="DML（数据操作语言）"></a>DML（数据操作语言）</h3><h4 id="添加数据"><a href="#添加数据" class="headerlink" title="添加数据"></a>添加数据</h4><p>指定字段：<br><code>INSERT INTO 表名 (字段名1, 字段名2, ...) VALUES (值1, 值2, ...);</code><br>全部字段：<br><code>INSERT INTO 表名 VALUES (值1, 值2, ...);</code></p><p>批量添加数据：<br><code>INSERT INTO 表名 (字段名1, 字段名2, ...) VALUES (值1, 值2, ...), (值1, 值2, ...), (值1, 值2, ...);</code><br><code>INSERT INTO 表名 VALUES (值1, 值2, ...), (值1, 值2, ...), (值1, 值2, ...);</code></p><h5 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h5><ul><li>字符串和日期类型数据应该包含在引号中</li><li>插入的数据大小应该在字段的规定范围内</li></ul><h4 id="更新和删除数据"><a href="#更新和删除数据" class="headerlink" title="更新和删除数据"></a>更新和删除数据</h4><p>修改数据：<br><code>UPDATE 表名 SET 字段名1 = 值1, 字段名2 = 值2, ... [ WHERE 条件 ];</code><br>例：<br><code>UPDATE emp SET name = &#39;Jack&#39; WHERE id = 1;</code></p><p>删除数据：<br><code>DELETE FROM 表名 [ WHERE 条件 ];</code></p><h3 id="DQL（数据查询语言）"><a href="#DQL（数据查询语言）" class="headerlink" title="DQL（数据查询语言）"></a>DQL（数据查询语言）</h3><p>语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">SELECT</span><br><span class="line">字段列表</span><br><span class="line">FROM</span><br><span class="line">表名字段</span><br><span class="line">WHERE</span><br><span class="line">条件列表</span><br><span class="line">GROUP BY</span><br><span class="line">分组字段列表</span><br><span class="line">HAVING</span><br><span class="line">分组后的条件列表</span><br><span class="line">ORDER BY</span><br><span class="line">排序字段列表</span><br><span class="line">LIMIT</span><br><span class="line">分页参数</span><br></pre></td></tr></table></figure><h4 id="基础查询"><a href="#基础查询" class="headerlink" title="基础查询"></a>基础查询</h4><p>查询多个字段：<br><code>SELECT 字段1, 字段2, 字段3, ... FROM 表名;</code><br><code>SELECT * FROM 表名;</code></p><p>设置别名：<br><code>SELECT 字段1 [ AS 别名1 ], 字段2 [ AS 别名2 ], 字段3 [ AS 别名3 ], ... FROM 表名;</code><br><code>SELECT 字段1 [ 别名1 ], 字段2 [ 别名2 ], 字段3 [ 别名3 ], ... FROM 表名;</code></p><p>去除重复记录：<br><code>SELECT DISTINCT 字段列表 FROM 表名;</code></p><p>转义：<br><code>SELECT * FROM 表名 WHERE name LIKE &#39;/_张三&#39; ESCAPE &#39;/&#39;</code><br>&#x2F; 之后的_不作为通配符</p><h4 id="条件查询"><a href="#条件查询" class="headerlink" title="条件查询"></a>条件查询</h4><p>语法：<br><code>SELECT 字段列表 FROM 表名 WHERE 条件列表;</code></p><p>条件：</p><table><thead><tr><th>比较运算符</th><th>功能</th></tr></thead><tbody><tr><td>&gt;</td><td>大于</td></tr><tr><td>&gt;&#x3D;</td><td>大于等于</td></tr><tr><td>&lt;</td><td>小于</td></tr><tr><td>&lt;&#x3D;</td><td>小于等于</td></tr><tr><td>&#x3D;</td><td>等于</td></tr><tr><td>&lt;&gt; 或 !&#x3D;</td><td>不等于</td></tr><tr><td>BETWEEN … AND …</td><td>在某个范围内（含最小、最大值）</td></tr><tr><td>IN(…)</td><td>在in之后的列表中的值，多选一</td></tr><tr><td>LIKE 占位符</td><td>模糊匹配（_匹配单个字符，%匹配任意个字符）</td></tr><tr><td>IS NULL</td><td>是NULL</td></tr></tbody></table><table><thead><tr><th>逻辑运算符</th><th>功能</th></tr></thead><tbody><tr><td>AND 或 &amp;&amp;</td><td>并且（多个条件同时成立）</td></tr><tr><td>OR 或&amp;#124;&amp;#124;</td><td>或者（多个条件任意一个成立）</td></tr><tr><td>NOT 或 !</td><td>非，不是</td></tr></tbody></table><p>例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">-- 年龄等于30</span><br><span class="line">select * from employee where age = 30;</span><br><span class="line">-- 年龄小于30</span><br><span class="line">select * from employee where age &lt; 30;</span><br><span class="line">-- 小于等于</span><br><span class="line">select * from employee where age &lt;= 30;</span><br><span class="line">-- 没有身份证</span><br><span class="line">select * from employee where idcard is null or idcard = &#x27;&#x27;;</span><br><span class="line">-- 有身份证</span><br><span class="line">select * from employee where idcard;</span><br><span class="line">select * from employee where idcard is not null;</span><br><span class="line">-- 不等于</span><br><span class="line">select * from employee where age != 30;</span><br><span class="line">-- 年龄在20到30之间</span><br><span class="line">select * from employee where age between 20 and 30;</span><br><span class="line">select * from employee where age &gt;= 20 and age &lt;= 30;</span><br><span class="line">-- 下面语句不报错，但查不到任何信息</span><br><span class="line">select * from employee where age between 30 and 20;</span><br><span class="line">-- 性别为女且年龄小于30</span><br><span class="line">select * from employee where age &lt; 30 and gender = &#x27;女&#x27;;</span><br><span class="line">-- 年龄等于25或30或35</span><br><span class="line">select * from employee where age = 25 or age = 30 or age = 35;</span><br><span class="line">select * from employee where age in (25, 30, 35);</span><br><span class="line">-- 姓名为两个字</span><br><span class="line">select * from employee where name like &#x27;__&#x27;;</span><br><span class="line">-- 身份证最后为X</span><br><span class="line">select * from employee where idcard like &#x27;%X&#x27;;</span><br></pre></td></tr></table></figure><h4 id="聚合查询（聚合函数）"><a href="#聚合查询（聚合函数）" class="headerlink" title="聚合查询（聚合函数）"></a>聚合查询（聚合函数）</h4><p>常见聚合函数：</p><table><thead><tr><th>函数</th><th>功能</th></tr></thead><tbody><tr><td>count</td><td>统计数量</td></tr><tr><td>max</td><td>最大值</td></tr><tr><td>min</td><td>最小值</td></tr><tr><td>avg</td><td>平均值</td></tr><tr><td>sum</td><td>求和</td></tr></tbody></table><p>语法：<br><code>SELECT 聚合函数(字段列表) FROM 表名;</code><br>例：<br><code>SELECT count(id) from employee where workaddress = &quot;广东省&quot;;</code></p><h4 id="分组查询"><a href="#分组查询" class="headerlink" title="分组查询"></a>分组查询</h4><p>语法：<br><code>SELECT 字段列表 FROM 表名 [ WHERE 条件 ] GROUP BY 分组字段名 [ HAVING 分组后的过滤条件 ];</code></p><p>where 和 having 的区别：</p><ul><li>执行时机不同：where是分组之前进行过滤，不满足where条件不参与分组；having是分组后对结果进行过滤。</li><li>判断条件不同：where不能对聚合函数进行判断，而having可以。</li></ul><p>例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">-- 根据性别分组，统计男性和女性数量（只显示分组数量，不显示哪个是男哪个是女）</span><br><span class="line">select count(*) from employee group by gender;</span><br><span class="line">-- 根据性别分组，统计男性和女性数量</span><br><span class="line">select gender, count(*) from employee group by gender;</span><br><span class="line">-- 根据性别分组，统计男性和女性的平均年龄</span><br><span class="line">select gender, avg(age) from employee group by gender;</span><br><span class="line">-- 年龄小于45，并根据工作地址分组</span><br><span class="line">select workaddress, count(*) from employee where age &lt; 45 group by workaddress;</span><br><span class="line">-- 年龄小于45，并根据工作地址分组，获取员工数量大于等于3的工作地址</span><br><span class="line">select workaddress, count(*) address_count from employee where age &lt; 45 group by workaddress having address_count &gt;= 3;</span><br></pre></td></tr></table></figure><h5 id="注意事项-2"><a href="#注意事项-2" class="headerlink" title="注意事项"></a>注意事项</h5><ul><li>执行顺序：where &gt; 聚合函数 &gt; having</li><li>分组之后，查询的字段一般为聚合函数和分组字段，查询其他字段无任何意义</li></ul><h4 id="排序查询"><a href="#排序查询" class="headerlink" title="排序查询"></a>排序查询</h4><p>语法：<br><code>SELECT 字段列表 FROM 表名 ORDER BY 字段1 排序方式1, 字段2 排序方式2;</code></p><p>排序方式：</p><ul><li>ASC: 升序（默认）</li><li>DESC: 降序</li></ul><p>例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-- 根据年龄升序排序</span><br><span class="line">SELECT * FROM employee ORDER BY age ASC;</span><br><span class="line">SELECT * FROM employee ORDER BY age;</span><br><span class="line">-- 两字段排序，根据年龄升序排序，入职时间降序排序(如果年龄相同那么就按这个)</span><br><span class="line">SELECT * FROM employee ORDER BY age ASC, entrydate DESC;</span><br></pre></td></tr></table></figure><h5 id="注意事项-3"><a href="#注意事项-3" class="headerlink" title="注意事项"></a>注意事项</h5><p>如果是多字段排序，当第一个字段值相同时，才会根据第二个字段进行排序</p><h4 id="分页查询"><a href="#分页查询" class="headerlink" title="分页查询"></a>分页查询</h4><p>语法：<br><code>SELECT 字段列表 FROM 表名 LIMIT 起始索引, 查询记录数;</code></p><p>例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-- 查询第一页数据，展示10条</span><br><span class="line">SELECT * FROM employee LIMIT 0, 10;</span><br><span class="line">-- 查询第二页</span><br><span class="line">SELECT * FROM employee LIMIT 10, 10;</span><br></pre></td></tr></table></figure><h5 id="注意事项-4"><a href="#注意事项-4" class="headerlink" title="注意事项"></a>注意事项</h5><ul><li>起始索引从0开始，起始索引 &#x3D; （查询页码 - 1） * 每页显示记录数</li><li>分页查询是数据库的方言，不同数据库有不同实现，MySQL是LIMIT</li><li>如果查询的是第一页数据，起始索引可以省略，直接简写 LIMIT 10</li></ul><h4 id="DQL执行顺序"><a href="#DQL执行顺序" class="headerlink" title="DQL执行顺序"></a>DQL执行顺序</h4><p>FROM -&gt; WHERE -&gt; GROUP BY -&gt; SELECT -&gt; ORDER BY -&gt; LIMIT</p><h3 id="DCL"><a href="#DCL" class="headerlink" title="DCL"></a>DCL</h3><h4 id="管理用户"><a href="#管理用户" class="headerlink" title="管理用户"></a>管理用户</h4><p>查询用户：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">USER mysql;</span><br><span class="line">SELECT * FROM user;</span><br></pre></td></tr></table></figure><p>创建用户:<br><code>CREATE USER &#39;用户名&#39;@&#39;主机名&#39; IDENTIFIED BY &#39;密码&#39;;</code></p><p>修改用户密码：<br><code>ALTER USER &#39;用户名&#39;@&#39;主机名&#39; IDENTIFIED WITH mysql_native_password BY &#39;新密码&#39;;</code></p><p>删除用户：<br><code>DROP USER &#39;用户名&#39;@&#39;主机名&#39;;</code></p><p>例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-- 创建用户test，只能在当前主机localhost访问</span><br><span class="line">create user &#x27;test&#x27;@&#x27;localhost&#x27; identified by &#x27;123456&#x27;;</span><br><span class="line">-- 创建用户test，能在任意主机访问</span><br><span class="line">create user &#x27;test&#x27;@&#x27;%&#x27; identified by &#x27;123456&#x27;;</span><br><span class="line">create user &#x27;test&#x27; identified by &#x27;123456&#x27;;</span><br><span class="line">-- 修改密码</span><br><span class="line">alter user &#x27;test&#x27;@&#x27;localhost&#x27; identified with mysql_native_password by &#x27;1234&#x27;;</span><br><span class="line">-- 删除用户</span><br><span class="line">drop user &#x27;test&#x27;@&#x27;localhost&#x27;;</span><br></pre></td></tr></table></figure><h5 id="注意事项-5"><a href="#注意事项-5" class="headerlink" title="注意事项"></a>注意事项</h5><ul><li>主机名可以使用 % 通配</li></ul><h4 id="权限控制"><a href="#权限控制" class="headerlink" title="权限控制"></a>权限控制</h4><p>常用权限：</p><table><thead><tr><th>权限</th><th>说明</th></tr></thead><tbody><tr><td>ALL, ALL PRIVILEGES</td><td>所有权限</td></tr><tr><td>SELECT</td><td>查询数据</td></tr><tr><td>INSERT</td><td>插入数据</td></tr><tr><td>UPDATE</td><td>修改数据</td></tr><tr><td>DELETE</td><td>删除数据</td></tr><tr><td>ALTER</td><td>修改表</td></tr><tr><td>DROP</td><td>删除数据库&#x2F;表&#x2F;视图</td></tr><tr><td>CREATE</td><td>创建数据库&#x2F;表</td></tr></tbody></table><p>更多权限请看<a href="#%E6%9D%83%E9%99%90%E4%B8%80%E8%A7%88%E8%A1%A8" title="权限一览表">权限一览表</a></p><p>查询权限：<br><code>SHOW GRANTS FOR &#39;用户名&#39;@&#39;主机名&#39;;</code></p><p>授予权限：<br><code>GRANT 权限列表 ON 数据库名.表名 TO &#39;用户名&#39;@&#39;主机名&#39;;</code></p><p>撤销权限：<br><code>REVOKE 权限列表 ON 数据库名.表名 FROM &#39;用户名&#39;@&#39;主机名&#39;;</code></p><h5 id="注意事项-6"><a href="#注意事项-6" class="headerlink" title="注意事项"></a>注意事项</h5><ul><li>多个权限用逗号分隔</li><li>授权时，数据库名和表名可以用 * 进行通配，代表所有</li></ul><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>函数  是指一段可以直接被另外一段程序调用的程序或代码。</p><ul><li>字符串函数</li><li>数值函数</li><li>日期函数</li><li>流程函数</li></ul><h3 id="字符串函数"><a href="#字符串函数" class="headerlink" title="字符串函数"></a>字符串函数</h3><p>常用函数：</p><table><thead><tr><th>函数</th><th>功能</th></tr></thead><tbody><tr><td>CONCAT(s1, s2, …, sn)</td><td>字符串拼接，将s1, s2, …, sn拼接成一个字符串</td></tr><tr><td>LOWER(str)</td><td>将字符串全部转为小写</td></tr><tr><td>UPPER(str)</td><td>将字符串全部转为大写</td></tr><tr><td>LPAD(str, n, pad)</td><td>左填充，用字符串pad对str的左边进行填充，达到n个字符串长度</td></tr><tr><td>RPAD(str, n, pad)</td><td>右填充，用字符串pad对str的右边进行填充，达到n个字符串长度</td></tr><tr><td>TRIM(str)</td><td>去掉字符串头部和尾部的空格</td></tr><tr><td>SUBSTRING(str, start, len)</td><td>返回从字符串str从start位置起的len个长度的字符串</td></tr></tbody></table><p>使用示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">-- 拼接</span><br><span class="line">SELECT CONCAT(&#x27;Hello&#x27;, &#x27;World&#x27;);</span><br><span class="line">-- 小写</span><br><span class="line">SELECT LOWER(&#x27;Hello&#x27;);</span><br><span class="line">-- 大写</span><br><span class="line">SELECT UPPER(&#x27;Hello&#x27;);</span><br><span class="line">-- 左填充</span><br><span class="line">SELECT LPAD(&#x27;01&#x27;, 5, &#x27;-&#x27;);</span><br><span class="line">-- 右填充</span><br><span class="line">SELECT RPAD(&#x27;01&#x27;, 5, &#x27;-&#x27;);</span><br><span class="line">-- 去除空格</span><br><span class="line">SELECT TRIM(&#x27; Hello World &#x27;);</span><br><span class="line">-- 切片（起始索引为1）</span><br><span class="line">SELECT SUBSTRING(&#x27;Hello World&#x27;, 1, 5);</span><br></pre></td></tr></table></figure><h3 id="数值函数"><a href="#数值函数" class="headerlink" title="数值函数"></a>数值函数</h3><p>常见函数：</p><table><thead><tr><th>函数</th><th>功能</th></tr></thead><tbody><tr><td>CEIL(x)</td><td>向上取整</td></tr><tr><td>FLOOR(x)</td><td>向下取整</td></tr><tr><td>MOD(x, y)</td><td>返回x&#x2F;y的模</td></tr><tr><td>RAND()</td><td>返回0~1内的随机数</td></tr><tr><td>ROUND(x, y)</td><td>求参数x的四舍五入值，保留y位小数</td></tr></tbody></table><h3 id="日期函数"><a href="#日期函数" class="headerlink" title="日期函数"></a>日期函数</h3><p>常用函数：</p><table><thead><tr><th>函数</th><th>功能</th></tr></thead><tbody><tr><td>CURDATE()</td><td>返回当前日期</td></tr><tr><td>CURTIME()</td><td>返回当前时间</td></tr><tr><td>NOW()</td><td>返回当前日期和时间</td></tr><tr><td>YEAR(date)</td><td>获取指定date的年份</td></tr><tr><td>MONTH(date)</td><td>获取指定date的月份</td></tr><tr><td>DAY(date)</td><td>获取指定date的日期</td></tr><tr><td>DATE_ADD(date, INTERVAL expr type)</td><td>返回一个日期&#x2F;时间值加上一个时间间隔expr后的时间值</td></tr><tr><td>DATEDIFF(date1, date2)</td><td>返回起始时间date1和结束时间date2之间的天数</td></tr></tbody></table><p>例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- DATE_ADD</span><br><span class="line">SELECT DATE_ADD(NOW(), INTERVAL 70 YEAR);</span><br></pre></td></tr></table></figure><h3 id="流程函数"><a href="#流程函数" class="headerlink" title="流程函数"></a>流程函数</h3><p>常用函数：</p><table><thead><tr><th>函数</th><th>功能</th></tr></thead><tbody><tr><td>IF(value, t, f)</td><td>如果value为true，则返回t，否则返回f</td></tr><tr><td>IFNULL(value1, value2)</td><td>如果value1不为空，返回value1，否则返回value2</td></tr><tr><td>CASE WHEN [ val1 ] THEN [ res1 ] … ELSE [ default ] END</td><td>如果val1为true，返回res1，… 否则返回default默认值</td></tr><tr><td>CASE [ expr ] WHEN [ val1 ] THEN [ res1 ] … ELSE [ default ] END</td><td>如果expr的值等于val1，返回res1，… 否则返回default默认值</td></tr></tbody></table><p>例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">select</span><br><span class="line">name,</span><br><span class="line">(case when age &gt; 30 then &#x27;中年&#x27; else &#x27;青年&#x27; end)</span><br><span class="line">from employee;</span><br><span class="line">select</span><br><span class="line">name,</span><br><span class="line">(case workaddress when &#x27;北京市&#x27; then &#x27;一线城市&#x27; when &#x27;上海市&#x27; then &#x27;一线城市&#x27; else &#x27;二线城市&#x27; end) as &#x27;工作地址&#x27;</span><br><span class="line">from employee;</span><br></pre></td></tr></table></figure><h2 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h2><ol><li>概念：约束是用来作用于表中字段上的规则，用于限制存储在表中的数据。</li><li>目的：保证数据库中的数据的正确、有效性和完整性</li></ol><p>分类：</p><table><thead><tr><th>约束</th><th>描述</th><th>关键字</th></tr></thead><tbody><tr><td>非空约束</td><td>限制该字段的数据不能为null</td><td>NOT NULL</td></tr><tr><td>唯一约束</td><td>保证该字段的所有数据都是唯一、不重复的</td><td>UNIQUE</td></tr><tr><td>主键约束</td><td>主键是一行数据的唯一标识，要求非空且唯一</td><td>PRIMARY KEY</td></tr><tr><td>默认约束</td><td>保存数据时，如果未指定该字段的值，则采用默认值</td><td>DEFAULT</td></tr><tr><td>检查约束（8.0.1版本后）</td><td>保证字段值满足某一个条件</td><td>CHECK</td></tr><tr><td>外键约束</td><td>用来让两张图的数据之间建立连接，保证数据的一致性和完整性</td><td>FOREIGN KEY</td></tr></tbody></table><p>约束是作用于表中字段上的，可以再创建表&#x2F;修改表的时候添加约束。</p><h3 id="常用约束"><a href="#常用约束" class="headerlink" title="常用约束"></a>常用约束</h3><table><thead><tr><th>约束条件</th><th>关键字</th></tr></thead><tbody><tr><td>主键</td><td>PRIMARY KEY</td></tr><tr><td>自动增长</td><td>AUTO_INCREMENT</td></tr><tr><td>不为空</td><td>NOT NULL</td></tr><tr><td>唯一</td><td>UNIQUE</td></tr><tr><td>逻辑条件</td><td>CHECK</td></tr><tr><td>默认值</td><td>DEFAULT</td></tr></tbody></table><p>例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">create table user(</span><br><span class="line">id int primary key auto_increment,</span><br><span class="line">name varchar(10) not null unique,</span><br><span class="line">age int check(age &gt; 0 and age &lt; 120),</span><br><span class="line">status char(1) default &#x27;1&#x27;,</span><br><span class="line">gender char(1)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h3 id="外键约束"><a href="#外键约束" class="headerlink" title="外键约束"></a>外键约束</h3><p>外键用来让两张表的数据之间建立连接，从而保证数据的一致性和完整性。</p><p>添加外键：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE 表名(</span><br><span class="line">字段名 字段类型,</span><br><span class="line">...</span><br><span class="line">[CONSTRAINT] [外键名称] FOREIGN KEY(外键字段名) REFERENCES 主表(主表列名)</span><br><span class="line">);  </span><br><span class="line">ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段名) REFERENCES 主表(主表列名);</span><br><span class="line"></span><br><span class="line">-- 例子  </span><br><span class="line">alter table emp add constraint fk_emp_dept_id foreign key(dept_id) references dept(id);  </span><br></pre></td></tr></table></figure><p>删除外键：<br><code>ALTER TABLE 表名 DROP FOREIGN KEY 外键名;</code></p><h4 id="删除-x2F-更新行为"><a href="#删除-x2F-更新行为" class="headerlink" title="删除&#x2F;更新行为"></a>删除&#x2F;更新行为</h4><table><thead><tr><th>行为</th><th>说明</th></tr></thead><tbody><tr><td>NO ACTION</td><td>当在父表中删除&#x2F;更新对应记录时，首先检查该记录是否有对应外键，如果有则不允许删除&#x2F;更新（与RESTRICT一致）</td></tr><tr><td>RESTRICT</td><td>当在父表中删除&#x2F;更新对应记录时，首先检查该记录是否有对应外键，如果有则不允许删除&#x2F;更新（与NO ACTION一致）</td></tr><tr><td>CASCADE</td><td>当在父表中删除&#x2F;更新对应记录时，首先检查该记录是否有对应外键，如果有则也删除&#x2F;更新外键在子表中的记录</td></tr><tr><td>SET NULL</td><td>当在父表中删除&#x2F;更新对应记录时，首先检查该记录是否有对应外键，如果有则设置子表中该外键值为null（要求该外键允许为null）</td></tr><tr><td>SET DEFAULT</td><td>父表有变更时，子表将外键设为一个默认值（Innodb不支持）</td></tr></tbody></table><p>更改删除&#x2F;更新行为：<br><code>ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段) REFERENCES 主表名(主表字段名) ON UPDATE 行为 ON DELETE 行为;</code></p><h2 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h2><h3 id="多表关系"><a href="#多表关系" class="headerlink" title="多表关系"></a>多表关系</h3><ul><li>一对多（多对一）</li><li>多对多</li><li>一对一</li></ul><h4 id="一对多"><a href="#一对多" class="headerlink" title="一对多"></a>一对多</h4><p>案例：部门与员工<br>关系：一个部门对应多个员工，一个员工对应一个部门<br>实现：在多的一方建立外键，指向一的一方的主键</p><h4 id="多对多"><a href="#多对多" class="headerlink" title="多对多"></a>多对多</h4><p>案例：学生与课程<br>关系：一个学生可以选多门课程，一门课程也可以供多个学生选修<br>实现：建立第三张中间表，中间表至少包含两个外键，分别关联两方主键</p><h4 id="一对一"><a href="#一对一" class="headerlink" title="一对一"></a>一对一</h4><p>案例：用户与用户详情<br>关系：一对一关系，多用于单表拆分，将一张表的基础字段放在一张表中，其他详情字段放在另一张表中，以提升操作效率<br>实现：在任意一方加入外键，关联另外一方的主键，并且设置外键为唯一的（UNIQUE）</p><h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><p>合并查询（笛卡尔积，会展示所有组合结果）：<code>select * from employee, dept;</code></p><blockquote><p>笛卡尔积：两个集合A集合和B集合的所有组合情况（在多表查询时，需要消除无效的笛卡尔积）</p></blockquote><p>消除无效笛卡尔积：<br><code>select * from employee, dept where employee.dept = dept.id;</code></p><h3 id="内连接查询"><a href="#内连接查询" class="headerlink" title="内连接查询"></a>内连接查询</h3><p>内连接查询的是两张表交集的部分</p><p>隐式内连接：<br><code>SELECT 字段列表 FROM 表1, 表2 WHERE 条件 ...;</code></p><p>显式内连接：<br><code>SELECT 字段列表 FROM 表1 [ INNER ] JOIN 表2 ON 连接条件 ...;</code></p><p>显式性能比隐式高</p><p>例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-- 查询员工姓名，及关联的部门的名称</span><br><span class="line">-- 隐式</span><br><span class="line">select e.name, d.name from employee as e, dept as d where e.dept = d.id;</span><br><span class="line">-- 显式</span><br><span class="line">select e.name, d.name from employee as e inner join dept as d on e.dept = d.id;</span><br></pre></td></tr></table></figure><h3 id="外连接查询"><a href="#外连接查询" class="headerlink" title="外连接查询"></a>外连接查询</h3><p>左外连接：<br>查询左表所有数据，以及两张表交集部分数据<br><code>SELECT 字段列表 FROM 表1 LEFT [ OUTER ] JOIN 表2 ON 条件 ...;</code><br>相当于查询表1的所有数据，包含表1和表2交集部分数据</p><p>右外连接：<br>查询右表所有数据，以及两张表交集部分数据<br><code>SELECT 字段列表 FROM 表1 RIGHT [ OUTER ] JOIN 表2 ON 条件 ...;</code></p><p>例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-- 左</span><br><span class="line">select e.*, d.name from employee as e left outer join dept as d on e.dept = d.id;  </span><br><span class="line">select d.name, e.* from dept d left outer join emp e on e.dept = d.id;  -- 这条语句与下面的语句效果一样  </span><br><span class="line">-- 右</span><br><span class="line">select d.name, e.* from employee as e right outer join dept as d on e.dept = d.id;  </span><br></pre></td></tr></table></figure><p>左连接可以查询到没有dept的employee，右连接可以查询到没有employee的dept</p><h3 id="自连接查询"><a href="#自连接查询" class="headerlink" title="自连接查询"></a>自连接查询</h3><p>当前表与自身的连接查询，自连接必须使用表别名</p><p>语法：<br><code>SELECT 字段列表 FROM 表A 别名A JOIN 表A 别名B ON 条件 ...;</code></p><p>自连接查询，可以是内连接查询，也可以是外连接查询</p><p>例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-- 查询员工及其所属领导的名字  </span><br><span class="line">select a.name, b.name from employee a, employee b where a.manager = b.id;  </span><br><span class="line">-- 没有领导的也查询出来  </span><br><span class="line">select a.name, b.name from employee a left join employee b on a.manager = b.id;  </span><br></pre></td></tr></table></figure><h3 id="联合查询-union-union-all"><a href="#联合查询-union-union-all" class="headerlink" title="联合查询 union, union all"></a>联合查询 union, union all</h3><p>把多次查询的结果合并，形成一个新的查询集</p><p>语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT 字段列表 FROM 表A ...</span><br><span class="line">UNION [ALL]</span><br><span class="line">SELECT 字段列表 FROM 表B ...</span><br></pre></td></tr></table></figure><h4 id="注意事项-7"><a href="#注意事项-7" class="headerlink" title="注意事项"></a>注意事项</h4><ul><li>UNION ALL 会有重复结果，UNION 不会</li><li>联合查询比使用or效率高，不会使索引失效</li></ul><h3 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h3><p>SQL语句中嵌套SELECT语句，称谓嵌套查询，又称子查询。<br><code>SELECT * FROM t1 WHERE column1 = ( SELECT column1 FROM t2);</code><br><strong>子查询外部的语句可以是 INSERT &#x2F; UPDATE &#x2F; DELETE &#x2F; SELECT 的任何一个</strong></p><p>根据子查询结果可以分为：</p><ul><li>标量子查询（子查询结果为单个值）</li><li>列子查询（子查询结果为一列）</li><li>行子查询（子查询结果为一行）</li><li>表子查询（子查询结果为多行多列）</li></ul><p>根据子查询位置可分为：</p><ul><li>WHERE 之后</li><li>FROM 之后</li><li>SELECT 之后</li></ul><h4 id="标量子查询"><a href="#标量子查询" class="headerlink" title="标量子查询"></a>标量子查询</h4><p>子查询返回的结果是单个值（数字、字符串、日期等）。<br>常用操作符：- &lt; &gt; &gt; &gt;&#x3D; &lt; &lt;&#x3D;</p><p>例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-- 查询销售部所有员工</span><br><span class="line">select id from dept where name = &#x27;销售部&#x27;;</span><br><span class="line">-- 根据销售部部门ID，查询员工信息</span><br><span class="line">select * from employee where dept = 4;</span><br><span class="line">-- 合并（子查询）  </span><br><span class="line">select * from employee where dept = (select id from dept where name = &#x27;销售部&#x27;);  </span><br><span class="line"></span><br><span class="line">-- 查询xxx入职之后的员工信息  </span><br><span class="line">select * from employee where entrydate &gt; (select entrydate from employee where name = &#x27;xxx&#x27;);  </span><br></pre></td></tr></table></figure><h4 id="列子查询"><a href="#列子查询" class="headerlink" title="列子查询"></a>列子查询</h4><p>返回的结果是一列（可以是多行）。</p><p>常用操作符：</p><table><thead><tr><th>操作符</th><th>描述</th></tr></thead><tbody><tr><td>IN</td><td>在指定的集合范围内，多选一</td></tr><tr><td>NOT IN</td><td>不在指定的集合范围内</td></tr><tr><td>ANY</td><td>子查询返回列表中，有任意一个满足即可</td></tr><tr><td>SOME</td><td>与ANY等同，使用SOME的地方都可以使用ANY</td></tr><tr><td>ALL</td><td>子查询返回列表的所有值都必须满足</td></tr></tbody></table><p>例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-- 查询销售部和市场部的所有员工信息  </span><br><span class="line">select * from employee where dept in (select id from dept where name = &#x27;销售部&#x27; or name = &#x27;市场部&#x27;);</span><br><span class="line">-- 查询比财务部所有人工资都高的员工信息</span><br><span class="line">select * from employee where salary &gt; all(select salary from employee where dept = (select id from dept where name = &#x27;财务部&#x27;));</span><br><span class="line">-- 查询比研发部任意一人工资高的员工信息</span><br><span class="line">select * from employee where salary &gt; any (select salary from employee where dept = (select id from dept where name = &#x27;研发部&#x27;));</span><br></pre></td></tr></table></figure><h4 id="行子查询"><a href="#行子查询" class="headerlink" title="行子查询"></a>行子查询</h4><p>返回的结果是一行（可以是多列）。<br>常用操作符：&#x3D;, &lt;, &gt;, IN, NOT IN</p><p>例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-- 查询与xxx的薪资及直属领导相同的员工信息  </span><br><span class="line">select * from employee where (salary, manager) = (12500, 1);  </span><br><span class="line">select * from employee where (salary, manager) = (select salary, manager from employee where name = &#x27;xxx&#x27;);  </span><br></pre></td></tr></table></figure><h4 id="表子查询"><a href="#表子查询" class="headerlink" title="表子查询"></a>表子查询</h4><p>返回的结果是多行多列<br>常用操作符：IN</p><p>例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-- 查询与xxx1，xxx2的职位和薪资相同的员工</span><br><span class="line">select * from employee where (job, salary) in (select job, salary from employee where name = &#x27;xxx1&#x27; or name = &#x27;xxx2&#x27;);</span><br><span class="line">-- 查询入职日期是2006-01-01之后的员工，及其部门信息</span><br><span class="line">select e.*, d.* from (select * from employee where entrydate &gt; &#x27;2006-01-01&#x27;) as e left join dept as d on e.dept = d.id;</span><br></pre></td></tr></table></figure><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p>事务是一组操作的集合，事务会把所有操作作为一个整体一起向系统提交或撤销操作请求，即这些操作要么同时成功，要么同时失败。</p><p>基本操作：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">-- 1. 查询张三账户余额</span><br><span class="line">select * from account where name = &#x27;张三&#x27;;</span><br><span class="line">-- 2. 将张三账户余额-1000</span><br><span class="line">update account set money = money - 1000 where name = &#x27;张三&#x27;;</span><br><span class="line">-- 此语句出错后张三钱减少但是李四钱没有增加</span><br><span class="line">模拟sql语句错误</span><br><span class="line">-- 3. 将李四账户余额+1000</span><br><span class="line">update account set money = money + 1000 where name = &#x27;李四&#x27;;</span><br><span class="line"></span><br><span class="line">-- 查看事务提交方式</span><br><span class="line">SELECT @@AUTOCOMMIT;</span><br><span class="line">-- 设置事务提交方式，1为自动提交，0为手动提交，该设置只对当前会话有效</span><br><span class="line">SET @@AUTOCOMMIT = 0;</span><br><span class="line">-- 提交事务</span><br><span class="line">COMMIT;</span><br><span class="line">-- 回滚事务</span><br><span class="line">ROLLBACK;</span><br><span class="line"></span><br><span class="line">-- 设置手动提交后上面代码改为：</span><br><span class="line">select * from account where name = &#x27;张三&#x27;;  </span><br><span class="line">update account set money = money - 1000 where name = &#x27;张三&#x27;;  </span><br><span class="line">update account set money = money + 1000 where name = &#x27;李四&#x27;;  </span><br><span class="line">commit;  </span><br></pre></td></tr></table></figure><p>操作方式二：</p><p>开启事务：<br><code>START TRANSACTION 或 BEGIN TRANSACTION;</code><br>提交事务：<br><code>COMMIT;</code><br>回滚事务：<br><code>ROLLBACK;</code></p><p>操作实例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">start transaction; </span><br><span class="line">select * from account where name = &#x27;张三&#x27;;</span><br><span class="line">update account set money = money - 1000 where name = &#x27;张三&#x27;;</span><br><span class="line">update account set money = money + 1000 where name = &#x27;李四&#x27;;</span><br><span class="line">commit;</span><br></pre></td></tr></table></figure><p>开启事务后，只有手动提交才会改变数据库中的数据。</p><h3 id="四大特性ACID"><a href="#四大特性ACID" class="headerlink" title="四大特性ACID"></a>四大特性ACID</h3><ul><li>原子性(Atomicity)：事务是不可分割的最小操作但愿，要么全部成功，要么全部失败</li><li>一致性(Consistency)：事务完成时，必须使所有数据都保持一致状态</li><li>隔离性(Isolation)：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境下运行</li><li>持久性(Durability)：事务一旦提交或回滚，它对数据库中的数据的改变就是永久的</li></ul><h3 id="并发事务"><a href="#并发事务" class="headerlink" title="并发事务"></a>并发事务</h3><table><thead><tr><th>问题</th><th>描述</th></tr></thead><tbody><tr><td>脏读</td><td>一个事务读到另一个事务还没提交的数据</td></tr><tr><td>不可重复读</td><td>一个事务先后读取同一条记录，但两次读取的数据不同</td></tr><tr><td>幻读</td><td>一个事务按照条件查询数据时，没有对应的数据行，但是再插入数据时，又发现这行数据已经存在</td></tr></tbody></table><blockquote><p>这三个问题的详细演示：<a href="https://www.bilibili.com/video/BV1Kr4y1i7ru?p=55cd">https://www.bilibili.com/video/BV1Kr4y1i7ru?p=55cd</a></p></blockquote><p>并发事务隔离级别：</p><table><thead><tr><th>隔离级别</th><th>脏读</th><th>不可重复读</th><th>幻读</th></tr></thead><tbody><tr><td>Read uncommitted</td><td>√</td><td>√</td><td>√</td></tr><tr><td>Read committed</td><td>×</td><td>√</td><td>√</td></tr><tr><td>Repeatable Read(默认)</td><td>×</td><td>×</td><td>√</td></tr><tr><td>Serializable</td><td>×</td><td>×</td><td>×</td></tr></tbody></table><ul><li>√表示在当前隔离级别下该问题会出现</li><li>Serializable 性能最低；Read uncommitted 性能最高，数据安全性最差</li></ul><p>查看事务隔离级别：<br><code>SELECT @@TRANSACTION_ISOLATION;</code><br>设置事务隔离级别：<br><code>SET [ SESSION | GLOBAL ] TRANSACTION ISOLATION LEVEL &#123;READ UNCOMMITTED | READ COMMITTED | REPEATABLE READ | SERIALIZABLE &#125;;  </code><br>SESSION 是会话级别，表示只针对当前会话有效，GLOBAL 表示对所有会话有效</p><h1 id="进阶篇"><a href="#进阶篇" class="headerlink" title="进阶篇"></a>进阶篇</h1><h2 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h2><p>MySQL体系结构：</p><p><img src="https://dhc.pythonanywhere.com/media/editor/MySQL%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84_20220315034329549927.png" alt="结构图" title="结构图"><br><img src="https://dhc.pythonanywhere.com/media/editor/MySQL%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E5%B1%82%E7%BA%A7%E5%90%AB%E4%B9%89_20220315034359342837.png" alt="层级描述" title="层级描述"></p><p>存储引擎就是存储数据、建立索引、更新&#x2F;查询数据等技术的实现方式。存储引擎是基于表而不是基于库的，所以存储引擎也可以被称为表引擎。<br>默认存储引擎是InnoDB。</p><p>相关操作：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-- 查询建表语句</span><br><span class="line">show create table account;  </span><br><span class="line">-- 建表时指定存储引擎</span><br><span class="line">CREATE TABLE 表名(</span><br><span class="line">...</span><br><span class="line">) ENGINE=INNODB;</span><br><span class="line">-- 查看当前数据库支持的存储引擎</span><br><span class="line">show engines;</span><br></pre></td></tr></table></figure><h3 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h3><p>InnoDB 是一种兼顾高可靠性和高性能的通用存储引擎，在 MySQL 5.5 之后，InnoDB 是默认的 MySQL 引擎。</p><p>特点：</p><ul><li>DML 操作遵循 ACID 模型，支持<strong>事务</strong></li><li><strong>行级锁</strong>，提高并发访问性能</li><li>支持<strong>外键</strong>约束，保证数据的完整性和正确性</li></ul><p>文件：</p><ul><li>xxx.ibd: xxx代表表名，InnoDB 引擎的每张表都会对应这样一个表空间文件，存储该表的表结构（frm、sdi）、数据和索引。</li></ul><p>参数：innodb_file_per_table，决定多张表共享一个表空间还是每张表对应一个表空间</p><p>知识点：</p><p>查看 Mysql 变量：<br><code>show variables like &#39;innodb_file_per_table&#39;;</code></p><p>从idb文件提取表结构数据：<br>（在cmd运行）<br><code>ibd2sdi xxx.ibd</code></p><p>InnoDB 逻辑存储结构：<br><img src="https://dhc.pythonanywhere.com/media/editor/%E9%80%BB%E8%BE%91%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84_20220316030616590001.png" alt="InnoDB逻辑存储结构" title="InnoDB逻辑存储结构"></p><h3 id="MyISAM"><a href="#MyISAM" class="headerlink" title="MyISAM"></a>MyISAM</h3><p>MyISAM 是 MySQL 早期的默认存储引擎。</p><p>特点：</p><ul><li>不支持事务，不支持外键</li><li>支持表锁，不支持行锁</li><li>访问速度快</li></ul><p>文件：</p><ul><li>xxx.sdi: 存储表结构信息</li><li>xxx.MYD: 存储数据</li><li>xxx.MYI: 存储索引</li></ul><h3 id="Memory"><a href="#Memory" class="headerlink" title="Memory"></a>Memory</h3><p>Memory 引擎的表数据是存储在内存中的，受硬件问题、断电问题的影响，只能将这些表作为临时表或缓存使用。</p><p>特点：</p><ul><li>存放在内存中，速度快</li><li>hash索引（默认）</li></ul><p>文件：</p><ul><li>xxx.sdi: 存储表结构信息</li></ul><h3 id="存储引擎特点"><a href="#存储引擎特点" class="headerlink" title="存储引擎特点"></a>存储引擎特点</h3><table><thead><tr><th>特点</th><th>InnoDB</th><th>MyISAM</th><th>Memory</th></tr></thead><tbody><tr><td>存储限制</td><td>64TB</td><td>有</td><td>有</td></tr><tr><td>事务安全</td><td>支持</td><td>-</td><td>-</td></tr><tr><td>锁机制</td><td>行锁</td><td>表锁</td><td>表锁</td></tr><tr><td>B+tree索引</td><td>支持</td><td>支持</td><td>支持</td></tr><tr><td>Hash索引</td><td>-</td><td>-</td><td>支持</td></tr><tr><td>全文索引</td><td>支持（5.6版本之后）</td><td>支持</td><td>-</td></tr><tr><td>空间使用</td><td>高</td><td>低</td><td>N&#x2F;A</td></tr><tr><td>内存使用</td><td>高</td><td>低</td><td>中等</td></tr><tr><td>批量插入速度</td><td>低</td><td>高</td><td>高</td></tr><tr><td>支持外键</td><td>支持</td><td>-</td><td>-</td></tr></tbody></table><h3 id="存储引擎的选择"><a href="#存储引擎的选择" class="headerlink" title="存储引擎的选择"></a>存储引擎的选择</h3><p>在选择存储引擎时，应该根据应用系统的特点选择合适的存储引擎。对于复杂的应用系统，还可以根据实际情况选择多种存储引擎进行组合。</p><ul><li>InnoDB: 如果应用对事物的完整性有比较高的要求，在并发条件下要求数据的一致性，数据操作除了插入和查询之外，还包含很多的更新、删除操作，则 InnoDB 是比较合适的选择</li><li>MyISAM: 如果应用是以读操作和插入操作为主，只有很少的更新和删除操作，并且对事务的完整性、并发性要求不高，那这个存储引擎是非常合适的。</li><li>Memory: 将所有数据保存在内存中，访问速度快，通常用于临时表及缓存。Memory 的缺陷是对表的大小有限制，太大的表无法缓存在内存中，而且无法保障数据的安全性</li></ul><p>电商中的足迹和评论适合使用 MyISAM 引擎，缓存适合使用 Memory 引擎。</p><h2 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h2><h3 id="查看执行频次"><a href="#查看执行频次" class="headerlink" title="查看执行频次"></a>查看执行频次</h3><p>查看当前数据库的 INSERT, UPDATE, DELETE, SELECT 访问频次：<br><code>SHOW GLOBAL STATUS LIKE &#39;Com_______&#39;;</code> 或者 <code>SHOW SESSION STATUS LIKE &#39;Com_______&#39;;</code><br>例：<code>show global status like &#39;Com_______&#39;</code></p><h3 id="慢查询日志"><a href="#慢查询日志" class="headerlink" title="慢查询日志"></a>慢查询日志</h3><p>慢查询日志记录了所有执行时间超过指定参数（long_query_time，单位：秒，默认10秒）的所有SQL语句的日志。<br>MySQL的慢查询日志默认没有开启，需要在MySQL的配置文件（&#x2F;etc&#x2F;my.cnf）中配置如下信息：<br>    # 开启慢查询日志开关<br>    slow_query_log&#x3D;1<br>    # 设置慢查询日志的时间为2秒，SQL语句执行时间超过2秒，就会视为慢查询，记录慢查询日志<br>    long_query_time&#x3D;2<br>更改后记得重启MySQL服务，日志文件位置：&#x2F;var&#x2F;lib&#x2F;mysql&#x2F;localhost-slow.log</p><p>查看慢查询日志开关状态：<br><code>show variables like &#39;slow_query_log&#39;;</code></p><h3 id="profile"><a href="#profile" class="headerlink" title="profile"></a>profile</h3><p>show profile 能在做SQL优化时帮我们了解时间都耗费在哪里。通过 have_profiling 参数，能看到当前 MySQL 是否支持 profile 操作：<br><code>SELECT @@have_profiling;</code><br>profiling 默认关闭，可以通过set语句在session&#x2F;global级别开启 profiling：<br><code>SET profiling = 1;</code><br>查看所有语句的耗时：<br><code>show profiles;</code><br>查看指定query_id的SQL语句各个阶段的耗时：<br><code>show profile for query query_id;</code><br>查看指定query_id的SQL语句CPU的使用情况<br><code>show profile cpu for query query_id;</code></p><h3 id="explain"><a href="#explain" class="headerlink" title="explain"></a>explain</h3><p>EXPLAIN 或者 DESC 命令获取 MySQL 如何执行 SELECT 语句的信息，包括在 SELECT 语句执行过程中表如何连接和连接的顺序。<br>语法：<br>    # 直接在select语句之前加上关键字 explain &#x2F; desc<br>    EXPLAIN SELECT 字段列表 FROM 表名 HWERE 条件;</p><p>EXPLAIN 各字段含义：</p><ul><li>id：select 查询的序列号，表示查询中执行 select 子句或者操作表的顺序（id相同，执行顺序从上到下；id不同，值越大越先执行）</li><li>select_type：表示 SELECT 的类型，常见取值有 SIMPLE（简单表，即不适用表连接或者子查询）、PRIMARY（主查询，即外层的查询）、UNION（UNION中的第二个或者后面的查询语句）、   SUBQUERY（SELECT&#x2F;WHERE之后包含了子查询）等</li><li>type：表示连接类型，性能由好到差的连接类型为 NULL、system、const、eq_ref、ref、range、index、all</li><li>possible_key：可能应用在这张表上的索引，一个或多个</li><li>Key：实际使用的索引，如果为 NULL，则没有使用索引</li><li>Key_len：表示索引中使用的字节数，该值为索引字段最大可能长度，并非实际使用长度，在不损失精确性的前提下，长度越短越好</li><li>rows：MySQL认为必须要执行的行数，在InnoDB引擎的表中，是一个估计值，可能并不总是准确的</li><li>filtered：表示返回结果的行数占需读取行数的百分比，filtered的值越大越好</li></ul><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p>索引是帮助 MySQL <strong>高效获取数据</strong>的<strong>数据结构（有序）</strong>。在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查询算法，这种数据结构就是索引。</p><p>优缺点：</p><p>优点：</p><ul><li>提高数据检索效率，降低数据库的IO成本</li><li>通过索引列对数据进行排序，降低数据排序的成本，降低CPU的消耗</li></ul><p>缺点：</p><ul><li>索引列也是要占用空间的</li><li>索引大大提高了查询效率，但降低了更新的速度，比如 INSERT、UPDATE、DELETE</li></ul><h3 id="索引结构"><a href="#索引结构" class="headerlink" title="索引结构"></a>索引结构</h3><table><thead><tr><th>索引结构</th><th>描述</th></tr></thead><tbody><tr><td>B+Tree</td><td>最常见的索引类型，大部分引擎都支持B+树索引</td></tr><tr><td>Hash</td><td>底层数据结构是用哈希表实现，只有精确匹配索引列的查询才有效，不支持范围查询</td></tr><tr><td>R-Tree(空间索引)</td><td>空间索引是 MyISAM 引擎的一个特殊索引类型，主要用于地理空间数据类型，通常使用较少</td></tr><tr><td>Full-Text(全文索引)</td><td>是一种通过建立倒排索引，快速匹配文档的方式，类似于 Lucene, Solr, ES</td></tr></tbody></table><table><thead><tr><th>索引</th><th>InnoDB</th><th>MyISAM</th><th>Memory</th></tr></thead><tbody><tr><td>B+Tree索引</td><td>支持</td><td>支持</td><td>支持</td></tr><tr><td>Hash索引</td><td>不支持</td><td>不支持</td><td>支持</td></tr><tr><td>R-Tree索引</td><td>不支持</td><td>支持</td><td>不支持</td></tr><tr><td>Full-text</td><td>5.6版本后支持</td><td>支持</td><td>不支持</td></tr></tbody></table><h4 id="B-Tree"><a href="#B-Tree" class="headerlink" title="B-Tree"></a>B-Tree</h4><p><img src="https://dhc.pythonanywhere.com/media/editor/%E4%BA%8C%E5%8F%89%E6%A0%91_20220316153214227108.png" alt="二叉树" title="二叉树"></p><p>二叉树形成链表的缺点可以用红黑树来解决：<br><img src="https://dhc.pythonanywhere.com/media/editor/%E7%BA%A2%E9%BB%91%E6%A0%91_20220316163142686602.png" alt="红黑树" title="红黑树"><br>红黑树也存在大数据量情况下，层级较深，检索速度慢的问题。</p><p>为了解决上述问题，可以使用 B-Tree 结构。<br>B-Tree (多路平衡查找树) 以一棵最大度数（max-degree，指一个节点的子节点个数）为5（5阶）的 b-tree 为例（每个节点最多存储4个key，5个指针）</p><p><img src="https://dhc.pythonanywhere.com/media/editor/B-Tree%E7%BB%93%E6%9E%84_20220316163813441163.png" alt="B-Tree结构" title="B-Tree结构"></p><blockquote><p>B-Tree 的数据插入过程动画参照：<a href="https://www.bilibili.com/video/BV1Kr4y1i7ru?p=68">https://www.bilibili.com/video/BV1Kr4y1i7ru?p=68</a><br>演示地址：<a href="https://www.cs.usfca.edu/~galles/visualization/BTree.html">https://www.cs.usfca.edu/~galles/visualization/BTree.html</a></p></blockquote><h4 id="B-Tree-1"><a href="#B-Tree-1" class="headerlink" title="B+Tree"></a>B+Tree</h4><p>结构图：</p><p><img src="https://dhc.pythonanywhere.com/media/editor/B+Tree%E7%BB%93%E6%9E%84%E5%9B%BE_20220316170700591277.png" alt="B+Tree结构图" title="B+Tree结构图"></p><blockquote><p>演示地址：<a href="https://www.cs.usfca.edu/~galles/visualization/BPlusTree.html">https://www.cs.usfca.edu/~galles/visualization/BPlusTree.html</a></p></blockquote><p>与 B-Tree 的区别：</p><ul><li>所有的数据都会出现在叶子节点</li><li>叶子节点形成一个单向链表</li></ul><p>MySQL 索引数据结构对经典的 B+Tree 进行了优化。在原 B+Tree 的基础上，增加一个指向相邻叶子节点的链表指针，就形成了带有顺序指针的 B+Tree，提高区间访问的性能。</p><p><img src="https://dhc.pythonanywhere.com/media/editor/%E7%BB%93%E6%9E%84%E5%9B%BE_20220316171730865611.png" alt="MySQL B+Tree 结构图" title="MySQL B+Tree 结构图"></p><h4 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h4><p>哈希索引就是采用一定的hash算法，将键值换算成新的hash值，映射到对应的槽位上，然后存储在hash表中。<br>如果两个（或多个）键值，映射到一个相同的槽位上，他们就产生了hash冲突（也称为hash碰撞），可以通过链表来解决。</p><p><img src="https://dhc.pythonanywhere.com/media/editor/Hash%E7%B4%A2%E5%BC%95%E5%8E%9F%E7%90%86%E5%9B%BE_20220317143226150679.png" alt="Hash索引原理图" title="Hash索引原理图"></p><p>特点：</p><ul><li>Hash索引只能用于对等比较（&#x3D;、in），不支持范围查询（betwwn、&gt;、&lt;、…）</li><li>无法利用索引完成排序操作</li><li>查询效率高，通常只需要一次检索就可以了，效率通常要高于 B+Tree 索引</li></ul><p>存储引擎支持：</p><ul><li>Memory</li><li>InnoDB: 具有自适应hash功能，hash索引是存储引擎根据 B+Tree 索引在指定条件下自动构建的</li></ul><h4 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h4><ol><li>为什么 InnoDB 存储引擎选择使用 B+Tree 索引结构？</li></ol><ul><li>相对于二叉树，层级更少，搜索效率高</li><li>对于 B-Tree，无论是叶子节点还是非叶子节点，都会保存数据，这样导致一页中存储的键值减少，指针也跟着减少，要同样保存大量数据，只能增加树的高度，导致性能降低</li><li>相对于 Hash 索引，B+Tree 支持范围匹配及排序操作</li></ul><h3 id="索引分类"><a href="#索引分类" class="headerlink" title="索引分类"></a>索引分类</h3><table><thead><tr><th>分类</th><th>含义</th><th>特点</th><th>关键字</th></tr></thead><tbody><tr><td>主键索引</td><td>针对于表中主键创建的索引</td><td>默认自动创建，只能有一个</td><td>PRIMARY</td></tr><tr><td>唯一索引</td><td>避免同一个表中某数据列中的值重复</td><td>可以有多个</td><td>UNIQUE</td></tr><tr><td>常规索引</td><td>快速定位特定数据</td><td>可以有多个</td><td></td></tr><tr><td>全文索引</td><td>全文索引查找的是文本中的关键词，而不是比较索引中的值</td><td>可以有多个</td><td>FULLTEXT</td></tr></tbody></table><p>在 InnoDB 存储引擎中，根据索引的存储形式，又可以分为以下两种：</p><table><thead><tr><th>分类</th><th>含义</th><th>特点</th></tr></thead><tbody><tr><td>聚集索引(Clustered Index)</td><td>将数据存储与索引放一块，索引结构的叶子节点保存了行数据</td><td>必须有，而且只有一个</td></tr><tr><td>二级索引(Secondary Index)</td><td>将数据与索引分开存储，索引结构的叶子节点关联的是对应的主键</td><td>可以存在多个</td></tr></tbody></table><p>演示图：</p><p><img src="https://dhc.pythonanywhere.com/media/editor/%E5%8E%9F%E7%90%86%E5%9B%BE_20220318194454880073.png" alt="大致原理" title="大致原理"><br><img src="https://dhc.pythonanywhere.com/media/editor/%E6%BC%94%E7%A4%BA%E5%9B%BE_20220319215403721066.png" alt="演示图" title="演示图"></p><p>聚集索引选取规则：</p><ul><li>如果存在主键，主键索引就是聚集索引</li><li>如果不存在主键，将使用第一个唯一(UNIQUE)索引作为聚集索引</li><li>如果表没有主键或没有合适的唯一索引，则 InnoDB 会自动生成一个 rowid 作为隐藏的聚集索引</li></ul><h4 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h4><p>1. 以下 SQL 语句，哪个执行效率高？为什么？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select * from user where id = 10;</span><br><span class="line">select * from user where name = &#x27;Arm&#x27;;</span><br><span class="line">-- 备注：id为主键，name字段创建的有索引</span><br></pre></td></tr></table></figure><p>答：第一条语句，因为第二条需要回表查询，相当于两个步骤。</p><p>2. InnoDB 主键索引的 B+Tree 高度为多少？</p><p>答：假设一行数据大小为1k，一页中可以存储16行这样的数据。InnoDB 的指针占用6个字节的空间，主键假设为bigint，占用字节数为8.<br>可得公式：<code>n * 8 + (n + 1) * 6 = 16 * 1024</code>，其中 8 表示 bigint 占用的字节数，n 表示当前节点存储的key的数量，(n + 1) 表示指针数量（比key多一个）。算出n约为1170。</p><p>如果树的高度为2，那么他能存储的数据量大概为：<code>1171 * 16 = 18736</code>；<br>如果树的高度为3，那么他能存储的数据量大概为：<code>1171 * 1171 * 16 = 21939856</code>。</p><p>另外，如果有成千上万的数据，那么就要考虑分表，涉及运维篇知识。</p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p>创建索引：<br><code>CREATE [ UNIQUE | FULLTEXT ] INDEX index_name ON table_name (index_col_name, ...);</code><br>如果不加 CREATE 后面不加索引类型参数，则创建的是常规索引</p><p>查看索引：<br><code>SHOW INDEX FROM table_name;</code></p><p>删除索引：<br><code>DROP INDEX index_name ON table_name;</code></p><p>案例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">-- name字段为姓名字段，该字段的值可能会重复，为该字段创建索引</span><br><span class="line">create index idx_user_name on tb_user(name);</span><br><span class="line">-- phone手机号字段的值非空，且唯一，为该字段创建唯一索引</span><br><span class="line">create unique index idx_user_phone on tb_user (phone);</span><br><span class="line">-- 为profession, age, status创建联合索引</span><br><span class="line">create index idx_user_pro_age_stat on tb_user(profession, age, status);</span><br><span class="line">-- 为email建立合适的索引来提升查询效率</span><br><span class="line">create index idx_user_email on tb_user(email);</span><br><span class="line"></span><br><span class="line">-- 删除索引  </span><br><span class="line">drop index idx_user_email on tb_user;  </span><br></pre></td></tr></table></figure><h3 id="使用规则"><a href="#使用规则" class="headerlink" title="使用规则"></a>使用规则</h3><h4 id="最左前缀法则"><a href="#最左前缀法则" class="headerlink" title="最左前缀法则"></a>最左前缀法则</h4><p>如果索引关联了多列（联合索引），要遵守最左前缀法则，最左前缀法则指的是查询从索引的最左列开始，并且不跳过索引中的列。<br>如果跳跃某一列，索引将部分失效（后面的字段索引失效）。跳过的话，后面的排序就无从说起了。最左前缀法则在用select的时候，和放的位置是没有关系的，只要存在就行。</p><p>联合索引中，出现范围查询（&lt;, &gt;），范围查询右侧的列索引失效。可以用&gt;&#x3D;或者&lt;&#x3D;来规避索引失效问题。</p><h4 id="索引失效情况"><a href="#索引失效情况" class="headerlink" title="索引失效情况"></a>索引失效情况</h4><ol><li>在索引列上进行运算操作，索引将失效。如：<code>explain select * from tb_user where substring(phone, 10, 2) = &#39;15&#39;;</code> 换成 <code>explain select * from tb_user where phone = &#39;17799990015&#39;;</code>这是可以的。</li><li>字符串类型字段使用时，不加引号，索引将失效。如：<code>explain select * from tb_user where phone = 17799990015;</code>，此处phone的值没有加引号</li><li>模糊查询中，如果仅仅是尾部模糊匹配，索引不会是失效；如果是头部模糊匹配，索引失效。如：<code>explain select * from tb_user where profession like &#39;%工程&#39;;</code>，前后都有 % 也会失效。<code>explain select * from tb_user where profession like &#39;软件%&#39;;</code> 这个是不会失效的，只有前面加了%才会失效。</li><li>用 or 分割开的条件，如果 or 其中一个条件的列没有索引，那么涉及的索引都不会被用到。</li><li>如果 MySQL 评估使用索引比全表更慢，则不使用索引。因为只要有一个没有索引，另外一个用不用索引都没有意义，都要进行全表扫描。所以就无需用索引。</li></ol><h4 id="SQL-提示"><a href="#SQL-提示" class="headerlink" title="SQL 提示"></a>SQL 提示</h4><p>是优化数据库的一个重要手段，简单来说，就是在SQL语句中加入一些人为的提示来达到优化操作的目的。</p><p>例如，使用索引：<br><code>explain select * from tb_user use index(idx_user_pro) where profession=&quot;软件工程&quot;;</code><br>不使用哪个索引：<br><code>explain select * from tb_user ignore index(idx_user_pro) where profession=&quot;软件工程&quot;;</code><br>必须使用哪个索引：<br><code>explain select * from tb_user force index(idx_user_pro) where profession=&quot;软件工程&quot;;</code></p><p>use 是建议，实际使用哪个索引 MySQL 还会自己权衡运行速度去更改，force就是无论如何都强制使用该索引。</p><h4 id="覆盖索引-amp-回表查询"><a href="#覆盖索引-amp-回表查询" class="headerlink" title="覆盖索引&amp;回表查询"></a>覆盖索引&amp;回表查询</h4><p>尽量使用覆盖索引（查询使用了索引，并且需要返回的列，在该索引中已经全部能找到），减少 select *。</p><p>explain 中 extra 字段含义：<br><code>using index condition</code>：查找使用了索引，但是需要回表查询数据<br><code>using where; using index;</code>：查找使用了索引，但是需要的数据都在索引列中能找到，所以不需要回表查询</p><p>覆盖索引：<br>如果在生成的二级索引（辅助索引）中可以一次性获得select所需要的字段，不需要回表查询。</p><p>如果在聚集索引中直接能找到对应的行，则直接返回行数据，只需要一次查询，哪怕是select *；<br>如果在辅助索引（二级索引）中找聚集索引，如 <code>select id, name from xxx where name=&#39;xxx&#39;;</code>，也只需要通过辅助索引(name)查找到对应的id，返回name和name索引对应的id即可，只需要一次查询；<br>如果是通过辅助索引查找其他字段，则需要回表查询，如 <code>select id, name, gender from xxx where name=&#39;xxx&#39;;</code></p><p>所以尽量不要用 <code>select *</code>，容易出现回表查询，降低效率，除非有联合索引包含了所有字段</p><p>面试题：一张表，有四个字段（id, username, password, status），由于数据量大，需要对以下SQL语句进行优化，该如何进行才是最优方案：<br><code>select id, username, password from tb_user where username=&#39;itcast&#39;;</code></p><p>解：给username和password字段建立联合索引，则不需要回表查询，直接覆盖索引。<br>username和password字段建立联合索引的叶子节点挂的就是 id 所以不需要三者同时建索引。</p><h4 id="前缀索引"><a href="#前缀索引" class="headerlink" title="前缀索引"></a>前缀索引</h4><p>当字段类型为字符串（varchar, text等）时，有时候需要索引很长的字符串，这会让索引变得很大，查询时，浪费大量的磁盘IO，影响查询效率，此时可以只降字符串的一部分前缀，建立索引，这样可以大大节约索引空间，从而提高索引效率。</p><p>语法：<code>create index idx_xxxx on table_name(columnn(n));</code><br>前缀长度：可以根据索引的选择性来决定，而选择性是指不重复的索引值（基数）和数据表的记录总数的比值，索引选择性越高则查询效率越高，唯一索引的选择性是1，这是最好的索引选择性，性能也是最好的。</p><p>求选择性公式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select count(distinct email) / count(*) from tb_user;</span><br><span class="line">select count(distinct substring(email, 1, 5)) / count(*) from tb_user;</span><br></pre></td></tr></table></figure><p>前缀索引中是有可能碰到相同的索引的情况的（因为选择性可能不为1），所以使用前缀索引进行查询的时候，mysql 会有一个回表查询的过程，确定是否为所需数据。如图中的查询到lvbu6之后还要进行回表，回表完再查xiaoy，看到xiaoy是不需要的数据，则停止查下一个。</p><p><img src="https://github.com/Buildings-Lei/mysql_note/blob/main/images/pre.png" alt="images" title="索引流程"></p><p>show index 里面的sub_part可以看到接取的长度</p><h4 id="单列索引-amp-联合索引"><a href="#单列索引-amp-联合索引" class="headerlink" title="单列索引&amp;联合索引"></a>单列索引&amp;联合索引</h4><p>单列索引：即一个索引只包含单个列<br>联合索引：即一个索引包含了多个列<br>在业务场景中，如果存在多个查询条件，考虑针对于查询字段建立索引时，建议建立联合索引，而非单列索引。</p><p>单列索引情况：</p><p><code>explain select id, phone, name from tb_user where phone = &#39;17799990010&#39; and name = &#39;韩信&#39;;</code><br>phone 和 name 都建立了索引情况下，这句只会用到phone索引字段。</p><p>联合索引的数据组织图：</p><p><img src="https://github.com/Buildings-Lei/mysql_note/blob/main/images/uion.png" alt="images"></p><h5 id="注意事项-8"><a href="#注意事项-8" class="headerlink" title="注意事项"></a>注意事项</h5><ul><li>多条件联合查询时，MySQL优化器会评估哪个字段的索引效率更高，会选择该索引完成本次查询。</li></ul><h3 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h3><ol><li>针对于数据量较大，且查询比较频繁的表建立索引</li><li>针对于常作为查询条件（where）、排序（order by）、分组（group by）操作的字段建立索引</li><li>尽量选择区分度高的列作为索引，尽量建立唯一索引，区分度越高，使用索引的效率越高</li><li>如果是字符串类型的字段，字段长度较长，可以针对于字段的特点，建立前缀索引</li><li>尽量使用联合索引，减少单列索引，查询时，联合索引很多时候可以覆盖索引，节省存储空间，避免回表，提高查询效率</li><li>要控制索引的数量，索引并不是多多益善，索引越多，维护索引结构的代价就越大，会影响增删改的效率</li><li>如果索引列不能存储NULL值，请在创建表时使用NOT NULL约束它。当优化器知道每列是否包含NULL值时，它可以更好地确定哪个索引最有效地用于查询</li></ol><h2 id="SQL-优化"><a href="#SQL-优化" class="headerlink" title="SQL 优化"></a>SQL 优化</h2><h3 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h3><p>普通插入：</p><ol><li>采用批量插入（一次插入的数据不建议超过1000条，500 - 1000 为宜）</li><li>手动提交事务</li><li>主键顺序插入（主键顺序插入的效率大于乱序插入）</li></ol><p>大批量插入：<br>如果一次性需要插入大批量数据，使用insert语句插入性能较低，此时可以使用MySQL数据库提供的load指令插入。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 客户端连接服务端时，加上参数 --local-infile（这一行在bash/cmd界面输入）</span><br><span class="line">mysql --local-infile -u root -p</span><br><span class="line"># 设置全局参数local_infile为1，开启从本地加载文件导入数据的开关</span><br><span class="line">set global local_infile = 1;</span><br><span class="line">select @@local_infile;</span><br><span class="line"># 执行load指令将准备好的数据，加载到表结构中，先要把表建立起来。</span><br><span class="line">load data local infile &#x27;/root/sql1.log&#x27; into table &#x27;tb_user&#x27; fields terminated by &#x27;,&#x27; lines terminated by &#x27;\n&#x27;;</span><br></pre></td></tr></table></figure><h3 id="主键优化"><a href="#主键优化" class="headerlink" title="主键优化"></a>主键优化</h3><p>数据组织方式：在InnoDB存储引擎中，表数据都是根据主键顺序组织存放的，这种存储方式的表称为索引组织表（Index organized table, IOT）</p><p>主键的顺序的插入过程如下：</p><p><img src="https://github.com/Buildings-Lei/mysql_note/blob/main/images/keySort.png" alt="images"></p><p>但是如果主键是乱序插入的话，就会导致需要插入的位置为中间的位置，会有页分裂的过程。</p><p>页分裂：页可以为空，也可以填充一般，也可以填充100%，每个页包含了2-N行数据（如果一行数据过大，会行溢出），根据主键排列。</p><p>页合并：当删除一行记录时，实际上记录并没有被物理删除，只是记录被标记（flaged）为删除并且它的空间变得允许被其他记录声明使用。当页中删除的记录到达 MERGE_THRESHOLD（默认为页的50%），InnoDB会开始寻找最靠近的页（前后）看看是否可以将这两个页合并以优化空间使用。</p><p>MERGE_THRESHOLD：合并页的阈值，可以自己设置，在创建表或创建索引时指定</p><blockquote><p>文字说明不够清晰明了，具体可以看视频里的PPT演示过程：<a href="https://www.bilibili.com/video/BV1Kr4y1i7ru?p=90">https://www.bilibili.com/video/BV1Kr4y1i7ru?p=90</a></p></blockquote><p>主键设计原则：</p><ul><li>满足业务需求的情况下，尽量降低主键的长度，二级索引的叶子节点保存的就是主键，所以主键小占用的空间也就会少。</li><li>插入数据时，尽量选择顺序插入，选择使用 AUTO_INCREMENT 自增主键</li><li>尽量不要使用 UUID 做主键或者是其他的自然主键，如身份证号，占用的空间大。</li><li>业务操作时，避免对主键的修改</li></ul><h3 id="order-by优化"><a href="#order-by优化" class="headerlink" title="order by优化"></a>order by优化</h3><ol><li>Using filesort：通过表的索引或全表扫描，读取满足条件的数据行，然后在排序缓冲区 sort buffer 中完成排序操作，所有不是通过索引直接返回排序结果的排序都叫 FileSort 排序</li><li>Using index：通过有序索引顺序扫描直接返回有序数据，这种情况即为 using index，不需要额外排序，操作效率高</li></ol><p>如果order by字段全部使用升序排序或者降序排序，则都会走索引，但是如果一个字段升序排序，另一个字段降序排序，则不会走索引，explain的extra信息显示的是 <code>Using index, Using filesort</code>，如果要优化掉Using filesort，则需要另外再创建一个索引，如：<code>create index idx_user_age_phone_ad on tb_user(age asc, phone desc);</code>，此时使用 <code>select id, age, phone from tb_user order by age asc, phone desc;</code>会全部走索引</p><p>总结：</p><ul><li>根据排序字段建立合适的索引，多字段排序时，也遵循最左前缀法则</li><li>尽量使用覆盖索引</li><li>多字段排序，一个升序一个降序，此时需要注意联合索引在创建时的规则（ASC&#x2F;DESC）</li><li>如果不可避免出现filesort，大数据量排序时，可以适当增大排序缓冲区大小 sort_buffer_size（默认256k）</li></ul><h3 id="group-by优化"><a href="#group-by优化" class="headerlink" title="group by优化"></a>group by优化</h3><ul><li>在分组操作时，可以通过索引来提高效率</li><li>分组操作时，索引的使用也是满足最左前缀法则的</li></ul><p>如索引为 <code>idx_user_pro_age_stat</code>，则句式可以是 <code>select ... where profession order by age</code>，这样也符合最左前缀法则</p><h3 id="limit优化"><a href="#limit优化" class="headerlink" title="limit优化"></a>limit优化</h3><p>常见的问题如 <code>limit 2000000, 10</code>，此时需要 MySQL 排序前2000000条记录，但仅仅返回2000000 - 2000010的记录，其他记录丢弃，查询排序的代价非常大。<br>优化方案：一般分页查询时，通过创建覆盖索引能够比较好地提高性能，可以通过覆盖索引加子查询形式进行优化</p><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-- 此语句耗时很长</span><br><span class="line">select * from tb_sku limit 9000000, 10;</span><br><span class="line">-- 通过覆盖索引加快速度，直接通过主键索引进行排序及查询</span><br><span class="line">select id from tb_sku order by id limit 9000000, 10;</span><br><span class="line">-- 下面的语句是错误的，因为 MySQL 不支持 in 里面使用 limit</span><br><span class="line">-- select * from tb_sku where id in (select id from tb_sku order by id limit 9000000, 10);</span><br><span class="line">-- 通过连表查询即可实现第一句的效果，并且能达到第二句的速度</span><br><span class="line">select * from tb_sku as s, (select id from tb_sku order by id limit 9000000, 10) as a where s.id = a.id;</span><br></pre></td></tr></table></figure><h3 id="count优化"><a href="#count优化" class="headerlink" title="count优化"></a>count优化</h3><p>MyISAM 引擎把一个表的总行数存在了磁盘上，因此执行 count(*) 的时候会直接返回这个数，效率很高（前提是不适用where）；<br>InnoDB 在执行 count(*) 时，需要把数据一行一行地从引擎里面读出来，然后累计计数。<br>优化方案：自己计数，如创建key-value表存储在内存或硬盘，或者是用redis</p><p>count的几种用法：</p><ul><li>如果count函数的参数（count里面写的那个字段）不是NULL（字段值不为NULL），累计值就加一，最后返回累计值</li><li>用法：count(*)、count(主键)、count(字段)、count(1)</li><li>count(主键)跟count(*)一样，因为主键不能为空；count(字段)只计算字段值不为NULL的行；count(1)引擎会为每行添加一个1，然后就count这个1，返回结果也跟count(*)一样；count(null)返回0</li></ul><p>各种用法的性能：</p><ul><li>count(主键)：InnoDB引擎会遍历整张表，把每行的主键id值都取出来，返回给服务层，服务层拿到主键后，直接按行进行累加（主键不可能为空）</li><li>count(字段)：没有not null约束的话，InnoDB引擎会遍历整张表把每一行的字段值都取出来，返回给服务层，服务层判断是否为null，不为null，计数累加；有not null约束的话，InnoDB引擎会遍历整张表把每一行的字段值都取出来，返回给服务层，直接按行进行累加</li><li>count(1)：InnoDB 引擎遍历整张表，但不取值。服务层对于返回的每一层，放一个数字 1 进去，直接按行进行累加</li><li>count(*)：InnoDB 引擎并不会把全部字段取出来，而是专门做了优化，不取值，服务层直接按行进行累加</li></ul><p>按效率排序：count(字段) &lt; count(主键) &lt; count(1) &lt; count(*)，所以尽量使用 count(*)</p><h3 id="update优化（避免行锁升级为表锁）"><a href="#update优化（避免行锁升级为表锁）" class="headerlink" title="update优化（避免行锁升级为表锁）"></a>update优化（避免行锁升级为表锁）</h3><p>InnoDB 的行锁是针对索引加的锁，不是针对记录加的锁，并且该索引不能失效，否则会从行锁升级为表锁。</p><p>如以下两条语句：<br><code>update student set no = &#39;123&#39; where id = 1;</code>，这句由于id有主键索引，所以只会锁这一行；<br><code>update student set no = &#39;123&#39; where name = &#39;test&#39;;</code>，这句由于name没有索引，所以会把整张表都锁住进行数据更新，解决方法是给name字段添加索引，就可以由表锁变成行锁。</p><h2 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h2><p>视图（View）是一种虚拟存在的表。视图中的数据并不在数据库中实际存在，行和列数据来自定义视图的查询中使用的表，并且是在使用视图时动态生成的。<br>通俗的讲，视图只保存了查询的SQL逻辑，不保存查询结果。所以我们在创建视图的时候，主要的工作就落在创建这条SQL查询语句上。</p><h3 id="创建视图"><a href="#创建视图" class="headerlink" title="创建视图"></a>创建视图</h3><p><code>CREATE [ OR REPLACE ] VIEW 视图名称[（列名列表）] AS SELECT 语句 [ WITH [ CASCADED | LOCAL ] CHECK OPTION ]</code></p><blockquote><p>例子： <code>create or replace view stu_wll as select id,name from student where id&lt;=10;</code></p></blockquote><h3 id="查询视图"><a href="#查询视图" class="headerlink" title="查询视图"></a>查询视图</h3><p>查看创建视图语句： <code>SHOW CREATE VIEW </code>视图名称；</p><p>查看视图数据：<code>SELECT*FROM </code> 视图名称；<br><code>show create view stu_v_1;</code></p><h3 id="修改视图"><a href="#修改视图" class="headerlink" title="修改视图"></a>修改视图</h3><p>方式一：<code>CREATE[OR REPLACE] VIEW 视图名称[（列名列表)）] AS SELECT 语句[ WITH[ CASCADED | LOCAL ] CHECK OPTION ]</code></p><p>方式二：<code>ALTER VIEW 视图名称 [（列名列表)] AS SELECT语句 [WITH [CASCADED | LOCAL] CHECK OPTION]</code></p><h3 id="删除视图"><a href="#删除视图" class="headerlink" title="删除视图"></a>删除视图</h3><p><code>DROP VIEW [IF EXISTS] 视图名称 [视图名称]</code></p><h3 id="视图检查选项"><a href="#视图检查选项" class="headerlink" title="视图检查选项"></a>视图检查选项</h3><p>当使用WITH CHECK QPTION子句创建视图时，MySQL会通过视图检查正在更改的每个行，例如插入，更新，删除，以使其符合视图的定义。MySQL允许基于另一个视图创建视图，它还会检查依赖视图中的规则以保持一致性。为了确定检查的范围，mysql提供了两个选项：CASCADED 和 LOCAL ，默认值为 CASCADED。</p><p>NOTE：如果没有开检查选项就不会进行检查。不同版本是不同含义的，要看版本。</p><h4 id="CASCADED"><a href="#CASCADED" class="headerlink" title="CASCADED"></a>CASCADED</h4><p><code>级联，一旦选择了这个选项，除了会检查创建视图时候的条件，还会检查所依赖视图的条件。</code></p><blockquote><p>比如下面的例子：创建stu_V_l 视图，id是小于等于 20的。<br><code>create or replace view stu_V_l as select id,name from student where id &lt;=20;</code><br>再创建 stu_v_2 视图，20 &gt;&#x3D; id &gt;&#x3D;10。<br><code>create or replace view stu_v_2 as select id,name from stu_v_1 where id &gt;=10 with cascaded check option;</code><br>再创建 stu_v_3 视图。<br><code>create or replace view stu_v_3 as select id,name from stu_v_2 where id&lt;=15;</code><br>这条数据能够成功，stu_v_3 没有开检查选项所以不会 去判断 id 是否小于等于15, 直接检查 是否满足 stu_v_2。<br><code>insert into stu_v_3 values(17,&#39;Tom&#39;);</code></p></blockquote><h4 id="LOCAL"><a href="#LOCAL" class="headerlink" title="LOCAL"></a>LOCAL</h4><p>本地的条件也会检查，还会向上检查。在向上找的时候，就要看是否上面开了检查选项，如果没开就不检查。和 CASCADED 的区别就是 CASCADED 不管上面开没开检查选项都会进行检查。</p><h3 id="更新及作用"><a href="#更新及作用" class="headerlink" title="更新及作用"></a>更新及作用</h3><p>要使视图可更新，视图中的行与基础表中的行之间必须存在一对一的关系。如果视图包含以下任何一项，则该视图不可更新</p><ol><li>聚合函数或窗口函数 ( SUM()、MIN()、MAX()、COUNT() 等 )</li><li>DISTINCT</li><li>GROUP BY</li><li>HAVING</li><li>UNION 或者UNION ALL</li></ol><blockquote><p>例子： 使用了聚合函数，插入会失败。<br><code>create view stu_v_count as select count(*) from student;</code><br><code>insert into stu_v_count values(10);</code></p></blockquote><p>作用</p><p>视图不仅可以简化用户对数据的理解，也可以简化他们的操作。那些被经常使用的查询可以被定义为视图，从而使得用户不必为以后的操作每次指定全部的条件。</p><blockquote><p>安全<br>数据库可以授权，但不能授权到数据库特定行和特定的列上。通过视图用户只能查询和修改他们所能见到的数据<br>数据独立<br>视图可帮助用户屏蔽真实表结构变化带来的影响。</p></blockquote><p>总而言之 类似于给表加上了一个外壳，通过这个外壳访问表的时候，只能按照所设计的方式进行访问与更新。</p><h2 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h2><p>存储过程是事先经过编译并存储在数据库中的一段SQL 语句的集合，调用存储过程可以简化应用开发人员的很多工作，减少数据在数据库和应用服务器之间的传输，对于提高数据处理的效率是有好处的。<br>存储过程思想上很简单，就是数据库SQL 语言层面的代码封装与重用。</p><p>特点</p><ol><li>封装</li><li>复用</li><li>可以接收参数，也可以返回数据减少网络交互，效率提升</li></ol><h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><pre><code>CREATE PROCEDURE 存储过程名称( [参数列表] )BEGINSQL 语句END;</code></pre><p>NOTE: 在命令行中，执行创建存储过程的SQL时，需要通过关键字delimiter 指定SQL语句的结束符。默认是 分号作为结束符。</p><p>delimiter $ ，则 $ 符作为结束符。</p><h3 id="调用"><a href="#调用" class="headerlink" title="调用"></a>调用</h3><p>CALL 名称 ( [参数])</p><h3 id="查看"><a href="#查看" class="headerlink" title="查看"></a>查看</h3><p>查询指定数据库的存储过程及状态信息</p><p><code>SELECT* FROM INFORMATION_SCHEMA.ROUTINES WHERE ROUTINE_SCHEMA = &#39;xxx&#39; </code></p><p>存储过程名称；–查询某个存储过程的定义</p><p><code>SHOW CREATE PROCEDURE</code></p><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p><code>DROP PROCEDURE [ IFEXISTS ] 存储过程名称</code></p><h3 id="游标"><a href="#游标" class="headerlink" title="游标"></a>游标</h3><p>游标（CURSOR）是用来存储查询结果集的数据类型，在存储过程和函数中可以使用游标对结果集进行循环的处理。游标的使用包括游标的声明、OPEN、FETCH和CLOSE，其语法分别如下。</p><blockquote><p>声明游标：<br><code>DECLARE 游标名称 CURSOR FOR 查询语句</code></p></blockquote><blockquote><p>打开游标：<br><code>OPEN 游标名称</code></p></blockquote><blockquote><p>获取游标记录：<br><code>FETCH 游标名称INTO变量[变量]</code></p></blockquote><p>条件处理程序：条件处理程序（Handler）可以用来定义在流程控制结构执行过程中遇到问题时相应的处理步骤。具体语法为：</p><blockquote><p>DECLARE handler action HANDLER FOR condition value L condition value]..statement</p></blockquote><p>handler_action CONTINUE：继续执行当前程序</p><p>EXIT：终止执行当前程序</p><p>condition_value :</p><p><code>SQLSTATE sqlstate_value：状态码，如02000</code></p><p><code>SQLWARNING：所有以01开头的SQLSTATE代码的简写</code></p><p><code>NOT FOUND：所有以02开头的SQLSTATE代码的简写</code></p><p><code>SQLEXCEPTION：所有没有被SQLWARNING或NOT FOUND捕获的SQLSTATE代码的简写</code></p><p>例子：</p><p>NOTE：要先声明普通变量，再申请游标。</p><p>要求：<br><code>根据传入的参数uage，来查询用户表tb_user中，所有的用户年龄小于等于uage的用户姓名（name）和专业（profession），并将用户的姓名和专业插入到所创建的一张新表（id，name，profession）中。</code></p><pre><code>create procedure p1l(in uage int)begindeclare uname varchar(100);decLare upro varchar(100);declare u_cursor cursor for select name,profession from tb_user where age &lt;= uage;当 条件处理程序的处理的状态码为02000的时候，就会退出。        declare exit handler for SQLSTATE &#39;02000&#39;close u_cursor;drop table if exists tb_user_pro;create table if not exists tb_user_pro(id int primary key auto_increment,name varchar(100),profession varchar(100));open u_cursor;while true dofetch u_cursor into uname,Upro;insert into tb_user_pro values(null,uname,Upro);end while;close u_cursor;end;</code></pre><h2 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h2><p>介绍<br>触发器是与表有关的数据库对象，指在insert&#x2F;update&#x2F;delete之前或之后，触发并执行触发器中定义的SQL语句集合。触发器的这种特性可以协助应用在数据库端确保数据的完整性，日志记录，数据校验等操作。<br>使用别名OLD和NEW来引用触发器中发生变化的记录内容，这与其他的数据库是相似的。现在触发器还只支持行级触发（比如说 一条语句影响了 5 行 则会被触发 5 次），不支持语句级触发（比如说 一条语句影响了 5 行 则会被触发 1 次）。</p><table><thead><tr><th>触发器类型</th><th>NEW 和 OLD</th></tr></thead><tbody><tr><td>INSERT</td><td>NEW 表示将要或者已经新增的数据</td></tr><tr><td>UPDATE</td><td>OLD表示修改之前的数据，NEW表示将要或已经修改后的数据</td></tr><tr><td>DELETE</td><td>OLD表示将要或者已经删除的数据</td></tr></tbody></table><h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><p>锁是计算机协调多个进程或线程并发访问某一资源的机制。在数据库中，除传统的计算资源（CPU、RAM、I&#x2F;O）的争用以外，数据也是一种供许多用户共享的资源。如何保证数据并发访问的一致性、有效性是所有数据库必须解决的一个问题，锁冲突也是影响数据库并发访问性能的一个重要因素。从这个角度来说，锁对数据库而言显得尤其重要，也更加复杂。</p><p>NOTE : 针对事物才有加锁的意义。</p><p>分类：MySQL中的锁，按照锁的粒度分，分为以下三类：</p><ol><li>全局锁：锁定数据库中的所有表。</li><li>表级锁：每次操作锁住整张表。</li><li>行级锁：每次操作锁住对应的行数据。</li></ol><p>全局锁：</p><p>全局锁就是对整个数据库实例加锁，加锁后整个实例就处于只读状态，后续的DML的写语句，DDL语句，已经更新操作的事务提交语句都将被阻塞。<br>其典型的使用场景是做全库的逻辑备份，对所有的表进行锁定，从而获取一致性视图，保证数据的完整性。</p><p>表锁：</p><p>表级锁，每次操作锁住整张表。锁定粒度大，发生锁冲突的概率最高，并发度最低。应用在MyISAM、InnoDB、BDB等存储引擎中。</p><p>对于表级锁，主要分为以下三类：</p><ol><li>表锁：对于表锁，分为两类：1.表共享读锁（read lock）所有的事物都只能读（当前加锁的客户端也只能读，不能写），不能写 2.表独占写锁（write lock），对当前加锁的客户端，可读可写，对于其他的客户端，不可读也不可写。读锁不会阻塞其他客户端的读，但是会阻塞写。写锁既会阻塞其他客户端的读，又会阻塞其他客户端的写。</li><li>元数据锁（meta data lock，MDL），MDL加锁过程是系统自动控制，无需显式使用，在访问一张表的时候会自动加上。MDL锁主要作用是维护表元数据的数据一致性，在表上有活动事务的时候，不可以对元数据进行写入操作。在MySQL5.5中引入了MDL，当对一张表进行增删改查的时候，加MDL读锁（共享）;当对表结构进行变更操作的时候，加MDL写锁（排他）。</li><li>意向锁: 为了避免DML在执行时，加的行锁与表锁的冲突，在InnoDB中引入了意向锁，使得表锁不用检查每行数据是否加锁，使用意向锁来减少表锁的检查。<br>一个客户端对某一行加上了行锁，那么系统也会对其加上一个意向锁，当别的客户端来想要对其加上表锁时，便会检查意向锁是否兼容，若是不兼容，便会阻塞直到意向锁释放。</li></ol><p>意向锁兼容性：</p><ol><li>意向共享锁（IS）：与表锁共享锁（read）兼容，与表锁排它锁（write）互斥。</li><li>意向排他锁（lX）：与表锁共享锁（read）及排它锁（write）都互斥。意向锁之间不会互斥。</li></ol><p>行锁：</p><p>行级锁，每次操作锁住对应的行数据。锁定粒度最小，发生锁冲突的概率最低，并发度最高。应用在InnoDB存储引擎中。InnoDB的数据是基于索引组织的，行锁是通过对索引上的索引项加锁来实现的，而不是对记录加的锁。对于行级锁，主要分为以下三类：</p><ol><li>行锁（Record Lock）：锁定单个行记录的锁，防止其他事务对此行进行update和delete。在RC（read commit ）、RR（repeat read）隔离级别下都支持。</li><li>间隙锁（GapLock）：锁定索引记录间隙（不含该记录），确保索引记录间隙不变，防止其他事务在这个间隙进行insert，产生幻读。在RR隔离级别下都支持。比如说 两个临近叶子节点为 15 23，那么间隙就是指 [15 , 23],锁的是这个间隙。</li><li>临键锁（Next-Key Lock）：行锁和间隙锁组合，同时锁住数据，并锁住数据前面的间隙Gap。在RR隔离级别下支持。</li></ol><p>InnoDB实现了以下两种类型的行锁：</p><ol><li>共享锁（S）：允许一个事务去读一行，阻止其他事务获得相同数据集的排它锁。</li><li>排他锁（X）：允许获取排他锁的事务更新数据，阻止其他事务获得相同数据集的共享锁和排他锁。</li></ol><table><thead><tr><th>SQL</th><th>行锁类型</th><th>说明</th></tr></thead><tbody><tr><td>insert</td><td>排他锁</td><td>自动加锁</td></tr><tr><td>update</td><td>排他锁</td><td>自动加锁</td></tr><tr><td>delete</td><td>排他锁</td><td>自动加锁</td></tr><tr><td>select</td><td>不加任何锁</td><td></td></tr><tr><td>select　lock　in　share mode</td><td>排他锁</td><td>需要手动在SELECT之后加LOCK IN SHARE MODE</td></tr><tr><td>select　for　update</td><td>排他锁</td><td>需要手动在SELECT之后加FOR UPDATE</td></tr></tbody></table><p>行锁 - 演示</p><p>默认情况下，InnoDB在REPEATABLE READ事务隔离级别运行，InnoDB使用next-key 锁进行搜索和索引扫描，以防止幻读。</p><ol><li>针对唯一索引进行检索时，对已存在的记录进行等值匹配时，将会自动优化为行锁。</li><li>InnoDB的行锁是针对于索引加的锁，不通过索引条件检索数据，那么InnoDB将对表中的所有记录加锁，此时就会升级为表锁。</li></ol><p>间隙锁&#x2F;临键锁-演示</p><p>默认情况下，InnoDB在REPEATABLE READ事务隔离级别运行，InnoDB使用next-key 锁进行搜索和索引扫描，以防止幻读。</p><ol><li>索引上的等值查询（唯一索引），给不存在的记录加锁时，优化为间隙锁。</li><li>索引上的等值查询（普通索引），向右遍历时最后一个值不满足查询需求时，next-key lock 退化为间隙锁。</li><li>索引上的范围查询（唯一索引）–会访问到不满足条件的第一个值为止。</li></ol><p>注意：间隙锁唯一目的是防止其他事务插入间隙。间隙锁可以共存，一个事务采用的间隙锁不会阻止另一个事务在同一间隙上采用间隙锁。</p><h2 id="InnoDB-引擎"><a href="#InnoDB-引擎" class="headerlink" title="InnoDB 引擎"></a>InnoDB 引擎</h2><h3 id="逻辑存储结构"><a href="#逻辑存储结构" class="headerlink" title="逻辑存储结构"></a>逻辑存储结构</h3><p>表空间（ibd文件），一个mysql实例可以对应多个表空间，用于存储记录、索引等数据。</p><p>段，分为数据段（Leaf node segment）、索引段（Non-leaf node segment）、回滚段（Rollback segment），InnoDB是索引组织表，数据段就是B+树的叶子节点，索引段即为B+树的非叶子节点。段用来管理多个Extent（区）。</p><p>区，表空间的单元结构，每个区的大小为1M。默认情况下，InnoDB存储引擎页大小为16K，即一个区中一共有64个连续的页。</p><p>页，是InnoDB存储引擎磁盘管理的最小单元，每个页的大小默认为16KB。为了保证页的连续性，InnoDB存储引擎每从磁盘申请4-5个区。一页包含若干行。</p><p>行，InnoDB存储引擎数据是按进行存放的。</p><h3 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h3><p><img src="https://github.com/Buildings-Lei/mysql_note/blob/main/images/artic.png" alt="images"></p><p>Buffer Pool：缓冲池是主内存中的一个区域，里面可以缓存磁盘上经常操作的真实数据，在执行增删改查操作时，先操作缓冲池中的数据（若缓冲池没有数据，则从磁盘加载并缓存），然后再以一定频率刷新到磁盘，从而减少磁盘I0，加快处理速度。</p><p><img src="https://github.com/Buildings-Lei/mysql_note/blob/main/images/artic2.png" alt="images"><br><img src="https://github.com/Buildings-Lei/mysql_note/blob/main/images/artic3.png" alt="images"><br><img src="https://github.com/Buildings-Lei/mysql_note/blob/main/images/artic4.png" alt="images"><br><img src="https://github.com/Buildings-Lei/mysql_note/blob/main/images/artic5.png" alt="images"></p><p>磁盘架构：<br><img src="https://github.com/Buildings-Lei/mysql_note/blob/main/images/artic6.png" alt="images"><br><img src="https://github.com/Buildings-Lei/mysql_note/blob/main/images/artic7.png" alt="images"><br><img src="https://github.com/Buildings-Lei/mysql_note/blob/main/images/artic8.png" alt="images"></p><p>InnoDB的整个体系结构为：</p><p>当业务操作的时候直接操作的是内存缓冲区，如果缓冲区当中没有数据，则会从磁盘中加载到缓冲区，增删改查都是在缓冲区的，后台线程以一定的速率刷新到磁盘。</p><h2 id="事务原理"><a href="#事务原理" class="headerlink" title="事务原理"></a>事务原理</h2><p>事务是一组操作的集合，它是一个不可分割的工作单位，事务会把所有的操作作为一个整体一起向系统提交或撤销操作请求，即这些操作要么同时成功，要么同时败。具有ACID四大特征。</p><p>原子性，一致性，持久性这三大特性由 redo log 和 undo log 日志来保证的。<br>隔离性 是由锁机制和MVCC保证的。</p><p>redo log:</p><p>重做日志，记录的是事务提交时数据页的物理修改，是用来实现事务的持久性。<br>该日志文件由两部分组成：重做日志缓冲（redo log buffer）以及重做日志文件（redo log file），前者是在内存中，后者在磁盘中。当事务提交之后会把所有修改信息都存到该日志文件中，用于在刷新脏页到磁盘，发生错误时，进行数据恢复使用。</p><blockquote><p>个人理解： 事物每次提交的时候都会将数据刷到redo log中而不是直接将buffer pool中的数据直接刷到磁盘中（ibd文件中），是因为redo log 是顺序写，性能处理的够快，直接刷到ibd中，是随机写，性能慢。所以脏页是在下一次读的时候，或者后台线程采用一定的机制进行刷盘到ibd中。</p></blockquote><p>undo log:回滚日志，用于记录数据被修改前的信息，作用包含两个：提供回滚和MVCC（多版本并发控制）。<br>undo log和redo log记录物理日志不一样，它是逻辑日志。可以认为当delete一条记录，undo log中会记录一条对应的insert记录，反之亦然，当update一条记录时，它记录一条对应相反的update记录。当执行rollback时，就可以从undo log中的逻辑记录读取到相应的内容并进行回滚。</p><blockquote><p>Undo log销毁：undo log在事务执行时产生，事务提交时，并不会立即删除undo log，因为这些日志可能还用于MVCC。<br>Undo log存储：undo log采用段的方式进行管理和记录，存放在前面介绍的rollback segment回滚段中，内部包含1024个undo log segment。</p></blockquote><h2 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h2><h3 id="当前读"><a href="#当前读" class="headerlink" title="当前读:"></a>当前读:</h3><p>读取的是记录的最新版本，读取时还要保证其他并发事务不能修改当前记录，会对读取的记录进行加锁。对于我们日常的操作，如：</p><ul><li>select…lock in share mode（共享锁）。</li><li>select..…for update、update、insert、delete（排他锁）都是一种当前读。</li></ul><h3 id="快照读"><a href="#快照读" class="headerlink" title="快照读:"></a>快照读:</h3><p>简单的select（不加锁）就是快照读，快照读，读取的是记录数据的可见版本，有可能是历史数据，不加锁，是非阻塞读。</p><ul><li>Read Committed：每次select，都生成一个快照读。</li><li>Repeatable Read：开启事务后第一个select语句才是快照读的地方。</li><li>Serializable：快照读会退化为当前读。</li></ul><h3 id="MVCC-1"><a href="#MVCC-1" class="headerlink" title="MVCC:"></a>MVCC:</h3><p>全称Multi-Version Concurrency Control，多版本并发控制。指维护一个数据的多个版本，使得读写操作没有冲突，快照读为MySQL实现MVCC提供了一个非阻塞读功能。MVCC的具体实现，还需要依赖于数据库记录中的三个隐式字段、undo log日志、readView。</p><h4 id="MVCC-实现原理"><a href="#MVCC-实现原理" class="headerlink" title="MVCC 实现原理:"></a>MVCC 实现原理:</h4><p>有三个隐藏的字段:</p><p><img src="https://github.com/Buildings-Lei/mysql_note/blob/main/images/MVCC.png" alt="images"></p><blockquote><p>undo log回滚日志，在insert、update、delete的时候产生的便于数据回滚的日志。<br>当insert的时候，产生的undo log日志只在回滚时需要，在事务提交后，可被立即删除。<br>而update、delete的时候，产生的undo log日志不仅在回滚时需要，在快照读时也需要，不会立即被删除。</p></blockquote><p>undo log 版本链：</p><p>undo log日志会记录原来的版本的数据，因为是通过undo log 日志进行回滚的。</p><p><img src="https://github.com/Buildings-Lei/mysql_note/blob/main/images/MVCCList.png" alt="images"></p><p>如何确定返回哪一个版本 这是由read view决定返回 undo log 中的哪一个版本。</p><p><img src="https://github.com/Buildings-Lei/mysql_note/blob/main/images/readview0.png" alt="images"></p><blockquote><p>RC隔离级别下，在事务中每一次执行快照读时生成ReadView。<br>RR隔离级别下，在事务中第一次执行快照读时生成ReadView，后续会复用。</p></blockquote><blockquote><p><a href="https://www.bilibili.com/video/BV1Kr4y1i7ru?p=145&amp;spm_id_from=pageDriver&amp;vd_source=bbc04b831b54029788a178a7c2e9ae20">https://www.bilibili.com/video/BV1Kr4y1i7ru?p=145&amp;spm_id_from=pageDriver&amp;vd_source=bbc04b831b54029788a178a7c2e9ae20</a></p></blockquote><p>MVCC 靠 隐藏字段 , undo log 版本链 , read view 实现的。</p><ul><li>原子性-undo log</li><li>持久性-redo log</li><li>一致性-undo log + redo log</li><li>隔离性-锁 + MVCC</li></ul><p><img src="https://github.com/Buildings-Lei/mysql_note/blob/main/images/readview.png" alt="images"></p><h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><h2 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h2><table><thead><tr><th>类型名称</th><th>取值范围</th><th>大小</th></tr></thead><tbody><tr><td>TINYINT</td><td>-128〜127</td><td>1个字节</td></tr><tr><td>SMALLINT</td><td>-32768〜32767</td><td>2个宇节</td></tr><tr><td>MEDIUMINT</td><td>-8388608〜8388607</td><td>3个字节</td></tr><tr><td>INT (INTEGHR)</td><td>-2147483648〜2147483647</td><td>4个字节</td></tr><tr><td>BIGINT</td><td>-9223372036854775808〜9223372036854775807</td><td>8个字节</td></tr></tbody></table><p>无符号在数据类型后加 unsigned 关键字。</p><h2 id="浮点型"><a href="#浮点型" class="headerlink" title="浮点型"></a>浮点型</h2><table><thead><tr><th>类型名称</th><th>说明</th><th>存储需求</th></tr></thead><tbody><tr><td>FLOAT</td><td>单精度浮点数</td><td>4 个字节</td></tr><tr><td>DOUBLE</td><td>双精度浮点数</td><td>8 个字节</td></tr><tr><td>DECIMAL (M, D)，DEC</td><td>压缩的“严格”定点数</td><td>M+2 个字节</td></tr></tbody></table><h2 id="日期和时间"><a href="#日期和时间" class="headerlink" title="日期和时间"></a>日期和时间</h2><table><thead><tr><th>类型名称</th><th>日期格式</th><th>日期范围</th><th>存储需求</th></tr></thead><tbody><tr><td>YEAR</td><td>YYYY</td><td>1901 ~ 2155</td><td>1 个字节</td></tr><tr><td>TIME</td><td>HH:MM:SS</td><td>-838:59:59 ~ 838:59:59</td><td>3 个字节</td></tr><tr><td>DATE</td><td>YYYY-MM-DD</td><td>1000-01-01 ~ 9999-12-3</td><td>3 个字节</td></tr><tr><td>DATETIME</td><td>YYYY-MM-DD HH:MM:SS</td><td>1000-01-01 00:00:00 ~ 9999-12-31 23:59:59</td><td>8 个字节</td></tr><tr><td>TIMESTAMP</td><td>YYYY-MM-DD HH:MM:SS</td><td>1980-01-01 00:00:01 UTC ~ 2040-01-19 03:14:07 UTC</td><td>4 个字节</td></tr></tbody></table><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><table><thead><tr><th>类型名称</th><th>说明</th><th>存储需求</th></tr></thead><tbody><tr><td>CHAR(M)</td><td>固定长度非二进制字符串</td><td>M 字节，1&lt;&#x3D;M&lt;&#x3D;255</td></tr><tr><td>VARCHAR(M)</td><td>变长非二进制字符串</td><td>L+1字节，在此，L&lt; &#x3D; M和 1&lt;&#x3D;M&lt;&#x3D;255</td></tr><tr><td>TINYTEXT</td><td>非常小的非二进制字符串</td><td>L+1字节，在此，L&lt;2^8</td></tr><tr><td>TEXT</td><td>小的非二进制字符串</td><td>L+2字节，在此，L&lt;2^16</td></tr><tr><td>MEDIUMTEXT</td><td>中等大小的非二进制字符串</td><td>L+3字节，在此，L&lt;2^24</td></tr><tr><td>LONGTEXT</td><td>大的非二进制字符串</td><td>L+4字节，在此，L&lt;2^32</td></tr><tr><td>ENUM</td><td>枚举类型，只能有一个枚举字符串值</td><td>1或2个字节，取决于枚举值的数目 (最大值为65535)</td></tr><tr><td>SET</td><td>一个设置，字符串对象可以有零个或 多个SET成员</td><td>1、2、3、4或8个字节，取决于集合 成员的数量（最多64个成员）</td></tr></tbody></table><h2 id="二进制类型"><a href="#二进制类型" class="headerlink" title="二进制类型"></a>二进制类型</h2><table><thead><tr><th>类型名称</th><th>说明</th><th>存储需求</th></tr></thead><tbody><tr><td>BIT(M)</td><td>位字段类型</td><td>大约 (M+7)&#x2F;8 字节</td></tr><tr><td>BINARY(M)</td><td>固定长度二进制字符串</td><td>M 字节</td></tr><tr><td>VARBINARY (M)</td><td>可变长度二进制字符串</td><td>M+1 字节</td></tr><tr><td>TINYBLOB (M)</td><td>非常小的BLOB</td><td>L+1 字节，在此，L&lt;2^8</td></tr><tr><td>BLOB (M)</td><td>小 BLOB</td><td>L+2 字节，在此，L&lt;2^16</td></tr><tr><td>MEDIUMBLOB (M)</td><td>中等大小的BLOB</td><td>L+3 字节，在此，L&lt;2^24</td></tr><tr><td>LONGBLOB (M)</td><td>非常大的BLOB</td><td>L+4 字节，在此，L&lt;2^32</td></tr></tbody></table><h1 id="权限一览表"><a href="#权限一览表" class="headerlink" title="权限一览表"></a>权限一览表</h1><blockquote><p>具体权限的作用详见<a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html" title="官方文档">官方文档</a></p></blockquote><p>GRANT 和 REVOKE 允许的静态权限</p><table><thead><tr><th align="left">Privilege</th><th align="left">Grant Table Column</th><th align="left">Context</th></tr></thead><tbody><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_all"><code>ALL [PRIVILEGES]</code></a></td><td align="left">Synonym for “all privileges”</td><td align="left">Server administration</td></tr><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_alter"><code>ALTER</code></a></td><td align="left"><code>Alter_priv</code></td><td align="left">Tables</td></tr><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_alter-routine"><code>ALTER ROUTINE</code></a></td><td align="left"><code>Alter_routine_priv</code></td><td align="left">Stored routines</td></tr><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_create"><code>CREATE</code></a></td><td align="left"><code>Create_priv</code></td><td align="left">Databases, tables, or indexes</td></tr><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_create-role"><code>CREATE ROLE</code></a></td><td align="left"><code>Create_role_priv</code></td><td align="left">Server administration</td></tr><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_create-routine"><code>CREATE ROUTINE</code></a></td><td align="left"><code>Create_routine_priv</code></td><td align="left">Stored routines</td></tr><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_create-tablespace"><code>CREATE TABLESPACE</code></a></td><td align="left"><code>Create_tablespace_priv</code></td><td align="left">Server administration</td></tr><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_create-temporary-tables"><code>CREATE TEMPORARY TABLES</code></a></td><td align="left"><code>Create_tmp_table_priv</code></td><td align="left">Tables</td></tr><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_create-user"><code>CREATE USER</code></a></td><td align="left"><code>Create_user_priv</code></td><td align="left">Server administration</td></tr><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_create-view"><code>CREATE VIEW</code></a></td><td align="left"><code>Create_view_priv</code></td><td align="left">Views</td></tr><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_delete"><code>DELETE</code></a></td><td align="left"><code>Delete_priv</code></td><td align="left">Tables</td></tr><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_drop"><code>DROP</code></a></td><td align="left"><code>Drop_priv</code></td><td align="left">Databases, tables, or views</td></tr><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_drop-role"><code>DROP ROLE</code></a></td><td align="left"><code>Drop_role_priv</code></td><td align="left">Server administration</td></tr><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_event"><code>EVENT</code></a></td><td align="left"><code>Event_priv</code></td><td align="left">Databases</td></tr><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_execute"><code>EXECUTE</code></a></td><td align="left"><code>Execute_priv</code></td><td align="left">Stored routines</td></tr><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_file"><code>FILE</code></a></td><td align="left"><code>File_priv</code></td><td align="left">File access on server host</td></tr><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_grant-option"><code>GRANT OPTION</code></a></td><td align="left"><code>Grant_priv</code></td><td align="left">Databases, tables, or stored routines</td></tr><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_index"><code>INDEX</code></a></td><td align="left"><code>Index_priv</code></td><td align="left">Tables</td></tr><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_insert"><code>INSERT</code></a></td><td align="left"><code>Insert_priv</code></td><td align="left">Tables or columns</td></tr><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_lock-tables"><code>LOCK TABLES</code></a></td><td align="left"><code>Lock_tables_priv</code></td><td align="left">Databases</td></tr><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_process"><code>PROCESS</code></a></td><td align="left"><code>Process_priv</code></td><td align="left">Server administration</td></tr><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_proxy"><code>PROXY</code></a></td><td align="left">See <code>proxies_priv</code> table</td><td align="left">Server administration</td></tr><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_references"><code>REFERENCES</code></a></td><td align="left"><code>References_priv</code></td><td align="left">Databases or tables</td></tr><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_reload"><code>RELOAD</code></a></td><td align="left"><code>Reload_priv</code></td><td align="left">Server administration</td></tr><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_replication-client"><code>REPLICATION CLIENT</code></a></td><td align="left"><code>Repl_client_priv</code></td><td align="left">Server administration</td></tr><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_replication-slave"><code>REPLICATION SLAVE</code></a></td><td align="left"><code>Repl_slave_priv</code></td><td align="left">Server administration</td></tr><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_select"><code>SELECT</code></a></td><td align="left"><code>Select_priv</code></td><td align="left">Tables or columns</td></tr><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_show-databases"><code>SHOW DATABASES</code></a></td><td align="left"><code>Show_db_priv</code></td><td align="left">Server administration</td></tr><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_show-view"><code>SHOW VIEW</code></a></td><td align="left"><code>Show_view_priv</code></td><td align="left">Views</td></tr><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_shutdown"><code>SHUTDOWN</code></a></td><td align="left"><code>Shutdown_priv</code></td><td align="left">Server administration</td></tr><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_super"><code>SUPER</code></a></td><td align="left"><code>Super_priv</code></td><td align="left">Server administration</td></tr><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_trigger"><code>TRIGGER</code></a></td><td align="left"><code>Trigger_priv</code></td><td align="left">Tables</td></tr><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_update"><code>UPDATE</code></a></td><td align="left"><code>Update_priv</code></td><td align="left">Tables or columns</td></tr><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_usage"><code>USAGE</code></a></td><td align="left">Synonym for “no privileges”</td><td align="left">Server administration</td></tr></tbody></table><p>GRANT 和 REVOKE 允许的动态权限</p><table><thead><tr><th align="left">Privilege</th><th align="left">Context</th></tr></thead><tbody><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_application-password-admin"><code>APPLICATION_PASSWORD_ADMIN</code></a></td><td align="left">Dual password administration</td></tr><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_audit-abort-exempt"><code>AUDIT_ABORT_EXEMPT</code></a></td><td align="left">Allow queries blocked by audit log filter</td></tr><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_audit-admin"><code>AUDIT_ADMIN</code></a></td><td align="left">Audit log administration</td></tr><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_authentication-policy-admin"><code>AUTHENTICATION_POLICY_ADMIN</code></a></td><td align="left">Authentication administration</td></tr><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_backup-admin"><code>BACKUP_ADMIN</code></a></td><td align="left">Backup administration</td></tr><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_binlog-admin"><code>BINLOG_ADMIN</code></a></td><td align="left">Backup and Replication administration</td></tr><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_binlog-encryption-admin"><code>BINLOG_ENCRYPTION_ADMIN</code></a></td><td align="left">Backup and Replication administration</td></tr><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_clone-admin"><code>CLONE_ADMIN</code></a></td><td align="left">Clone administration</td></tr><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_connection-admin"><code>CONNECTION_ADMIN</code></a></td><td align="left">Server administration</td></tr><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_encryption-key-admin"><code>ENCRYPTION_KEY_ADMIN</code></a></td><td align="left">Server administration</td></tr><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_firewall-admin"><code>FIREWALL_ADMIN</code></a></td><td align="left">Firewall administration</td></tr><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_firewall-exempt"><code>FIREWALL_EXEMPT</code></a></td><td align="left">Firewall administration</td></tr><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_firewall-user"><code>FIREWALL_USER</code></a></td><td align="left">Firewall administration</td></tr><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_flush-optimizer-costs"><code>FLUSH_OPTIMIZER_COSTS</code></a></td><td align="left">Server administration</td></tr><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_flush-status"><code>FLUSH_STATUS</code></a></td><td align="left">Server administration</td></tr><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_flush-tables"><code>FLUSH_TABLES</code></a></td><td align="left">Server administration</td></tr><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_flush-user-resources"><code>FLUSH_USER_RESOURCES</code></a></td><td align="left">Server administration</td></tr><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_group-replication-admin"><code>GROUP_REPLICATION_ADMIN</code></a></td><td align="left">Replication administration</td></tr><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_group-replication-stream"><code>GROUP_REPLICATION_STREAM</code></a></td><td align="left">Replication administration</td></tr><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_innodb-redo-log-archive"><code>INNODB_REDO_LOG_ARCHIVE</code></a></td><td align="left">Redo log archiving administration</td></tr><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_ndb-stored-user"><code>NDB_STORED_USER</code></a></td><td align="left">NDB Cluster</td></tr><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_passwordless-user-admin"><code>PASSWORDLESS_USER_ADMIN</code></a></td><td align="left">Authentication administration</td></tr><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_persist-ro-variables-admin"><code>PERSIST_RO_VARIABLES_ADMIN</code></a></td><td align="left">Server administration</td></tr><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_replication-applier"><code>REPLICATION_APPLIER</code></a></td><td align="left"><code>PRIVILEGE_CHECKS_USER</code> for a replication channel</td></tr><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_replication-slave-admin"><code>REPLICATION_SLAVE_ADMIN</code></a></td><td align="left">Replication administration</td></tr><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_resource-group-admin"><code>RESOURCE_GROUP_ADMIN</code></a></td><td align="left">Resource group administration</td></tr><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_resource-group-user"><code>RESOURCE_GROUP_USER</code></a></td><td align="left">Resource group administration</td></tr><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_role-admin"><code>ROLE_ADMIN</code></a></td><td align="left">Server administration</td></tr><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_session-variables-admin"><code>SESSION_VARIABLES_ADMIN</code></a></td><td align="left">Server administration</td></tr><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_set-user-id"><code>SET_USER_ID</code></a></td><td align="left">Server administration</td></tr><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_show-routine"><code>SHOW_ROUTINE</code></a></td><td align="left">Server administration</td></tr><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_system-user"><code>SYSTEM_USER</code></a></td><td align="left">Server administration</td></tr><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_system-variables-admin"><code>SYSTEM_VARIABLES_ADMIN</code></a></td><td align="left">Server administration</td></tr><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_table-encryption-admin"><code>TABLE_ENCRYPTION_ADMIN</code></a></td><td align="left">Server administration</td></tr><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_version-token-admin"><code>VERSION_TOKEN_ADMIN</code></a></td><td align="left">Server administration</td></tr><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_xa-recover-admin"><code>XA_RECOVER_ADMIN</code></a></td><td align="left">Server administration</td></tr></tbody></table><h1 id="图形化界面工具"><a href="#图形化界面工具" class="headerlink" title="图形化界面工具"></a>图形化界面工具</h1><ul><li>Workbench(免费): <a href="http://dev.mysql.com/downloads/workbench/">http://dev.mysql.com/downloads/workbench/</a></li><li>navicat(收费，试用版30天): <a href="https://www.navicat.com/en/download/navicat-for-mysql">https://www.navicat.com/en/download/navicat-for-mysql</a></li><li>Sequel Pro(开源免费，仅支持Mac OS): <a href="http://www.sequelpro.com/">http://www.sequelpro.com/</a></li><li>HeidiSQL(免费): <a href="http://www.heidisql.com/">http://www.heidisql.com/</a></li><li>phpMyAdmin(免费): <a href="https://www.phpmyadmin.net/">https://www.phpmyadmin.net/</a></li><li>SQLyog: <a href="https://sqlyog.en.softonic.com/">https://sqlyog.en.softonic.com/</a></li></ul><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><h1 id="小技巧"><a href="#小技巧" class="headerlink" title="小技巧"></a>小技巧</h1><ol><li>在SQL语句之后加上 <code>\G</code>会将结果的表格形式转换成行文本形式</li><li>查看Mysql数据库占用空间：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT table_schema &quot;Database Name&quot;</span><br><span class="line">     , SUM(data_length + index_length) / (1024 * 1024) &quot;Database Size in MB&quot;</span><br><span class="line">FROM information_schema.TABLES</span><br><span class="line">GROUP BY table_schema;</span><br></pre></td></tr></table></figure><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><blockquote><p><a href="https://dhc.pythonanywhere.com/entry/share/?key=3ad29aad765a2b98b2b2a745d71bef715507ee9db8adbec98257bac0ad84cbe4#h1-u6743u9650u4E00u89C8u8868">https://dhc.pythonanywhere.com/entry/share/?key=3ad29aad765a2b98b2b2a745d71bef715507ee9db8adbec98257bac0ad84cbe4#h1-u6743u9650u4E00u89C8u8868</a><br>这篇笔记是在别人的基础上完善而来，感谢B站的黑马程序员up主，也感谢路途博客。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> SQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java复习笔记</title>
      <link href="/2022/12/01/Java%E7%AC%94%E8%AE%B0/"/>
      <url>/2022/12/01/Java%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h2><h3 id="1-什么是类和对象"><a href="#1-什么是类和对象" class="headerlink" title="1.什么是类和对象"></a>1.什么是类和对象</h3><ul><li>类是现实生活中一类具有<strong>共同属性</strong>和<strong>行为</strong>的事物的抽象</li><li>类的组成：属性和行为(方法)</li><li>对象是由类实例化而来</li><li>一个类可以有多个对象</li><li>创建对象的方法：<code>类名 对象名 = new 类名();</code></li></ul><h3 id="2-成员变量和局部变量"><a href="#2-成员变量和局部变量" class="headerlink" title="2.成员变量和局部变量"></a>2.成员变量和局部变量</h3><ul><li>成员变量：类中方法外的变量</li><li>局部变量：方法中的变量</li><li>区别<table><thead><tr><th align="center">区别</th><th align="center">成员变量</th><th align="center">局部变量</th></tr></thead><tbody><tr><td align="center">类中位置不同</td><td align="center">类中方法外</td><td align="center">方法内或或者方法声明上(形参)</td></tr><tr><td align="center">内存中位置不同</td><td align="center">堆内存</td><td align="center">栈内存</td></tr><tr><td align="center">生命周期</td><td align="center">随对象的存在而存在，随对象的消失而消失</td><td align="center">随着方法的调用而存在，随着方法的调用完毕而消失</td></tr><tr><td align="center">初始化值不同</td><td align="center">有默认的初始化值</td><td align="center">没有默认的初始化值，必须先定义，赋值才能使用</td></tr></tbody></table></li></ul><h3 id="3-封装"><a href="#3-封装" class="headerlink" title="3.封装"></a>3.封装</h3><p>a.private修饰符：</p><ul><li>权限修饰符，可以用来修饰成员(变量、方法)</li><li>特点：只能在本类当中进行访问</li><li>针对被private修饰的成员变量，如需被其它类使用，提供相应的操作：<ol><li>提供 <code>get变量名()</code>方法，用于获取成员变量的值，方法用<strong>public</strong>修饰</li><li>提供 <code>set变量名(参数)</code>方法，用于设置成员变量的值，方法用<strong>public</strong>修饰</li></ol></li></ul><p>b.this关键字</p><ul><li>在类的方法内如果局部变量和成员变量出现同名的情况下，Java会使用“就近原则”，将同名的成员变量当作局部变量</li><li>为了在方法内使用到成员变量，可以使用<strong>this</strong>关键字</li><li>this关键字的作用：可以调用本类的成员(变量、方法)，解决局部变量和成员变量重名的问题</li><li>this代表所在类的对象引用，方法被哪个对象调用，this就代表哪个对象</li></ul><p>c.封装的思想</p><ul><li>隐藏实现的细节，仅对外暴露公共的访问方式</li><li>封装的常见体现：<ol><li>私有化成员变量，提供setXxx()和getXxx()方法</li><li>将代码抽取到方法中，这是对代码的一种封装</li><li>将属性抽取到类当中，这是对数据的一种封装</li></ol></li><li>封装的好处：<ol><li>提高代码安全性</li><li>提高代码复用性</li></ol></li></ul><h3 id="4-构造方法"><a href="#4-构造方法" class="headerlink" title="4.构造方法"></a>4.构造方法</h3><ul><li>构造方法是构造、创建对象时所调用的方法</li><li>格式：<ol><li>方法名与类名相同，大小写一致</li><li>没有返回值类型，连void都没有</li><li>没有具体的返回值(不能由return带回结果数据)</li></ol></li><li>执行时机：<ol><li>创建对象时调用，每创建一次对象，就会执行一次构造方法</li><li>不能手动调用构造方法</li></ol></li><li>作用：用于给对象的数据(属性)进行<strong>初始化</strong></li><li>注意事项：<ol><li>如果没有定义构造方法，系统将会给出一个<strong>默认</strong>的<strong>无参构造方法</strong></li><li>如果定义了构造方法，系统将不再提供默认的构造方法</li></ol></li><li>构造方法的重载：如果自定义了带参的构造方法，还需要使用无参的构造方法，就必须再手动给出无参构造方法</li><li>推荐使用方式：无论是否使用，都手动给出无参构造方法和带参构造方法</li></ul><h3 id="4-分包的思想"><a href="#4-分包的思想" class="headerlink" title="4.分包的思想"></a>4.分包的思想</h3><p>a.包的概念</p><ul><li>如果将所有的类文件都放在同一个包下，不利于管理和后期维护，所以对于不同功能的类文件，可以放在不同的包下进行管理</li><li>包的本质就是文件夹</li><li>创建包(单级包和多级包)：<ol><li>多级包之间使用“.”进行分割</li><li>包名规范：域名的翻转</li></ol></li><li>包的定义：<code>package 包名</code></li><li>注意事项：<ol><li>package语句必须是程序的第一条可执行的代码</li><li>package语句在一个java文件中只能有一个</li><li>如果没有package，默认表示无包名</li></ol></li></ul><p>b.类与类之间的访问</p><ul><li>同一个包下的访问：不需要导包，直接使用即可</li><li>不同包下的访问：<ol><li>import导包后访问</li><li>通过全类名(包名+类名)访问，应用场景是当有多个包下存在相同的类名并且需要同时使用这些类时，可以使用全类名来区分</li></ol></li><li>注意事项：<ol><li>package必须是程序的第一条可执行的代码</li><li>import需要写在package下面</li></ol></li></ul><h3 id="5-static关键字"><a href="#5-static关键字" class="headerlink" title="5.static关键字"></a>5.static关键字</h3><p>a.概念</p><ul><li>static是静态的意思，是Java中的一个修饰符，可以修饰成员变量和成员方法</li><li>static修饰的成员变量称为<strong>静态变量</strong></li><li>static修饰的成员方法称为<strong>静态方法</strong></li></ul><p>b.特点</p><ul><li>被类的所有对象共享，这是我们判断是否使用静态关键字的条件</li><li>随着类的加载而加载，<strong>优先于</strong>对象存在，而对象是需要类被加载后才能创建</li><li>可以通过类名调用，也可以通过对象名调用，但是推荐使用类名</li></ul><p>c.注意事项</p><ul><li>静态方法只能访问静态成员，不能访问非静态成员</li><li>非静态方法可以访问静态成员，也可以访问非静态成员</li><li>**静态方法中不能使用this关键字 **</li></ul><h3 id="6-继承"><a href="#6-继承" class="headerlink" title="6.继承"></a>6.继承</h3><p>a.概念</p><ul><li>继承是类与类之间的关系</li><li>子类继承了父类所有的<strong>非私有</strong>成员，除了构造器</li><li>子类可以<strong>直接</strong>访问父类中<strong>非私有</strong>的成员</li><li>子类不能直接访问父类的私有成员，但是可以通过父类中的公有方法来访问，例如<strong>set</strong>和<strong>get</strong>方法</li><li>使用 <code>extends</code>关键字来实现继承</li><li>父类又称为基类、超类，子类又称为派生类</li></ul><p>b.好处和弊端</p><p>好处：</p><ul><li>提高代码的复用性、维护性</li><li>让类与类之间产生关系，这是多态的前提</li></ul><p>弊端：</p><ul><li>继承是侵入性的</li><li>降低代码灵活性，继承关系导致子类必须拥有父类非私有属性和方法，让子类自由的世界中多了些约束</li><li>增强了代码的耦合性，耦合是指代码与代码之间存在关联</li></ul><p>使用继承的时机：</p><ul><li>当类与类之间存在相同(共性)内容，并且产生了<strong>is a</strong>的关系，就可以考虑使用继承来优化代码</li></ul><p>c.继承的特点</p><ul><li><p>Java只支持单继承，不支持多继承，但是支持多重继承</p></li><li><p>继承的成员变量访问特点</p><p>在子类方法中访问一个变量的顺序是</p><ol><li>先在局部范围找</li><li>在子类成员范围中找</li><li>在父类成员范围中找</li></ol><p>注意：如果在子类和父类中出现重名的成员变量，通过就近原则，会优先使用子类的，如果一定要使用父类的可以通过<strong>super</strong>关键字来区分</p></li><li><p>继承的成员方法的访问特点</p><p>通过子类对象访问一个方法的顺序是</p><ol><li>子类范围找</li><li>父类范围找</li></ol></li></ul><p>d.super关键字</p><ul><li>super和this用法相似</li><li>this代表本类对象的引用</li><li>super代表父类存储空间的标识(可以理解为父类对象的引用)</li><li>区别<table><thead><tr><th align="center">关键字</th><th align="center">访问成员变量</th><th align="center">访问成员方法</th><th align="center">访问构造方法</th></tr></thead><tbody><tr><td align="center">this</td><td align="center"><strong>this.成员变量</strong>访问本类成员变量</td><td align="center">**this.成员方法(参数)**访问本类成员方法</td><td align="center">**this(参数)**访问本类构造方法</td></tr><tr><td align="center">super</td><td align="center"><strong>super.成员变量</strong>访问父类成员变量</td><td align="center">**super.成员方法(参数)**访问父类成员方法</td><td align="center">**super(参数)**访问父类构造方法</td></tr></tbody></table></li></ul><p>e.方法重写和应用场景</p><ul><li>当子类需要父类的功能，而子类的功能主体比父类又多了特有的功能或者完全不同的功能时，可以<strong>重写</strong>父类中的方法</li><li>注意：<ol><li>方法重写（overrite）：在继承体系中，子类出现和父类一摸一样的方法声明（方法名，参数列表，返回值类型）</li><li>方法重载（overlode）：在同一个类中，方法名相同，参数列表不同，与返回值无关</li><li>父类中私有方法不能重写</li><li>父类中的静态方法，子类必须通过静态的方法进行重写（<strong>实际上静态方法不能被重写，但是子类中可以有一个与父类静态方法相同方法声明的静态方法，可以理解为子类将父类中同名的方法隐藏了起来，而不是方法重写</strong>）</li><li>父类中的非静态方法，子类也必须通过非静态方法重写</li><li>子类重写父类方法时，方法的访问权限必须<strong>大于或等于</strong>父类的</li></ol></li></ul><p>f.访问权限修饰符</p><table><thead><tr><th align="center">修饰符</th><th align="center">同一个类中</th><th align="center">同一个包中的子类或其他类</th><th align="center">不同包中的子类</th><th align="center">不同包中的其他类</th></tr></thead><tbody><tr><td align="center">private</td><td align="center">✔</td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">默认</td><td align="center">✔</td><td align="center">✔</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">protected</td><td align="center">✔</td><td align="center">✔</td><td align="center">✔</td><td align="center"></td></tr><tr><td align="center">public</td><td align="center">✔</td><td align="center">✔</td><td align="center">✔</td><td align="center">✔</td></tr></tbody></table><p>g.继承中构造方法的访问特点</p><ul><li><p>子类中<strong>所有</strong>构造方法默认都会访问父类中的<strong>无参</strong>构造方法</p></li><li><p>子类在初始化的时候可能需要用到父类中的数据，如果父类没有初始化，子类就无法使用父类的数据，所以<strong>子类初始化前一定要先完成父类的初始化</strong></p></li><li><p>构造方法的第一条语句默认都是<strong>super()</strong></p></li><li><p>如果编写的类没有指定父类，系统也会自动继承<strong>Object</strong>（最顶层父类）</p><p>如果父类不提供无参的构造方法？解决方法是</p></li><li><p>子类通过super手动调用父类<strong>带参构造方法</strong></p></li><li><p>子类通过this调用本类的其他构造方法，其他构造方法再通过super去调用父类的带参构造方法</p></li><li><p>注意：**this()和super()**在构造方法中必须处于第一行的位置，所以二者不能共存</p></li></ul><h3 id="7-抽象类"><a href="#7-抽象类" class="headerlink" title="7.抽象类"></a>7.抽象类</h3><p>a.概述</p><ul><li>抽象方法：将共性的行为（方法）抽取到父类后，发现该方法的实现逻辑无法在父类中给出具体的含义，该方法就可以定义为抽象方法</li><li>抽象类：如果一个类中存在抽象方法，那么该类必须声明为抽象类</li></ul><p>b.注意事项</p><ul><li>抽象类不允许实例化</li><li>抽象类中<strong>存在</strong>构造方法</li><li>抽象类的子类<strong>必须</strong>重写所有的抽象方法，或者子类也是一个抽象类</li><li>抽象类中可以没有抽象方法，但是存在抽象方法一定是抽象类</li></ul><h3 id="8-final关键字"><a href="#8-final关键字" class="headerlink" title="8.final关键字"></a>8.final关键字</h3><ul><li>final可以修饰<strong>类，方法，变量</strong></li><li>final修饰类：表明该类是最终类，不能被继承</li><li>final修饰方法：表明该方法是最终方法，不能被重写</li><li>final修饰变量：<ol><li>变量是基本数据类型：数据值不能改变</li><li>变量是引用类型：引用指向的地址不允许改变，但是地址里面的内容可以</li></ol></li><li>final修饰成员变量时建议直接赋值或者在构造方法中赋值</li></ul><h3 id="9-代码块"><a href="#9-代码块" class="headerlink" title="9.代码块"></a>9.代码块</h3><ul><li>局部代码块<ol><li>位置：方法内</li><li>特点：在<strong>方法内代码块外</strong>的地方访问不到代码块里边的变量</li><li>作用：限定变量生命周期，及早释放，提高内存利用率</li></ol></li><li>构造代码块<ol><li>位置：类中方法外</li><li>特点：每次构造方法执行时，都会执行改代码块中的代码，并且<strong>在构造方法执行前执行</strong></li><li>作用：将多个构造方法中相同的代码抽取到代码块中，提高代码复用性</li></ol></li><li>静态代码块<ol><li>位置：类中方法外</li><li>特点：需要用<strong>static</strong>关键字修饰，随着类的加载而加载，<strong>只执行一次</strong></li><li>作用：在类加载时做一些数据初始化的操作</li></ol></li><li>执行顺序（对于一个类中）：<strong>静态代码块-&gt;父类构造方法-&gt;构造代码块-&gt;子类构造方法</strong></li></ul><h3 id="10-接口"><a href="#10-接口" class="headerlink" title="10.接口"></a>10.接口</h3><ul><li>接口使用<strong>interface</strong>关键字来定义 <code>public interface 接口名&#123;&#125;</code></li><li>接口通过<strong>implements</strong>关键字来实现接口 <code>public classs 类名 implements 接口名&#123;&#125;</code></li><li>实现接口的类需要需要重写接口中<strong>所有</strong>的抽象方法或者实现接口的类是抽象类</li><li>接口不能实例化</li><li>接口允许多实现，即一个类可以实现多个接口</li><li>接口中成员特点<ol><li>成员变量：只能是常量，默认是<strong>public static final</strong>修饰</li><li>成员方法：只能是抽象方法，默认是<strong>public abstract</strong>修饰</li><li>没有构造方法</li></ol></li><li>JDK8中接口成员特点<ul><li>默认方法<ol><li>允许在接口中定义非抽象的方法，但是需要关键字<strong>default</strong>修饰，称为默认方法，作用是解决接口升级的问题</li><li>定义格式 <code>public default 返回值类型 方法名(参数列表)&#123;&#125;</code></li><li>public是默认的可以省略，但default不能省略</li><li>默认方法不是抽象方法，不强制重写，但是允许重写，<strong>重写时去掉default关键字</strong></li><li>如果某个类实现了多个接口，接口中出现<strong>相同方法声明的默认方法</strong>，则必须对该方法重写</li></ol></li><li>静态方法<ol><li>允许在接口中定义静态方法，需要关键字<strong>static</strong>修饰</li><li>定义格式 <code>public static 返回值类型 方法名(参数列表)&#123;&#125;</code></li><li>public是默认的可以省略，static不能省略</li><li>接口中的静态方法只能通过 <code>接口名.方法名()</code>来调用，不能通过实现该接口的类的类名和对象来调用</li></ol></li></ul></li><li>JDK9中接口成员特点<ol><li>接口中允许有私有方法，使用关键字<strong>private</strong>修饰</li><li>定义格式 <code>private 返回值类型 方法名(参数列表)&#123;&#125;</code>或者 <code>private static 返回值类型 方法名(参数列表)&#123;&#125;</code></li></ol></li><li>接口使用思路<ol><li>如果某个类全是抽象方法，那么该类可以改进为一个接口</li><li>设计大面积接口更新（添加新的方法）时不想去修改每一个实现该接口的类，可以将更新的方法定义为带方法体的默认方法</li><li>希望默认方法调用更加简洁，可以考虑定义静态方法</li><li>默认方法中出现重复的代码，可以考虑抽取出一个私有方法</li></ol></li><li>接口与接口的关系<ol><li>可以单继承，使用关键字<strong>extends</strong>修饰</li><li>可以实现多继承，即一个接口可以继承多个接口</li><li>多继承时如果被继承的多个接口中存在<strong>相同方法声明的默认方法</strong>，则需要在继承时重写该方法</li></ol></li></ul><h3 id="11-多态"><a href="#11-多态" class="headerlink" title="11.多态"></a>11.多态</h3><p>a.多态指同一个对象，在不同时刻表现出来的不同形态</p><p>b.多态的前提和体现</p><ul><li>有继承&#x2F;实现关系</li><li>有方法重写</li><li>有父类引用指向子类对象</li></ul><p>c.多态中成员访问特点</p><ul><li>成员变量：编译时看**&#x3D;<strong>号左边（父类），运行时看</strong>&#x3D;**号左边（父类）</li><li>成员方法：编译时看**&#x3D;<strong>号左边（父类），运行时看</strong>&#x3D;**号右边边（子类）</li><li>成员变量和方法的访问不一样，理由是成员方法存在动态绑定机制，而成员变量没有</li></ul><p>d.多态的好处和弊端</p><ul><li>好处是提高了程序的扩展性</li><li>弊端是不能使用子类特有的功能</li></ul><p>e.向上转型</p><ul><li>父类引用指向子类对象</li><li>语法：<code>父类类型 引用名 = new 子类类型();  </code></li><li>可以调用父类的所有成员，需要遵循访问权限</li><li>不能调用子类<strong>特有</strong>的成员</li></ul><p>f.向下转型</p><ul><li>父类引用转为子类对象</li><li>语法：<code>子类类型 引用名 = (子类类型)父类引用;</code></li><li>只能强转父类的引用，不能强转父类的对象</li><li>父类的引用强转前必须指向的是子类类型的对象，否则出现<strong>ClassCastException</strong></li><li>可以调用子类中所有的成员</li></ul><p>g.instanceof关键字</p><ul><li>用于判断对象的<strong>运行类型</strong>是否为XX类或XX类的子类</li></ul><h3 id="12-内部类"><a href="#12-内部类" class="headerlink" title="12.内部类"></a>12.内部类</h3><p>a.内部类指在一个类中定义一个类</p><p>b.成员内部类</p><ul><li>位置：在类的成员位置</li><li>内部类可以直接访问外部类中的成员，包括私有</li><li>外部类要访问内部类的成员，必须创建对象</li><li>在外界创建内部类对象的语法是 <code>外部类名.内部类名 引用名 = new 外部类名().new 内部类名();</code></li><li>private修饰的成员内部类（私有成员内部类）<ol><li>不能在外界创建该内部类，因为private修饰</li><li>只能在自己所在的外部类中创建对象来访问</li></ol></li><li>static修饰的成员内部类（静态成员内部类）<ol><li>可以在外界创建</li><li>创建语法与普通的成员内部类不同 <code>外部类名.内部类名 引用名 = new 外部类名.内部类名();</code></li><li>静态成员内部类中的静态方法使用语法是 <code>外部类名.内部类名.方法名();</code></li></ol></li></ul><p>c.局部内部类</p><ul><li>局部内部类是在方法中定义的内部类，所以外界无法访问，需要在方法内部创建对象并使用</li><li>该类可以直接访问外部类的成员，也可以访问方法内的局部变量</li></ul><p>d.匿名内部类</p><ul><li><p>匿名内部类本质上是一个特殊的局部内部类</p></li><li><p>前提：需要存在一个接口&#x2F;类</p></li><li><p>语法是 <code>new 类名/接口名()&#123;重写方法&#125;;</code></p></li><li><p>匿名内部类是将（继承&#x2F;实现）（方法重写）（创建对象）三个步骤放在了一步进行</p></li><li><p>实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="comment">/*情况1,当接口中只有一个方法*/</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Inner1</span>()&#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;重写方法&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.show();<span class="comment">//可以通过这种方式直接调用方法</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*情况2,当接口中有多个方法*/</span></span><br><span class="line">        <span class="type">Inner2</span> <span class="variable">i</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Inner2</span>()&#123;<span class="comment">//这里实际上是多态</span></span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show1</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;重写方法1&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show2</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;重写方法2&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//存在多个方法,不能使用情况1中的方式调用多个方法</span></span><br><span class="line">         i.show1();</span><br><span class="line">         i.show2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Inner1</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Inner2</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">show1</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">show2</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用场景：当方法的形式参数是接口或者抽象类时可以将匿名内部类作为实际参数进行传参</p></li></ul><h3 id="13-Lambda表达式"><a href="#13-Lambda表达式" class="headerlink" title="13.Lambda表达式"></a>13.Lambda表达式</h3><ul><li>Lambda表达式是函数式编程思想的体现，函数式编程思想尽量忽略面向对象的复杂语法，强调“做什么”而不是以什么形式去做</li><li>Lambda表达式格式：<code>(形式参数) -&gt; &#123;代码&#125;</code><ol><li>如果有多个参数，参数之间用逗号隔开，如果没有参数则留空</li><li>-&gt;代表指向动作</li><li>代码指具体实现的内容</li></ol></li><li>Lambda表达式使用前提<ol><li>存在接口</li><li>接口中有且仅有一个抽象方法</li></ol></li><li>Lambda表达式分类<ol><li>无参无返回值</li><li>有参无返回值</li><li>无参有返回值</li><li>有参数有返回值</li></ol></li><li>Lambda表达式省略模式<ol><li>参数类型可以省略，如果有多个参数，要么不省略要么全部省略</li><li>如果参数有且仅有一个，那么参数的括号可以省略</li><li>如果代码块中只有一条语句，那么大括号和语句的分号可以省略，return关键字也可以省略</li></ol></li><li>Lambda表达式和匿名内部类的区别<ol><li>所需类型不同<ul><li>匿名内部类：可以是接口，可以是抽象类，还可以是具体的类</li><li>Lambda表达式：只能是接口</li></ul></li><li>使用限制不同<ul><li>如果接口中只有一个抽象方法，则可以使用Lambda表达式也可以使用匿名内部类</li><li>接口中有多于一个抽象方法，只能使用匿名内部类，不能使用Lambda表达式</li></ul></li><li>实现原理不同<ul><li>匿名内部类：编译之后，产生单独的.class字节码文件</li><li>Lambda表达式：编译之后，没有产生单独的.class字节码文件，对应的字节码会在运行的时候动态生成</li></ul></li></ol></li></ul><h2 id="常用API"><a href="#常用API" class="headerlink" title="常用API"></a>常用API</h2><h3 id="1-x3D-x3D-号比较注意事项"><a href="#1-x3D-x3D-号比较注意事项" class="headerlink" title="1.**&#x3D;&#x3D;**号比较注意事项"></a>1.**&#x3D;&#x3D;**号比较注意事项</h3><ul><li><strong>&#x3D;&#x3D;<strong>用于比较基本数据类型时，比较的是</strong>内容</strong></li><li><strong>&#x3D;&#x3D;<strong>用于比较引用类型时，比较的是</strong>地址</strong></li></ul><h3 id="2-String类"><a href="#2-String类" class="headerlink" title="2.String类"></a>2.String类</h3><ul><li><p>String类代表字符串，Java程序中所有字符串文字（例如“abc”）都被实现为此类的实例，也就是说，Java程序中所有的双引号字符串，都是String类的对象</p></li><li><p>字符串不可变，他们的值在创建后不能被更改</p></li><li><p>使用双引号创建字符串对象和使用new创建字符串对象的区别</p><ol><li>使用双引号创建字符串对象时，系统检查该字符串是否存在于字符串常量池中，如果不存在则创建，如果存在则复用</li><li>使用new来创建字符串对象，每一次new都会申请一个内存空间，虽然字符串内容相同，但是地址值不同</li><li>双引号创建的字符串对象在<strong>字符串常量池</strong>中存储，构造方法创建的字符串对象在<strong>堆内存</strong>中存储</li></ol></li><li><p>常见面试题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">        System.out.println(s1 == s2);<span class="comment">//比较地址，输出true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;abc&quot;</span>);<span class="comment">//使用构造方法创建字符串对象</span></span><br><span class="line">        System.out.println(s1 == s2);<span class="comment">//比较地址，输出false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> s2 + <span class="string">&quot;c&quot;</span>;</span><br><span class="line">        <span class="comment">/*这里系统自动创建StringBuilder对象，然后再调用append()方法完成拼接，最后调用toString()方法转换为String类型*/</span></span><br><span class="line">        System.out.println(s1 == s3);<span class="comment">//比较地址，由于创建新的对象，输出false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span> + <span class="string">&quot;c&quot;</span>;</span><br><span class="line">        <span class="comment">/*使用常量优化机制，当拼接的字符串均是双引号创建的字符串对象时，不会创建新的对象*/</span></span><br><span class="line">        System.out.println(s1 == s3);<span class="comment">//比较地址，没有创建新的对象，输出true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>字符串比较内容</p><ol><li>使用**equals()**方法来比较内容，严格区分大小写，返回true或者false</li><li>如果比较字符串时需要忽略大小写，则可以使用**equalsIgnoreCase()**方法</li></ol></li></ul><h3 id="3-StringBuilder类"><a href="#3-StringBuilder类" class="headerlink" title="3.StringBuilder类"></a>3.StringBuilder类</h3><ul><li>StringBuilder是一个可变的字符串类，可以将它看成一个容器</li><li>StringBuilder可以提高字符串操作效率，<strong>体现在字符串拼接上</strong></li><li>常用方法<ol><li>**append()**方法，完成字符串拼接，返回值是自己本身</li><li>**reverse()**方法，返回相反的字符串序列</li><li>**toString()**方法，把StringBuilder类型转为String类型</li></ol></li></ul><h3 id="4-Math类"><a href="#4-Math类" class="headerlink" title="4.Math类"></a>4.Math类</h3><ul><li>有关数学运算的类，构造方法被私有化所以不能被实例化，提供的方法全是静态方法</li><li>常用的方法<table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>public static int abs(int a)</td><td>返回参数的绝对值</td></tr><tr><td>public static double ceil(double a)</td><td>向上取整</td></tr><tr><td>public static double floor(double a)</td><td>向下取整</td></tr><tr><td>public static int round(float a)</td><td>四舍五入</td></tr><tr><td>public static int max(int a,int b)</td><td>返回两个参数值最大的</td></tr><tr><td>public static int min(int a,int b)</td><td>返回两个参数值最小的</td></tr><tr><td>public static double pow(double a,double b)</td><td>返回a的b次幂的值</td></tr><tr><td>public static double random()</td><td>返回值为double类型的正值，[0.0,1.0)</td></tr></tbody></table></li></ul><h3 id="5-System类"><a href="#5-System类" class="headerlink" title="5.System类"></a>5.System类</h3><ul><li>与系统相关的类，构造方法私有化所以不能被实例化，提供的方法都是静态方法</li><li>常用方法<table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>public static void exit(int status)</td><td>终止当前运行的Java虚拟机，参数非零表示异常终止</td></tr><tr><td>public static long currentTimeMillis()</td><td>返回当前距离1970年1月1日 00:00:00的毫秒值</td></tr><tr><td>public static arraycopy(源数组,起始索引,目的数组,起始索引,拷贝个数)</td><td>数组copy</td></tr></tbody></table></li></ul><h3 id="6-Object类"><a href="#6-Object类" class="headerlink" title="6.Object类"></a>6.Object类</h3><ul><li><p>所有类的超类，所有的对象（包括数组）都实现这个类中的方法</p></li><li><p>toString()方法</p><ol><li>直接打印一个对象就是打印这个对象的toString()方法的返回值</li><li>Object类的toString()方法得到的是这个对象的字符串表示 <code>全类名+@+哈希值的十六进制</code></li><li>一般情况下会对toString()方法进行重写，建议所有子类都重写该方法</li></ol></li><li><p>equals()方法</p><ol><li>与另一个对象比较</li><li>默认是比较地址</li><li>重写可以比较内容，例如String类和Integer类</li></ol></li><li><p>面试题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">        <span class="comment">//1.使用String中的equals()方法比较时会先判断参数是否是String类再判断内容，如果不是则直接返回false</span></span><br><span class="line">        System.out.println(s1.equals(sb));<span class="comment">//false</span></span><br><span class="line">        <span class="comment">//2.由于StringBuilder没有重写equals()方法，所以比较的是地址值</span></span><br><span class="line">        System.out.println(sb.equals(s1));<span class="comment">//false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="7-Objects类"><a href="#7-Objects类" class="headerlink" title="7.Objects类"></a>7.<strong>Objects</strong>类</h3><ul><li>构造方法被私有化所以不能实例化，提供的方法都是静态方法，注意与Object类的区别</li><li>常用方法<table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>public static String toString(Object o)</td><td>返回参数中对象的字符串表示形式</td></tr><tr><td>public static String toString(Object o,String nullDefault)</td><td>返回参数中对象的字符串表示形式，如果对象为空，返回第二个参数的默认字符串</td></tr><tr><td>public static boolean isNull(Object o)</td><td>判断对象是否为空</td></tr><tr><td>public static boolean nonNull(Object o)</td><td>判断对象是否为非空</td></tr></tbody></table></li></ul><h3 id="8-BigDecimal类"><a href="#8-BigDecimal类" class="headerlink" title="8.BigDecimal类"></a>8.BigDecimal类</h3><ul><li><p>常用两种构造方法</p><ol><li><code>BigDecimal bd1 = new BigDecimal(数值参数);</code></li><li><code>BigDecimal bd2 = new BigDecimal(字符串);</code></li></ol></li><li><p>四则运算（用于精确运算）</p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>public BigDecimal add(BigDecimal b)</td><td>加法</td></tr><tr><td>public BigDecimal subtract(BigDecimal b)</td><td>减法</td></tr><tr><td>public BigDecimal multiply(BigDecimal b)</td><td>乘法</td></tr><tr><td>public BigDecimal divide(BigDecimal b)</td><td>除法</td></tr></tbody></table></li><li><p>一种特殊的方法</p><ol><li>语法：<code>public BigDecimal divide(参数1，参数2，参数3);</code></li><li>用于除法中除不尽的情况</li><li>参数1表示另一个参与运算的数，参数2表示小数点后精确到的位数，参数3表示舍入模式</li><li>舍入模式有<ul><li><code>BigDecimal.ROUND_UP</code>，进一法</li><li><code>BigDecimal.ROUND_FLOOR</code>，去尾法</li><li><code>BigDecimal.ROUND_HALF_UP</code>，四舍五入</li></ul></li></ol></li><li><p>总结</p><ol><li>BigDecimal用于精确计算</li><li>创建BigDecimal对象，构造方法使用参数类型为字符串的</li><li>除法除不尽使用三个参数的方法</li></ol></li></ul><h3 id="9-包装类"><a href="#9-包装类" class="headerlink" title="9.包装类"></a>9.包装类</h3><ul><li><p>八个包装类</p><table><thead><tr><th>基本数据类型</th><th>包装类</th></tr></thead><tbody><tr><td>byte</td><td>Byte</td></tr><tr><td>short</td><td>Short</td></tr><tr><td>int</td><td>Integer</td></tr><tr><td>long</td><td>Long</td></tr><tr><td>float</td><td>Float</td></tr><tr><td>double</td><td>Double</td></tr><tr><td>char</td><td>Character</td></tr><tr><td>boolean</td><td>Boolean</td></tr></tbody></table></li><li><p>Integer类</p><ol><li><p>该对象中包装了一个基本数据类型为int的值</p></li><li><p>获取一个Integer对象的方法</p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>public Integer(int value)</td><td>根据int值创建Integer对象（过时）</td></tr><tr><td>public Integer(String s)</td><td>根据String值创建对象（过时）</td></tr><tr><td>public static Integer valueOf(int i)</td><td>返回表示指定int值的Integer对象</td></tr><tr><td>public static Integer valueOf(String s)</td><td>返回表示指定String值的Integer对象</td></tr></tbody></table></li><li><p>自动装箱和自动拆箱</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">100</span>;<span class="comment">//自动装箱，把基本数据类型转换为对应的包装类型</span></span><br><span class="line"><span class="type">int</span> <span class="variable">ii</span> <span class="operator">=</span> i;<span class="comment">//自动拆箱，把包装类型转换为对应的基本数据类型</span></span><br></pre></td></tr></table></figure></li><li><p>注意：在使用包装类型时如果有对应的操作，最好先判断是否为空</p></li><li><p>int转String的方法</p><ul><li><p>方式1：int值加空字符串，例如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> a + <span class="string">&quot;&quot;</span>;</span><br></pre></td></tr></table></figure></li><li><p>方式2：使用方法 <code>public static String valueOf(int i);</code>这是String类中的静态方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> String.valueOf(a);</span><br></pre></td></tr></table></figure></li></ul></li><li><p>String转int的方法</p><ul><li><p>使用方法 <code>public static int parseInt(String s);</code>这是Integer类中的静态方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;12&quot;</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> Integer.parseInt(s);</span><br></pre></td></tr></table></figure></li></ul></li></ol></li></ul><h3 id="10-Arrays类"><a href="#10-Arrays类" class="headerlink" title="10.Arrays类"></a>10.Arrays类</h3><ul><li>私有化构造方法所以不能实例化，提供的方法都是静态方法，用于数组的操作</li><li>常用方法<table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>public static String toString(数组)</td><td>返回数组的字符串形式</td></tr><tr><td>public static void sort(数组)</td><td>对给定的数组排序</td></tr><tr><td>public static int binarySearch(int[],int key)</td><td>二分查找，注意数组必须有序，找到返回索引，找不到返回（-插入点-1）</td></tr></tbody></table></li></ul><h3 id="11-时间日期类"><a href="#11-时间日期类" class="headerlink" title="11.时间日期类"></a>11.时间日期类</h3><ul><li><p>计算机中的时间原点是1970年1月1日 00:00:00</p></li><li><p>Date类</p><ul><li>表示一个特定的时间</li><li>构造方法<table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>public Date()</td><td>创建一个Date对象，表示默认事件（计算机当前时间）</td></tr><tr><td>public Date(long date)</td><td>创建一个Date对象，表示指定时间（从时间原点开始，过了指定毫秒的时间，需要考虑时差问题）</td></tr></tbody></table></li><li>常用方法<table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>public long getTime()</td><td>获取时间对象的毫秒值</td></tr><tr><td>public void setTime(long time)</td><td>设置时间为参数内指定的时间</td></tr></tbody></table></li></ul></li><li><p>SimpleDateFormat类</p><ul><li><p>可以对Date对象进行<strong>格式化和解析</strong></p></li><li><p>常用模式字母以及对应关系</p><table><thead><tr><th>字母</th><th>含义</th></tr></thead><tbody><tr><td>y</td><td>年</td></tr><tr><td>M</td><td>月</td></tr><tr><td>d</td><td>日</td></tr><tr><td>H</td><td>时</td></tr><tr><td>m</td><td>分</td></tr><tr><td>s</td><td>秒</td></tr></tbody></table><p>巧记为“小大，小大，小小”</p></li><li><p>构造方法</p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>public SimpleDateFormat()</td><td>构造一个默认格式的对象</td></tr><tr><td>public SimpleDateFormat(String pattern)</td><td>构造一个指定格式的对象</td></tr></tbody></table></li><li><p>格式化和解析的方法</p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>public final String format(Date date)</td><td>将日期格式化为指定格式的字符串</td></tr><tr><td>public Date parse(String source)</td><td>将字符串解析为日期类对象</td></tr></tbody></table></li></ul></li><li><p>JDK8新增的时间日期类</p><ul><li><p>LocalDate日期类、LocalTime时间类、<strong>LocalDateTime时间日期类</strong>，使用方法类似</p></li><li><p>LocalDateTime创建方法</p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>public static LocalDateTime now()</td><td>获取当前计算机的时间</td></tr><tr><td>public static LocalDateTime of(年,月,日,时,分,秒)</td><td>使用指定的年月日时分秒创建一个对象</td></tr></tbody></table></li><li><p>LocalDateTime常用方法</p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>public int getYear()</td><td>获取年</td></tr><tr><td>public int getMonthValue()</td><td>获取月份（1-12）</td></tr><tr><td>public int getDayOfMonth()</td><td>获取月份中第几天（1-31）</td></tr><tr><td>public Month getMonth()</td><td>获取月份，返回值类型是枚举类</td></tr><tr><td>public int getDayOfYear()</td><td>获取一年中第几天（1-366）</td></tr><tr><td>public DayOfWeek getDayOfWeek()</td><td>获取星期，返回值类型是枚举类</td></tr><tr><td>public int getMinute()</td><td>获取分钟</td></tr><tr><td>public int getHour()</td><td>获取小时</td></tr></tbody></table></li><li><p>LocalDateTime对象转为LocalDate对象或者LocalTime对象的方法</p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>public LocalDate toLocalDate()</td><td>转换成一个LocalDate对象</td></tr><tr><td>public LocalTime toLocalTime()</td><td>转换成一个LocalTime对象</td></tr></tbody></table></li><li><p>LocalDateTime的格式化和解析</p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>public String format(指定格式)</td><td>将LocalDateTime对象格式化为指定的字符串</td></tr><tr><td>public static LocalDateTime parse(待解析的字符串,解析格式)</td><td>将时间日期字符串解析为LocalDateTime对象</td></tr></tbody></table><p>JDK8中使用<strong>DateTimeFormatter</strong>类作为时间日期格式化器，使用的方法如下：</p><p><code>public static DateTimeFormatter ofPattern(String pattern)</code>，作用是获取一个指定格式的DateTimeFormatter对象</p></li><li><p>LocalDateTime中plus系列的方法</p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>public LocalDateTime plusYears(long years)</td><td>添加或者减去年，返回新的LocalDateTime对象</td></tr><tr><td>public LocalDateTime plusMonths(long months)</td><td>添加或者减去月，返回新的LocalDateTime对象</td></tr><tr><td>public LocalDateTime plusDays(long days)</td><td>添加或者减去日，返回新的LocalDateTime对象</td></tr><tr><td>public LocalDateTime plusHours(long hours)</td><td>添加或者减去时，返回新的LocalDateTime对象</td></tr><tr><td>public LocalDateTime plusMinutes(long minutes)</td><td>添加或者减去分，返回新的LocalDateTime对象</td></tr><tr><td>public LocalDateTime plusSeconds(long seconds)</td><td>添加或者减去秒，返回新的LocalDateTime对象</td></tr><tr><td>public LocalDateTime plusWeeks(long weeks)</td><td>添加或者减去周，返回新的LocalDateTime对象</td></tr></tbody></table><p>注意：参数为正表示添加，参数为负表示减去</p></li><li><p>LocalDateTime中minus系列的方法</p><ol><li>该系列方法与plus系列方法相反，作用是减去对应的年月日时分秒周</li><li>参数为正数表示减去的值，负数表示加上的值</li><li>例如 <code>public LocalDateTime minusYears(long years)</code>是minus系列方法之一，其他方法类似</li></ol></li><li><p>LocalDateTime中with系列方法</p><p>with系列方法用于直接修改LocalDateTime对象中的年月日时分秒</p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>public LocalDateTime withYear(int year)</td><td>直接修改年，返回新的LocalDateTime对象</td></tr><tr><td>public LocalDateTime withMonth(int month)</td><td>直接修改月，返回新的LocalDateTime对象</td></tr><tr><td>public LocalDateTime withDayOfMonth(int dayofmonth)</td><td>直接修改一月中第几天，返回新的LocalDateTime对象</td></tr><tr><td>public LocalDateTime withDayOfYear(int dayofyear)</td><td>直接修改一年中第几天，返回新的LocalDateTime对象</td></tr><tr><td>public LocalDateTime withHour(int hour)</td><td>直接修改小时，返回新的LocalDateTime对象</td></tr><tr><td>public LocalDateTime withMinute(int minute)</td><td>直接修改分钟，返回新的LocalDateTime对象</td></tr><tr><td>public LocalDateTime withSecond(int second)</td><td>直接修改秒，返回新的LocalDateTime对象</td></tr></tbody></table></li><li><p>Period日期间隔类</p><p>常用方法</p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>public static Period between(LocalDate start,LocalDate end)</td><td>返回两个日期的Period间隔类</td></tr><tr><td>public int getYears()</td><td>返回间隔的年数</td></tr><tr><td>public int getMonths()</td><td>返回间隔的月数</td></tr><tr><td>public int getDays()</td><td>返回间隔的天数</td></tr><tr><td>public long toTotalMonths()</td><td>返回间隔的总月数</td></tr></tbody></table></li><li><p>Duration时间间隔类</p><p>可以获取时间的间隔</p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>public static Duration between(开始时间,结束时间)</td><td>计算两个时间的间隔，返回Duration对象</td></tr><tr><td>public long toSeconds()</td><td>获取时间间隔的秒</td></tr><tr><td>public long toMillis()</td><td>获取时间间隔的毫秒</td></tr><tr><td>public long toNanos()</td><td>获取时间间隔的纳秒</td></tr></tbody></table></li></ul></li></ul><h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><h3 id="1-概念"><a href="#1-概念" class="headerlink" title="1.概念"></a>1.概念</h3><ul><li>Exception类称为异常类，它的子类有RuntimeException（运行时异常）和其他子类（编译时异常）</li><li>RuntimeException也有许多子类</li><li>编译时异常是在编译成class文件时必须要处理的异常，也称为受检异常</li><li>运行时异常是在运行字节码文件时出现的异常，也称为非受检异常</li></ul><h3 id="2-虚拟机默认处理异常的方式"><a href="#2-虚拟机默认处理异常的方式" class="headerlink" title="2.虚拟机默认处理异常的方式"></a>2.虚拟机默认处理异常的方式</h3><ul><li>在产生异常的代码处生成一个<strong>异常对象</strong>，接着查看是否有处理异常的代码，如果没有就交给调用者处理，如果调用者也不处理则最终交给虚拟机</li><li>虚拟机将异常的名称，异常原因以及异常出现的位置等信息输出在控制台</li><li>程序停止运行</li></ul><h3 id="3-使用throws方式处理异常"><a href="#3-使用throws方式处理异常" class="headerlink" title="3.使用throws方式处理异常"></a>3.使用throws方式处理异常</h3><ul><li>格式：<code>throws 异常类名</code></li><li>注意：写在<strong>方法的定义处</strong>，表示显式声明一个异常</li><li>这种异常异常处理方式主要<strong>用于编译时异常</strong>，如果声明的异常是运行时异常则声明处的代码可以省略</li><li>throws声明一个异常表示当前方法内不处理这个异常，而是交给<strong>调用者</strong>处理，如果调用者也不处理则<strong>最终</strong>交给虚拟机采用<strong>默认</strong>的处理方式</li></ul><h3 id="4-使用throw抛出异常对象"><a href="#4-使用throw抛出异常对象" class="headerlink" title="4.使用throw抛出异常对象"></a>4.使用throw抛出异常对象</h3><ul><li>格式：<code>throw new 异常类名();</code></li><li>注意：写在<strong>方法内部</strong>，表示在当前的代码处手动抛出一个异常，下面的代码不用再执行</li><li>给方法的调用者抛出了一个异常</li></ul><h3 id="5-使用try-catch方式处理异常"><a href="#5-使用try-catch方式处理异常" class="headerlink" title="5.使用try..catch方式处理异常"></a>5.使用try..catch方式处理异常</h3><ul><li><p>格式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">//可能出现异常的代码</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类名 变量名)&#123;</span><br><span class="line">    <span class="comment">//处理异常的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>作用是可以让程序继续执行下去</p></li><li><p>如果try块中没有出现异常，则程序会将try块的代码执行完毕，然后跳过catch块的代码继续执行下去</p></li><li><p>如果try块中某行代码出现异常，则该行后面的代码不再执行转而去执行catch块中的代码，然后继续执行下去</p></li><li><p>如果try块中出现的异常没有被捕获，则直接在出现异常的代码处停止执行，将异常交给虚拟机处理，程序不再执行下去</p></li><li><p>如果try块中出现多个异常，那么只需要添加多个catch块处理，如果多个异常存在继承关系，那么父类catch块需要写在<strong>最下方</strong>，发生异常时只会匹配一个catch块</p></li><li><p>写多个catch块的好处是可以针对不同的异常有不同的处理方式</p></li></ul><h3 id="6-Throwable的成员方法"><a href="#6-Throwable的成员方法" class="headerlink" title="6.Throwable的成员方法"></a>6.Throwable的成员方法</h3><ul><li>Throwable是所有异常类的父类，所以所有异常对象都能使用该类的方法</li><li>常用方法<table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>public String getMessage()</td><td>返回详细消息字符串</td></tr><tr><td>public String toString()</td><td>返回简短描述字符串</td></tr><tr><td>public void printStackTrace()</td><td>将异常信息打印输出在控制台</td></tr></tbody></table></li></ul><h3 id="7-自定义异常"><a href="#7-自定义异常" class="headerlink" title="7.自定义异常"></a>7.自定义异常</h3><ul><li><p>自定义异常的目的：为了使异常信息更加的见名知义</p></li><li><p>自定义异常类的步骤</p><ol><li><p>定义类名，建议为xxExtception</p></li><li><p>继承<strong>Exception</strong>类或者<strong>RuntimeException</strong>类</p></li><li><p>写一个空参构造方法</p></li><li><p>写一个带参构造方法，例如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">XXException</span><span class="params">(String message)</span>&#123;</span><br><span class="line">    <span class="built_in">super</span>(message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li></ul><h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><h3 id="1-集合简易体系结构"><a href="#1-集合简易体系结构" class="headerlink" title="1.集合简易体系结构"></a>1.集合简易体系结构</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">graph TB;</span><br><span class="line">集合--&gt;Collection</span><br><span class="line">集合--&gt;Map</span><br><span class="line">Collection--&gt;List</span><br><span class="line">Collection--&gt;Set</span><br><span class="line">Map--&gt;HashMap</span><br><span class="line">Map--&gt;TreeMap</span><br><span class="line">List--&gt;ArrayList</span><br><span class="line">List--&gt;LinkedList</span><br><span class="line">Set--&gt;HashSet</span><br><span class="line">Set--&gt;TreeSet</span><br></pre></td></tr></table></figure><ul><li>上图中<strong>Collection、Map、List、Set</strong>都是接口，其余都是实现类</li><li>其中Collection及其实现类存放的是<strong>单列数据</strong>，Map及其实现类存放的是<strong>双列数据</strong></li><li>该体系结构只列出较常使用的类</li></ul><h3 id="2-Collection"><a href="#2-Collection" class="headerlink" title="2.Collection"></a>2.Collection</h3><ul><li><p>Collection是单列集合的顶层接口，表示一组对象，这些对象也称为Collection元素</p></li><li><p>JDK不提供此接口的<strong>任何直接实现类</strong>，而是提供更具体的<strong>子接口</strong>如List和Set</p></li><li><p>由于是接口，所以创建Collection对象需要使用<strong>多态</strong>的方式</p></li><li><p>Collection常用方法</p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>boolean add(E e)</td><td>添加元素</td></tr><tr><td>boolean remove(Object o)</td><td>从集合中移除指定的元素</td></tr><tr><td>boolean removeif(Object o)</td><td>根据条件进行删除</td></tr><tr><td>void clear()</td><td>清空集合</td></tr><tr><td>boolean contains(Object o)</td><td>判断集合中是否存在指定的元素</td></tr><tr><td>boolean isEmpty()</td><td>判断集合是否为空</td></tr><tr><td>int size()</td><td>集合的长度（元素个数）</td></tr></tbody></table></li><li><p>迭代器</p><ol><li><p>迭代器<strong>Iterator</strong>，用于集合的遍历方式</p></li><li><p><code>Iterator&lt;E&gt; iterator();</code>是<strong>Iterable</strong>接口提供的一个抽象方法，用于返回一个迭代器对象，而Collection接口继承了该接口，所以实现<strong>Collection</strong>接口的实现类中根据每个实现类存放数据的方式不同重写各自的Iterator()方法，从而获得不同的迭代器对象</p></li><li><p>Iterator中的常用方法</p><ul><li><code>boolean hasNext();</code>用于判断集合中当前位置是否有元素可以被取出</li><li><code>E next();</code>获取当前位置的元素，并将迭代器对象移向下一个位置</li><li><code>void remove();</code>删除上一次调用next()方法时返回的元素，每次调用next()方法只能调用一次此方法</li></ul></li><li><p>迭代器使用案例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;String&gt; it = collection.iterator();<span class="comment">//获取集合中的迭代器对象</span></span><br><span class="line"><span class="keyword">while</span>(it.hasNext())&#123;<span class="comment">//当前索引位置是否存在元素</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> it.next();<span class="comment">//将索引位置处的元素获取出来，并且将索引移动到下一位置</span></span><br><span class="line">    System.out.println(s);<span class="comment">//打印输出</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> it.next();</span><br><span class="line">    <span class="keyword">if</span>(<span class="string">&quot;abc&quot;</span>.equals(s))&#123;</span><br><span class="line">        it.remove();<span class="comment">//将迭代器返回的最后一个元素删除</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>增强for循环</p><ul><li><p>作用是简化数组和Collection集合的遍历</p></li><li><p>内部原理依然是Iterator迭代器</p></li><li><p>实现<strong>Iterable</strong>接口的类才可以使用<strong>增强for循环和Iterator迭代器</strong></p></li><li><p>注意避免在增强for循环中对数组或集合元素删除或更改</p></li><li><p>三种循环的使用场景</p><p>需要操作索引使用普通for循环</p><p>需要遍历过程中删除元素，使用迭代器</p><p>仅仅遍历元素使用增强for循环</p></li></ul></li></ol></li></ul><h3 id="3-List"><a href="#3-List" class="headerlink" title="3.List"></a>3.List</h3><ul><li><p>存取有序，存元素的顺序和取元素顺序一致，类似数组</p></li><li><p>可以根据索引精确操作元素</p></li><li><p>与Set集合不同，允许存放重复的元素</p></li><li><p>List中特有的方法</p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>void add(int index,E element)</td><td>在指定位置插入元素</td></tr><tr><td>E remove(int index)</td><td>删除指定位置的元素并返回</td></tr><tr><td>E set(int index,E element)</td><td>修改指定位置的元素并返回<strong>被修改</strong>的元素</td></tr><tr><td>E get(int index)</td><td>返回指定索引处的元素</td></tr></tbody></table></li><li><p>List的实现类ArrayList</p><ul><li>底层数据结构是<strong>数组</strong>，查询快，增删慢</li><li>实现自动扩容的机制</li><li>每次扩容的容量是之前的1.5倍</li></ul></li><li><p>List的实现类LinkedList</p><ul><li>底层数据结构是<strong>双向链表</strong>，查询慢，增删快</li><li>LinkedList特有方法<table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>public void addFirst()</td><td>在开头插入元素</td></tr><tr><td>public void addLast()</td><td>在末尾插入元素</td></tr><tr><td>public E getFirst()</td><td>获取第一个元素</td></tr><tr><td>public E getLast()</td><td>获取最后一个元素</td></tr><tr><td>public E removeFirst()</td><td>删除并返回第一个元素</td></tr><tr><td>public E removeLast()</td><td>删除并返回最后一个元素</td></tr></tbody></table></li></ul></li></ul><h3 id="4-Set"><a href="#4-Set" class="headerlink" title="4.Set"></a>4.Set</h3><ul><li><p>Set集合可以<strong>去除重复的元素</strong>，而且<strong>不保证元素存取顺序</strong></p></li><li><p>Set集合没有带索引的方法，所以不能使用普通for循环遍历，也不能通过索引来获取、删除元素</p></li><li><p>Set集合可以通过迭代器或者增强for循环遍历</p></li><li><p>Set的实现类TreeSet</p><ul><li><p>底层数据结构是<strong>红黑树</strong></p></li><li><p>特点是可以将元素<strong>按照规则</strong>进行排序，如果想要使用TreeSet需要制定<strong>排序</strong>规则</p></li><li><p>自然排序</p><ul><li><p>使用空参构造器创建TreeSet集合时，会默认调用自然排序</p></li><li><p>存放在TreeSet集合的类需要实现<strong>Comparable接口</strong>然后重写里面的<strong>compareTo()方法</strong>，一般用在自定义的类中，比如定义一个学生类，按照学生的年龄排序</p></li><li><p>例如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;Student&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Student o)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="built_in">this</span>.age-o.age;<span class="comment">//this表示当前需要存入的元素，o表示集合中存在的元素</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul><p>}</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">```java</span><br><span class="line">class Student implements Comparable&lt;Student&gt; &#123;</span><br><span class="line"></span><br><span class="line">    private String name;</span><br><span class="line">    private int age;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int compareTo(Student o) &#123;</span><br><span class="line">        int result = this.age-o.age;</span><br><span class="line">        result = result == 0 ? this.name.compareTo(o.name) : result;//如果年龄出现相同的情况可以比较姓名，按照字母字典排序，注意这里使用到了String类的CompareTo()方法</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>比较器排序</p><ul><li><p>TreeSet的<strong>带参构造方法</strong>使用的是比较器排序对元素进行排序</p></li><li><p>比较器排序就是在TreeSet的带参构造方法中传入一个<strong>Comparator接口</strong>的实现类对象，重写<strong>Compare(T o1,T o2)方法</strong></p></li><li><p>例如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ParseException &#123;</span><br><span class="line">        TreeSet&lt;Student&gt; students = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Student&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Student o1, Student o2)</span> &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> o1.getAge()-o2.getAge();<span class="comment">//比较年龄</span></span><br><span class="line">                result = result == <span class="number">0</span> ? o1.getName().compareTo(o2.getName()) : result;<span class="comment">//年龄相同时比较姓名</span></span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="type">Student</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;zhansan&quot;</span>,<span class="number">18</span>);</span><br><span class="line">        <span class="type">Student</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;wangwu&quot;</span>,<span class="number">18</span>);</span><br><span class="line">        <span class="type">Student</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;lisi&quot;</span>,<span class="number">22</span>);</span><br><span class="line">        <span class="type">Student</span> <span class="variable">s4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;wuliu&quot;</span>,<span class="number">16</span>);</span><br><span class="line"></span><br><span class="line">        students.add(s1);</span><br><span class="line">        students.add(s2);</span><br><span class="line">        students.add(s3);</span><br><span class="line">        students.add(s4);</span><br><span class="line"></span><br><span class="line">        System.out.println(students);</span><br><span class="line">        <span class="comment">//输出:[&#123;wuliu,16&#125;, &#123;wangwu,18&#125;, &#123;zhansan,18&#125;, &#123;lisi,22&#125;]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;Student&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&#123;&quot;</span>+</span><br><span class="line">                <span class="built_in">this</span>.getName()+</span><br><span class="line">                <span class="string">&quot;,&quot;</span>+</span><br><span class="line">                <span class="built_in">this</span>.getAge()+</span><br><span class="line">                <span class="string">&quot;&#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul><p>}</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>两种比较方式总结</p><ul><li>自然排序：自定义类实现Comparable接口，重写compareTo()方法，根据返回值进行排序</li><li>比较器排序：创建TreeSet对象的时候传递Comparator的实现类对象，重写compare()方法，根据返回值排序</li><li>使用的时候，默认使用自然排序（<strong>当TreeSet集合中存的元素对象已经实现了Comparable接口并且重写compareTo()方法</strong>），当自然排序不满足需求时（<strong>当TreeSet集合中存的元素对象是自定义的类并且没有实现Comparable接口</strong>）必须使用比较器排序，还有一种情况是自定义的类已经实现了Comparable接口并且重写了compareTo()方法，那么也可以通过比较器排序来改变排序规则</li><li>两种方式中，关于compareTo()方法和compare()方法的返回值有如下规则<ol><li>如果返回值是负数，表示当前存入的元素是较小值，存左边</li><li>如果返回值是0，表示当前存入的元素跟集合中的元素重复了，不存</li><li>如果返回值是正数，表示当前存入的元素是较大值，存右边</li></ol></li></ul></li></ul></li><li><p>Set的实现类HashSet</p><ul><li>底层数据结构是<strong>哈希表</strong></li><li>不保证数据的存取顺序一致</li><li>没有带索引的方法所以不能使用普通的for循环遍历</li><li>由于是Set集合，所以元素唯一</li><li>哈希值<ul><li>哈希值是JDK根据对象的地址或者属性值，算出来的int类型的整数</li><li>Object类中有一个 <code>public int hasCode()</code>方法可以根据对象的地址值计算并返回哈希值，同一个对象多次调用这个方法返回的哈希值是一样的</li><li>如果没有重写HashCode()方法，那么默认哈希值是根据对象的<strong>地址</strong>计算得出，不同的对象哈希值不同</li><li>如果重写了HashCode()方法，则哈希值是根据对象的<strong>属性</strong>计算得出，如果有不同的对象属性值一样那么哈希值相同</li></ul></li><li>JDK7版本中HashSet底层原理<ul><li>底层结构：哈希表（数组加链表）</li><li>数组默认长度为16，加载因子为0.75，当数组存储了16*0.75&#x3D;12个位置时则扩容为原来容量的两倍</li><li>存入元素时，首先获取元素的<strong>哈希值</strong>，计算出在数组中应该存放的索引，接着判断该索引处是否为null，如果是null直接添加，如果不是null则与该索引处的链表中每一个元素通过**equals()**方法比较属性值，只要存在一个相同的就不存，否则存入该链表</li></ul></li><li>JDK8版本中HashSet底层原理<ul><li>底层结构：哈希表（数组加链表加红黑树）</li><li>当链表长度超过8时将链表转为红黑树，目的是提高效率</li><li>存储流程与之前相同，只是当存入的是红黑树时不需要比较完全部元素</li></ul></li><li>结论：如果HashSet要存储自定义的类，那么需要重写HashCode()方法和equals()方法</li></ul></li></ul><h3 id="5-Map"><a href="#5-Map" class="headerlink" title="5.Map"></a>5.Map</h3><ul><li><p><code>interface Map&lt;K,V&gt;</code>是双列集合的顶层接口，K表示键的数据类型，V表示值的数据类型</p></li><li><p>键不能重复，值允许重复，键值是对应的，一个键只能对应一个值</p></li><li><p>（键+值）这个整体称为“键值对”或者“键值对对象”，在Java中叫做“Entry对象”</p></li><li><p>由于Map是接口，所以创建Map对象可以通过多态的方式</p></li><li><p>Map常用方法</p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>V put(K k,V v)</td><td>添加元素</td></tr><tr><td>V remove(K k)</td><td>根据键删除键值对元素，并且将被删除的键值对中的值返回</td></tr><tr><td>void clear()</td><td>清空所有的键值对</td></tr><tr><td>boolean containsKey(K k)</td><td>判断集合是否包含指定的键</td></tr><tr><td>boolean containsValue(V v)</td><td>判断集合是否包含指定的值</td></tr><tr><td>boolean isEmpty()</td><td>判断集合是否为空</td></tr><tr><td>int size()</td><td>返回集合的长度（键值对个数）</td></tr><tr><td>Set<code>&lt;K&gt;</code> keySet()</td><td>获取所有键的集合</td></tr><tr><td>V get(K k)</td><td>根据键获取值</td></tr><tr><td>Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()</td><td>获取所有键值对对象的集合</td></tr></tbody></table><ul><li>put()方法注意事项：如果添加的键值对中的键在集合中<strong>不存在</strong>，则直接添加进去，返回的是null；如果添加的键值对中的键在集合中<strong>已经存在</strong>，那么会<strong>替换</strong>掉键值对中原来的<strong>值</strong>，并且将被替换的值返回</li></ul></li><li><p>Map遍历方式1</p><ul><li><p>由**keySet()<strong>方法获取所有的键，然后遍历键，在遍历键的同时通过</strong>get()**方法实现键值对的遍历</p></li><li><p>例如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;String&gt; set = map.keySet();</span><br><span class="line"><span class="keyword">for</span>(String key:set)&#123;</span><br><span class="line">    map.get(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>Map遍历方式2</p><ul><li><p>由**entrySet()<strong>方法获得键值对对象的集合，</strong>Map.Entry&lt;K,V&gt;**接口中有两个方法 <code>K getKey()</code>和 <code>V getValue()</code>分别可以获取键值对的键和值</p></li><li><p>例如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;Map.Entry&lt;String, String&gt;&gt; entries = map.entrySet();</span><br><span class="line"><span class="keyword">for</span>(Map.Entry&lt;String,String&gt; entry:entries)&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">k</span> <span class="operator">=</span> entry.getKey();</span><br><span class="line">    <span class="type">String</span> <span class="variable">v</span> <span class="operator">=</span> entry.getValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>Map的实现类HashMap</p><ul><li>HashMap底层是哈希表</li><li>存放的方式与HashSet类似，但是需要将键值对封装成Entry对象再进行存放</li><li>依赖HashCode()方法和equals()方法保证<strong>键</strong>的唯一，由<strong>键</strong>的哈希值决定存放位置，由<strong>键</strong>的equals()方法判断元素是否重复</li><li>如果键的类型是<strong>自定义的类</strong>，那么需要重写HashCode()方法和equals()方法</li></ul></li><li><p>Map的实现类TreeMap</p><ul><li>TreeMap底层是红黑树</li><li>依赖自然排序或比较器排序，对<strong>键</strong>进行排序</li><li>如果键是<strong>自定义类型</strong>的对象，则该类需要实现Comparable接口或者在创建TreeMap对象时候给出比较器排序规则</li></ul></li></ul><h3 id="6-可变参数"><a href="#6-可变参数" class="headerlink" title="6.可变参数"></a>6.可变参数</h3><ul><li><p>可变参数是指形参个数可以改变</p></li><li><p>格式：<code>修饰符 返回值类型 方法名(数据类型...变量名)&#123;&#125;</code></p></li><li><p>范例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">func</span><span class="params">(<span class="type">int</span>...arr)</span>&#123;&#125;</span><br></pre></td></tr></table></figure></li><li><p>可变参数其实是一个数组</p></li><li><p>如果方法参数还含有其他参数，<strong>可变参数需要放在最后边</strong></p></li></ul><h3 id="7-创建不可变集合"><a href="#7-创建不可变集合" class="headerlink" title="7.创建不可变集合"></a>7.创建不可变集合</h3><ul><li><p>在<strong>List、Set、Map</strong>接口中，存在静态方法**of(可变参数)**，可以创建一个不可变集合</p></li><li><p>这个不可变集合不能添加、删除、修改</p></li><li><p>可以结合集合的带参构造，实现集合的批量添加</p></li><li><p>Map接口中还有一个**ofEntries(可变参数)**方法可以提高代码阅读性，作用和Map.of()相同，但是ofEntries()中的可变参数会先封装成一个Entry对象</p></li><li><p>范例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = List.of(<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;c&quot;</span>);<span class="comment">//利用可变参数创建不可变集合</span></span><br><span class="line">ArrayList&lt;String&gt; list1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(list);<span class="comment">//利用不可变集合创建集合</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="8-Stream流"><a href="#8-Stream流" class="headerlink" title="8.Stream流"></a>8.Stream流</h3><ul><li><p>Stream流中的三类方法</p><ol><li>获取Stream流的方法：创建一条类似于流水线的流，并且将数据放上流中准备进行处理</li><li>中间方法：流水线上的操作，一次操作结束后还能继续进行其他操作</li><li>终结方法：一个Stream流只能有一个终结方法，是流水线上最后的一个操作</li></ol></li><li><p>获取Stream流的方法</p><ol><li><p>单列集合：可以使用<strong>Collection</strong>接口的默认方法stream()生成流</p><p><code>default Stream&lt;E&gt; stream()</code></p></li><li><p>双列集合：间接生成流，可以先通过keySet或entrySet获取一个Set集合，再获取Stream流</p></li><li><p>数组：Arrays中的静态方法stream()生成</p></li><li><p>同种类型的多个数据：使用Stream.of(T…value)方法获取，其中参数是<strong>可变参数</strong></p></li></ol></li><li><p>常用中间方法</p><ol><li><code>Stream&lt;T&gt; filter(Predicate&lt;? super T&gt; predicate)</code>，用于按照某规则过滤流中的数据，其中Predicate接口含有抽象方法test(T t)，形参是流中的数据，重写该方法时可以指定过滤规则，当返回值是true时保留数据，当false时过滤掉数据，由于Predicate是只含有一个抽象方法的接口，所以可以使用Lambda表达式，也可以使用匿名内部类</li><li><code>Stream&lt;T&gt; limit(long maxsize)</code>，将流中前maxsize个数据截取出来</li><li><code>Stream&lt;T&gt; skip(long n)</code>，跳过n个数据</li><li><code>static Stream&lt;T&gt; concat(Stream a,Stream b)</code>，Stream中的静态方法，用于合并两个流</li><li><code>Stream&lt;T&gt; distinct()</code>，去除流中重复的数据，依赖hashCode()方法和equals()方法</li></ol></li><li><p>常用终结方法</p><ol><li><code>void forEach(Consumer&lt;? super T&gt; consumer)</code>，用于遍历流中的数据，其中Consumer接口含有一个抽象方法accpet(T t)，该方法的形参就是流中的数据，所以可以在重写该方法时设计对流中数据的操作，比如打印输出，由于该接口只有一个抽象方法所以可以使用Lambda表达式</li><li><code>long count()</code>，返回流中的元素个数</li></ol></li><li><p>Stream流无法修改集合或者数组等数据源中的数据</p></li><li><p>Stream流中的收集操作</p><ol><li><code>R collect(Collector collector)</code>，用于将流中的数据收集一个集合中并返回这个集合，集合的类型由Collector决定，R表示集合类型</li><li><strong>Collectors</strong>工具类<ul><li>该类可以由静态方法<strong>获取collector对象</strong></li><li><code>public static &lt;T&gt; Collector toList()</code>，收集到List集合中</li><li><code>public static &lt;T&gt; Collector toSet()</code>，收集到Set集合中</li><li><code>public static &lt;T&gt; Collector toMap(Function keyMapper,Function valueMapper)</code>，收集到Map集合中，注意toMap()方法中的两个参数，可以理解为获取键和值的方式，可以使用Lambda表达式</li></ul></li></ol></li></ul><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h3><ul><li>泛型提供编译时类型安全检测机制</li><li>好处是把运行时的可能出现的错误提前到编译期间</li><li>泛型分类：<strong>泛型类</strong>、<strong>泛型方法</strong>、<strong>泛型接口</strong></li></ul><h3 id="2-自定义泛型类"><a href="#2-自定义泛型类" class="headerlink" title="2.自定义泛型类"></a>2.自定义泛型类</h3><ul><li>格式 <code>修饰符 class 类名&lt;标识&gt;&#123;&#125;</code></li><li>范例 <code>public class Generic&lt;T&gt;</code></li><li>上述T是标识，其他的还有如T、E、K、V等标识</li></ul><h3 id="3-自定义泛型方法"><a href="#3-自定义泛型方法" class="headerlink" title="3.自定义泛型方法"></a>3.自定义泛型方法</h3><ul><li>格式 <code>修饰符 &lt;标识&gt; 返回值类型 方法名(类型 变量)&#123;&#125;</code></li><li>范例 <code>public &lt;T&gt; void show(T t)&#123;&#125;</code></li></ul><h3 id="4-自定义泛型接口"><a href="#4-自定义泛型接口" class="headerlink" title="4.自定义泛型接口"></a>4.自定义泛型接口</h3><ul><li>格式 <code>修饰符 interface 接口名&lt;标识&gt;&#123;&#125;</code></li><li>范例 <code>public interface Generic&lt;T&gt;&#123;&#125;</code></li><li>与泛型类相似</li><li>泛型接口有两种使用方式，一种是在实现类给出确定的T，一种是写成泛型类（即不给出具体的T）</li></ul><h3 id="5-类型通配符"><a href="#5-类型通配符" class="headerlink" title="5.类型通配符"></a>5.类型通配符</h3><ul><li>类型通配符为：**&lt;?&gt;**</li><li>例如ArrayList：表示元素类型未知的ArrayList，它的元素可以匹配任何类型</li><li>通配符上限：<code>&lt;? extends 某个类型&gt;</code>表示匹配的类型应该是某个类型或者某个类型的<strong>子类</strong></li><li>通配符下限：<code>&lt;? super 某个类型&gt;</code>表示匹配的类型应该是某个类型或者某个类型的<strong>父类</strong></li></ul><h2 id="文件和IO流"><a href="#文件和IO流" class="headerlink" title="文件和IO流"></a>文件和IO流</h2><h3 id="1-File类"><a href="#1-File类" class="headerlink" title="1.File类"></a>1.File类</h3><ul><li><p>文件和目录可以通过File封装成对象</p></li><li><p>Flie封装的仅仅是一个路径名，可以是存在的也可以是不存在的</p></li><li><p>构造方法</p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>File(String pathname)</td><td>通过路径名字符串创建一个File对象</td></tr><tr><td>File(String parent,String child)</td><td>通过父路径和子路径拼接创建一个File对象</td></tr><tr><td>File(File parent,String child)</td><td>通过父路径File对象和子路径拼接创建一个File对象</td></tr></tbody></table></li><li><p>相对路径和绝对路径</p><ul><li>绝对路径是从<strong>盘符</strong>开始给出文件的路径</li><li>相对路径是相对当前项目下的文件路径</li></ul></li><li><p>常用方法</p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>public boolean createNewFile()</td><td>创建一个文件，如果该文件已存在返回false，如果不存在则创建该文件并且返回true，注意该文件所在文件夹必须存在</td></tr><tr><td>public boolean mkdir()</td><td>创建一个单级文件夹，如果文件夹已存在则返回false，如果不存在则创建文件夹并且返回true</td></tr><tr><td>public boolean mkdirs()</td><td>创建一个单级或多级文件夹，如果文件夹已存在则返回false，如果不存在则创建文件夹并且返回true（常用，既能创建单级也能创建多级）</td></tr><tr><td>public boolean delete()</td><td>删除一个文件或者一个空文件夹，不能删除含有文件的文件夹</td></tr><tr><td>public boolean isDirectory()</td><td>判断该路径表示的File对象是不是目录</td></tr><tr><td>public boolean isFile()</td><td>判断该路径表示的File对象是不是文件</td></tr><tr><td>public boolean exists()</td><td>判断该路径表示的File对象是否存在</td></tr><tr><td>public String getName()</td><td>返回该路径表示的File对象的文件名（含后缀）或者文件夹名</td></tr></tbody></table></li><li><p>特殊方法</p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>public File[] listFiles()</td><td>返回一个File数组，里面装有该路径下的文件和目录</td></tr></tbody></table><ul><li>当调用者不存在时，返回null</li><li>当调用者是一个文件是，返回null</li><li>当调用者是一个空文件夹时，返回长度为0的数组</li><li>当调用者是一个非空的文件夹时，返回一个装有该目录下所有的文件（含隐藏文件）和文件夹的File数组</li><li>当调用者是一个需要权限的文件夹时，返回null</li></ul></li><li><p>范例，如何删除含有文件和文件夹的文件夹？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">deleteDir</span><span class="params">(File src)</span>&#123;</span><br><span class="line">    <span class="comment">//先删除文件夹里面的内容，再删除文件夹</span></span><br><span class="line">    <span class="comment">//使用递归思路</span></span><br><span class="line">    File[] files = src.listFiles();</span><br><span class="line">    <span class="keyword">for</span>(File file:files)&#123;</span><br><span class="line">        <span class="keyword">if</span>(file.isFile())&#123;</span><br><span class="line">            <span class="comment">//如果是文件则删除</span></span><br><span class="line">            file.delete();</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//如果是文件夹则递归删除</span></span><br><span class="line">            deleteDir(file);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    src.delete();<span class="comment">//最后删除文件夹</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="2-IO流的分类"><a href="#2-IO流的分类" class="headerlink" title="2.IO流的分类"></a>2.IO流的分类</h3><ul><li><p>按流向分</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">graph TB;</span><br><span class="line">IO流--&gt;输入流</span><br><span class="line">IO流--&gt;输出流</span><br></pre></td></tr></table></figure></li><li><p>按数据类型分</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">graph TB;</span><br><span class="line">IO流--&gt;字节流</span><br><span class="line">IO流--&gt;字符流</span><br><span class="line">字节流--&gt;操作所有类型的文件</span><br><span class="line">字符流--&gt;只能操作纯文本文件</span><br></pre></td></tr></table></figure></li></ul><h3 id="3-字节流"><a href="#3-字节流" class="headerlink" title="3.字节流"></a>3.字节流</h3><ul><li><p>字节输出流<strong>FileOutputStream</strong></p><ol><li><p>常用构造方法</p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>public FileOutputStream(String finepath)</td><td>根据文件路径创建字节输出流对象</td></tr><tr><td>public FileOutputStream(File file)</td><td>根据文件对象创建字节输出流对象</td></tr><tr><td>public FileOutputStream(String filepath,boolean append)</td><td>append指定是否允许在文件追加数据</td></tr><tr><td>public FileOutputStream(File file,boolean append)</td><td>append指定是否允许在文件追加数据</td></tr></tbody></table></li><li><p>写数据的三种方式</p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>void write(int b)</td><td>一次写一个字节数据，<strong>这里的int值对应成ASCII中的字符</strong></td></tr><tr><td>void write(byte[] b)</td><td>一次写一个字节数组数据</td></tr><tr><td>void write(byte[] b,int off,int len)</td><td>一次写一个字节数组某长度的数据</td></tr></tbody></table><ul><li>如果在写数据时需要换行，可以使用 <code>write(&quot;\r\n&quot;.getBytes())</code>在windows系统中写入一个换行符，linux使用<strong>\n</strong>，mac使用<strong>\r</strong></li><li>默认情况下每次打开文件写数据时会将文件内容清空，如果需要实现追加的功能，可以使用带有<strong>append</strong>参数的构造方法来创建FileOutputStream对象</li></ul></li><li><p>字节输出流写文件的步骤</p><ul><li><p>创建字节输出流对象</p><p>文件不存在会自动创建，文件存在如果不使用含有append参数的构造方法则会清空文件</p></li><li><p>写数据</p></li><li><p>释放资源</p></li></ul></li><li><p>异常处理，使用finally块</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//try..catch..finally块处理异常的模板</span></span><br><span class="line"><span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    fos = <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;a.txt&quot;</span>);</span><br><span class="line">    fos.write(<span class="number">98</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">//finally块的代码无论是否产生异常，都会执行</span></span><br><span class="line">    <span class="keyword">if</span>(fos != <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            fos.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li><li><p>字节输入流<strong>FileInputStream</strong></p><ol><li><p>常用构造方法</p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>public FileInputStream(String filepath)</td><td>根据文件路径创建字节输入流对象</td></tr><tr><td>public FileInputStream(File file)</td><td>根据文件对象创建字节输入流对象</td></tr></tbody></table></li><li><p>读数据的方法</p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>int read()</td><td>从输入流中读一个字节，返回的是该字符的ASCII值</td></tr><tr><td>int read(byte[] b)</td><td>从输入流中最多将b.length个字节读取到数组中，返回的是<strong>实际读到的字节数</strong></td></tr><tr><td>int read(byte[] b,off,len)</td><td>从输入流中最多将len个字节读取到数组中，返回的是<strong>实际读到的字节数</strong></td></tr></tbody></table><ul><li><p>当使用读出来的数据是**-1**时，表明文件已经读到底部</p></li><li><p>连续读取多个数据范例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="type">int</span> b;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    fis = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;a.txt&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> ((b = fis.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">        System.out.print((<span class="type">char</span>)b);<span class="comment">//由于读出来的数据是字节，需要强转</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        fis.close();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>文件拷贝范例1（单个字节读写）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="type">int</span> b;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    fis = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;D:\\Code\\HTML\\project1.html&quot;</span>);</span><br><span class="line">    fos = <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;a.txt&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span>((b = fis.read()) != -<span class="number">1</span>)&#123;</span><br><span class="line">        fos.write(b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        fis.close();</span><br><span class="line">        fos.close();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>文件拷贝范例2（多个字节读写）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="type">int</span> len;</span><br><span class="line"><span class="type">byte</span>[] temp = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    fis = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;D:\\Code\\HTML\\project1.html&quot;</span>);</span><br><span class="line">    fos = <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;a.txt&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span>((len = fis.read(temp)) != -<span class="number">1</span>)&#123;</span><br><span class="line">        fos.write(temp,<span class="number">0</span>,len);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        fis.close();</span><br><span class="line">        fos.close();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol></li></ul><h3 id="4-字节缓冲流"><a href="#4-字节缓冲流" class="headerlink" title="4.字节缓冲流"></a>4.字节缓冲流</h3><ul><li><p>字节缓冲流是将数据从硬盘读&#x2F;写到缓冲区中，待缓冲区满了再进行读&#x2F;写，不用每次都到硬盘中操作，提高了读写的效率</p></li><li><p>字节缓冲流<strong>仅仅提供缓冲区</strong>，而真正读写数据还得依靠基本的字节流对象进行操作</p></li><li><p>字节缓冲输出流<strong>BufferedOutputStream</strong></p><ol><li>构造方法：<ul><li><code>public BufferedOutputStream(OutputStream out);</code>默认缓冲区大小</li><li><code>public BufferedOutputStream(OutputStream out,int size);</code>指定缓冲区大小</li></ul></li><li>构造的参数是OutputStream类型的对象</li></ol></li><li><p>字节缓冲输入流<strong>BufferedInputStream</strong></p><ol><li>构造方法：<ul><li><code>public BufferedInputStream(InputStream in);</code>默认缓冲区大小</li><li><code>public BufferedInputStream(InputStream in,int size);</code>指定缓冲区大小</li></ul></li><li>构造的参数是InputStream类型的对象</li></ol></li><li><p>使用缓冲流拷贝文件范例1（单个字节读写）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">BufferedInputStream</span> <span class="variable">bis</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="type">BufferedOutputStream</span> <span class="variable">bos</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="type">int</span> b;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    bis = <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;D:\\Code\\HTML\\project1.html&quot;</span>));</span><br><span class="line">    bos = <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;a.txt&quot;</span>));</span><br><span class="line">    <span class="keyword">while</span>((b = bis.read()) != -<span class="number">1</span>)&#123;</span><br><span class="line">        bos.write(b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        bis.close();</span><br><span class="line">        bos.close();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用缓冲流拷贝文件范例2（多个字节读写）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">BufferedInputStream</span> <span class="variable">bis</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="type">BufferedOutputStream</span> <span class="variable">bos</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="type">int</span> len;</span><br><span class="line"><span class="type">byte</span>[] b = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    bis = <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;D:\\Code\\HTML\\project1.html&quot;</span>));</span><br><span class="line">    bos = <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;a.txt&quot;</span>));</span><br><span class="line">    <span class="keyword">while</span>((len = bis.read(b)) != -<span class="number">1</span>)&#123;</span><br><span class="line">        bos.write(b,<span class="number">0</span>,len);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        bis.close();</span><br><span class="line">        bos.close();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="5-字符流"><a href="#5-字符流" class="headerlink" title="5.字符流"></a>5.字符流</h3><ul><li><p>由于编码和解码的方式不同，计算机中可能会出现乱码的问题</p></li><li><p>Windows默认使用的码表是GBK，一个汉字占<strong>两个字节</strong>，IDEA和以后工作默认使用Unicode的UTF-8编解码格式，一个汉字占<strong>三个字节</strong></p></li><li><p>字符串中的编码和解码</p><ol><li><code>byte[] getBytes()</code>，使用平台默认字符集将该String编码为一系列字节，将结果存储到字节数组中返回</li><li><code>byte[] getBytes(String charsetName)</code>，使用指定的字符集将该String编码为一系列字节，将结果存储到字节数组中返回</li><li><code>public String(byte[] bytes)</code>，String类的一个构造方法，使用平台默认的字符集对给定的字节数组进行解码（创建字符串对象）</li><li><code>public String(byte[] bytes,String charsetName)</code>，String类的一个构造方法，使用指定的字符集对给定的字节数组进行解码（创建字符串对象）</li></ol></li><li><p>如果需要将文本文件数据<strong>读取</strong>到内存或者将内存数据<strong>写入</strong>文本文件时，建议使用字符流，而文件拷贝使用字节流</p></li><li><p>字符输出流<strong>FileWriter</strong></p><ol><li><p>构造方法</p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>public FileWriter(String filepath)</td><td>通过文件路径创建字符输出流对象</td></tr><tr><td>public FileWriter(File file)</td><td>通过文件对象创建字符输出流对象</td></tr><tr><td>public FileWriter(String filepath,boolean append)</td><td>append指定是否允许在文件追加数据</td></tr><tr><td>public FileWriter(File file,boolean append)</td><td>append指定是否允许在文件追加数据</td></tr></tbody></table><ul><li>字符流底层使用到了字节流</li></ul></li><li><p>字符流写数据</p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>void write(int c)</td><td>写一个字符，<strong>int值是字符的ASCII值</strong></td></tr><tr><td>void write(char[] cbuf)</td><td>写一个字符数组</td></tr><tr><td>void write(char[] cbuf,int off,int len)</td><td>写一个字符数组的指定长度</td></tr><tr><td>void write(String str)</td><td>写一个字符串</td></tr><tr><td>void write(String str,int off,int len)</td><td>写一个字符串的指定长度</td></tr></tbody></table></li><li><p>**flush()<strong>方法和</strong>close()**方法</p><p><code>void flush()</code>：刷新流，后续仍然能写数据</p><p><code>void close()</code>：关闭流，关闭前会刷新一次，后续不能再写数据</p></li><li><p>写文件范例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">FileWriter</span> <span class="variable">fw</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="type">char</span>[] c = <span class="keyword">new</span> <span class="title class_">char</span>[]&#123;<span class="string">&#x27;廖&#x27;</span>,<span class="string">&#x27;向&#x27;</span>,<span class="string">&#x27;前&#x27;</span>&#125;;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    fw = <span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;a.txt&quot;</span>);</span><br><span class="line">    fw.write(c);</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        fw.close();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li><li><p>字符输入流<strong>FileReader</strong></p><ol><li><p>构造方法</p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>public FileReader(String filepath)</td><td>通过文件路径创建字符输入流对象</td></tr><tr><td>public FileReader(File file)</td><td>通过文件对象创建字符输入流对象</td></tr></tbody></table><ul><li>底层用到字节流</li></ul></li><li><p>字符流读数据</p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>int read()</td><td>读一个字符，返回的<strong>int</strong>是字符的整数表示</td></tr><tr><td>int read(char[] cbuf)</td><td>读最多cbuf.leng个字符到字符数组中，返回实际读到的字符数</td></tr><tr><td>int read(char[] cbuf,int off,int len)</td><td>读最多len个字符到字符数组中，返回实际读到的字符数</td></tr></tbody></table></li><li><p>读文件范例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">FileReader</span> <span class="variable">fr</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="type">char</span>[] chars = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">1024</span>];</span><br><span class="line"><span class="type">int</span> len;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    fr = <span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;a.txt&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span>((len = fr.read(chars)) != -<span class="number">1</span>)&#123;</span><br><span class="line">        System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(chars,<span class="number">0</span>,len));</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        fr.close();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li></ul><h3 id="6-字符缓冲流"><a href="#6-字符缓冲流" class="headerlink" title="6.字符缓冲流"></a>6.字符缓冲流</h3><ul><li><p>字符缓冲流也是用于提高效率的</p></li><li><p>字符缓冲输出流<strong>BufferedWriter</strong></p><ol><li><p>构造方法</p><p><code>public BufferedWriter(Writer out);</code>默认缓冲区大小</p><p><code>public BufferedWriter(Writer out,int size)</code>，指定缓冲区大小</p></li><li><p>构造的参数是Writer</p></li><li><p>特殊方法</p><p><code>public void newLine();</code>写入一个换行符</p></li></ol></li><li><p>字符缓冲输入流<strong>BufferedReader</strong></p><ol><li><p>构造方法</p><p><code>public BufferedReader(Reader in);</code>默认缓冲区大小</p><p><code>public BufferedReader(Reader in,int size)</code>，指定缓冲区大小</p></li><li><p>构造的参数是Reader</p></li><li><p>特殊方法</p><p><code>public String readLine();</code>读一行数据并返回，如果是文件末尾返回null</p></li></ol></li><li><p>使用字符缓冲输出流范例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">BufferedWriter</span> <span class="variable">bw</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    bw = <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;a.txt&quot;</span>));</span><br><span class="line">    bw.write(<span class="string">&quot;我是大帅逼&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        bw.close();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用字符缓冲输入流范例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="type">char</span>[] chars = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">1024</span>];</span><br><span class="line"><span class="type">int</span> len;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    br = <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;a.txt&quot;</span>));</span><br><span class="line">    <span class="keyword">while</span>((len = br.read(chars)) != -<span class="number">1</span>)&#123;</span><br><span class="line">        System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(chars,<span class="number">0</span>,len));</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        br.close();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="7-转换流"><a href="#7-转换流" class="headerlink" title="7.转换流"></a>7.转换流</h3><ul><li><strong>InputStreamReader</strong>，字节流转为字符流，硬盘–&gt;内存<ul><li>InputStreamReader是FileReader的父类，构造FileReader对象底层是用到了InputStreamReader的构造方法</li><li>作用是将硬盘中的字节码读取出来，经过解码从而转换为字符，所以使用字符流使用到了转换流</li></ul></li><li><strong>OutputStreamWriter</strong>，字符流转为字节流，内存–&gt;硬盘<ul><li>OutputStreamWriter是FileWriter的父类，构造FileWriter对象底层是用到了OutputStreamWriter的构造方法</li><li>作用是将内存中的字符经过编码转换为字节码，然后写入硬盘，所以使用字符流使用到了转换流</li></ul></li><li>转换流的构造方法可以<strong>指定字符集</strong>，在JDK11以前<strong>字符流</strong>不能指定字符集，而JDK11后字符流新增了可以指定字符集的<strong>构造方法</strong>，从而可以直接使用字符流来完成读写而无需使用转换流</li></ul><h3 id="8-对象流"><a href="#8-对象流" class="headerlink" title="8.对象流"></a>8.对象流</h3><ul><li><p>将对象以流的形式传输，这种流称为对象流</p></li><li><p>分类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">graph TB;</span><br><span class="line">对象流--&gt;对象输入流</span><br><span class="line">对象流--&gt;对象输出流</span><br><span class="line">对象输入流--&gt;ObjectInputStream</span><br><span class="line">对象输出流--&gt;ObjectOutputStream</span><br></pre></td></tr></table></figure></li><li><p>对象输出流又称为<strong>对象序列化流</strong>，用于将对象写入文件或在网络中传输，使用**writeObject()**方法写对象</p><ol><li>构造方法：<code>public ObjectOutputStream(OutputStream out);</code></li><li>常用方法：<code>void writeObject(Object o);</code></li></ol></li><li><p>对象输入流又称为<strong>对象反序列化流</strong>，用于将对象从文件中读到内存或接收网络中的对象，使用**readObject()**方法读对象，注意类型转换</p><ol><li>构造方法：<code>public ObjectInputStream(InputStream in);</code></li><li>常用方法：<code>Object readObject();</code></li></ol></li><li><p>对象需要序列化必须实现<strong>Serializable</strong>接口，该接口是标记接口，没有任何抽象方法，只要是实现该接口的类，它的对象就能序列化</p></li><li><p>注意事项1</p><ol><li><p>用对象序列化流序列化一个对象后，如果修改了对象所属的类，再次读取该对象时会抛出<strong>InvalidClassException</strong>异常</p></li><li><p>这是因为<strong>serialVersionUID</strong>是由虚拟机自动生成，写入文件时与读取文件时的serialVersionUID不一致造成的</p></li><li><p>解决办法是在序列化的类中手动给出serialVersionUID，并且这个值固定不变，格式是：</p><p><code>private static final long serialVersionUID = long值;</code></p></li></ol></li><li><p>注意事项2</p><ol><li>如果类中某个成员变量的值不想要被序列化，可以给该成员变量加上<strong>transient</strong>关键字修饰，表示该成员变量不参与序列化过程</li></ol></li><li><p>读取多个对象时难以分辨循环中是否读取到文件末尾，所以在存对象时可以将对象先存放在<strong>集合</strong>中再写入文件，这样读取对象时可以只使用一次读操作将该集合读取出来</p></li></ul><h3 id="9-Properties类"><a href="#9-Properties类" class="headerlink" title="9.Properties类"></a>9.Properties类</h3><ul><li><p>是Map集合中的一个类，存放的是双列数据</p></li><li><p>含有跟IO相关的方法</p></li><li><p>键值对的数据类型一般使用String</p></li><li><p>由于是Map集合体系中的类，所以一般的增删改查方法与Map集合中的相同</p></li><li><p>其他方法</p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>Object setProperty(String key,String value)</td><td>设置集合的键和值，都是String类型，底层调用HashTable的put()方法</td></tr><tr><td>String getProperty(String key)</td><td>根据键获取值</td></tr><tr><td>Set<code>&lt;String&gt;</code> stringPropertyNames()</td><td>返回一个装有键的Set集合，其中键值都是String类型</td></tr></tbody></table></li><li><p>load()和store()方法</p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>void load(InputStream in)</td><td>从字节输入流中读取键值对到Peoperties集合</td></tr><tr><td>void load(Reader reader)</td><td>从字符输入流中读取键值对到Peoperties集合</td></tr><tr><td>void store(OutputStream out,String comments)</td><td>将Properties集合中的键值对写入字节输出流，保存到文件中</td></tr><tr><td>void store(Writer writer,String comments)</td><td>将Properties集合中的键值对写入字符输出流，保存到文件中</td></tr></tbody></table><ul><li>comments参数作用是在配置文件中写注释</li></ul></li><li><p>一般存放Properties集合的文件后缀是**.properties**，一般用于配置文件</p></li><li><p>范例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//store()方法使用</span></span><br><span class="line"><span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">properties.setProperty(<span class="string">&quot;user&quot;</span>,<span class="string">&quot;root&quot;</span>);</span><br><span class="line">properties.setProperty(<span class="string">&quot;password&quot;</span>,<span class="string">&quot;root&quot;</span>);</span><br><span class="line"><span class="type">FileWriter</span> <span class="variable">fw</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    fw = <span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;prop.properties&quot;</span>);</span><br><span class="line">    properties.store(fw,<span class="literal">null</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        fw.close();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//load()方法使用</span></span><br><span class="line"><span class="type">Properties</span> <span class="variable">newProperties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line"><span class="type">FileReader</span> <span class="variable">fr</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    fr = <span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;prop.properties&quot;</span>);</span><br><span class="line">    newProperties.load(fr);</span><br><span class="line">    System.out.println(newProperties);</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        fr.close();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>由于Properties集合没有关闭流的操作，所以不建议使用匿名内部类的形式来使用store()和load()方法</p></li></ul><h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><h3 id="1-概述-1"><a href="#1-概述-1" class="headerlink" title="1.概述"></a>1.概述</h3><ul><li>多线程是指从硬件或软件上实现多个线程并发执行的技术</li><li>具有多线程能力的计算机因有硬件支持而能够在同一时间执行多个线程，提升性能</li></ul><h3 id="2-并行和并发"><a href="#2-并行和并发" class="headerlink" title="2.并行和并发"></a>2.并行和并发</h3><ul><li>并行：在同一时刻，有多个指令在多个CPU上<strong>同时</strong>执行</li><li>并发：在同一时刻，有多个指令在单个CPU上<strong>交替</strong>执行</li></ul><h3 id="3-进程和线程"><a href="#3-进程和线程" class="headerlink" title="3.进程和线程"></a>3.进程和线程</h3><ul><li>进程：正在运行的软件<ol><li>独立性：进程是一个能独立运行的基本单位，同时也是系统分配资源和调度的独立单位</li><li>动态性：进程实质是程序的一次执行过程，进程是动态产生，动态消亡的</li><li>并发性：任何进程都可以和其他进程一起并发执行</li></ol></li><li>线程：是进程中的单个顺序控制流，是一条执行路径<ol><li>单线程：一个进程如果只有一条执行路径，称为单线程程序</li><li>多线程：一个进程如果有多条执行路径，称为多线程程序</li></ol></li></ul><h3 id="4-多线程实现方式"><a href="#4-多线程实现方式" class="headerlink" title="4.多线程实现方式"></a>4.多线程实现方式</h3><ul><li><p>继承<strong>Thread</strong>类方式进行</p><ol><li><p>自定义类继承Thread类</p></li><li><p>在自定义类中重写**run()**方法</p></li><li><p>创建自定义类的对象</p></li><li><p>启动线程</p></li><li><p>范例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="comment">//创建线程1</span></span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">        <span class="comment">//创建线程2</span></span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">        <span class="comment">//启动线程1</span></span><br><span class="line">        thread1.start();</span><br><span class="line">        <span class="comment">//启动线程2</span></span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>注意事项</p><ul><li>run()方法用来封装被线程执行的代码，如果直接调用该方法不能实现多线程，而是单纯的方法调用</li><li>start()方法用来启动一个线程，然后JVM调用该线程的run()方法</li></ul></li></ol></li><li><p>实现<strong>Runnable</strong>接口方式进行</p><ol><li><p>自定义类实现Runnable接口</p></li><li><p>在自定义类中重写**run()**方法</p></li><li><p>创建自定义类对象</p></li><li><p>创建Thread类对象，把自定义类对象作为构造方法的参数</p></li><li><p>启动线程</p></li><li><p>范例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="comment">//创建线程1</span></span><br><span class="line">        <span class="type">MyRunnable</span> <span class="variable">myRunnable1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyRunnable</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(myRunnable1);</span><br><span class="line">        <span class="comment">//创建线程2</span></span><br><span class="line">        <span class="type">MyRunnable</span> <span class="variable">myRunnable2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(myRunnable2);</span><br><span class="line">        <span class="comment">//启动线程1</span></span><br><span class="line">        thread1.start();</span><br><span class="line">        <span class="comment">//启动线程2</span></span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li><li><p>利用<strong>Callable</strong>接口和<strong>FutureTask</strong>类进行</p><ol><li><p>自定义类实现Callable接口</p></li><li><p>在自定义类中重写**call()**方法</p></li><li><p>创建自定义类的对象</p></li><li><p>创建FutureTask类的对象，把自定义类的对象作为构造方法的参数</p></li><li><p>创建Thread类的对象，把FutureTask对象作为构造方法的参数</p></li><li><p>FutrueTask中的get()方法可以获取线程执行完后的返回值，如果在线程开启前调用该方法，那么该程序会一直停留在该代码处</p></li><li><p>范例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="comment">//创建线程1</span></span><br><span class="line">        <span class="type">MyCallable</span> <span class="variable">myCallable1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyCallable</span>();</span><br><span class="line">        FutureTask&lt;String&gt; futureTask1 = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(myCallable1);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(futureTask1);</span><br><span class="line">        <span class="comment">//创建线程2</span></span><br><span class="line">        <span class="type">MyCallable</span> <span class="variable">myCallable2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyCallable</span>();</span><br><span class="line">        FutureTask&lt;String&gt; futureTask2 = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(myCallable2);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(futureTask2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//启动线程1</span></span><br><span class="line">        thread1.start();</span><br><span class="line">        <span class="comment">//启动线程2</span></span><br><span class="line">        thread2.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取执行完的结果</span></span><br><span class="line">        System.out.println(futureTask1.get());</span><br><span class="line">        System.out.println(futureTask2.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyCallable</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;String&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; <span class="number">100</span>;i++)&#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//返回值表示线程执行完返回的结果</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;该线程执行完啦&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li><li><p>三种方式对比</p><table><thead><tr><th>方式</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>继承Thread类</td><td>编程简单，run()方法中能直接使用Thread类中的方法</td><td>扩展性差，不能继承其他类</td></tr><tr><td>实现Runnable接口或实现Callable接口</td><td>扩展性强，实现接口的同时还能继承其它类</td><td>编程复杂，run()方法或者call()方法中不能直接使用Thread类中的方法</td></tr></tbody></table></li></ul><h3 id="5-Thread类常用方法"><a href="#5-Thread类常用方法" class="headerlink" title="5.Thread类常用方法"></a>5.Thread类常用方法</h3><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>String getName()</td><td>获取线程名称</td></tr><tr><td>void setName(String name)</td><td>设置线程名称</td></tr><tr><td>public static Thread currentThread()</td><td>返回当前线程对象的引用</td></tr><tr><td>public static void sleep(long time)</td><td>让线程休眠指定时间，单位为毫秒</td></tr><tr><td>public final void setPriority(int priority)</td><td>设置线程优先级（优先级范围是1~10，默认是5）</td></tr><tr><td>public final int getPriority()</td><td>获取线程优先级</td></tr><tr><td>public final void setDaemon(boolean on)</td><td>设置线程为守护线程</td></tr></tbody></table><ul><li>线程调度<ol><li>多线程的并发运行：计算机中的CPU，在任意时刻只能执行一条机器指令，每个线程只有获得CPU的使用权才能执行代码，各个线程轮流获得CPU的使用权，分别执行各自的任务</li><li>两种调度模型：<ul><li>分时调度模型：所有线程<strong>轮流</strong>使用CPU的使用权，平均分配每个线程占用CPU时间片</li><li>抢占式调度模型：优先让优先级高的线程使用CPU，如果线程优先级相同，则随机执行，优先级高的线程获得的时间片的概率较高</li></ul></li><li>java使用第二种调度模型</li></ol></li><li>守护线程：守护线程是为了守护普通线程而存在的，普通线程执行完毕后，守护线程也会停止运行</li></ul><h3 id="6-线程安全问题"><a href="#6-线程安全问题" class="headerlink" title="6.线程安全问题"></a>6.线程安全问题</h3><ul><li>多线程操作共享数据时，会出现多线程的数据安全问题，例如卖票的案例</li><li>解决方式：把操作共享数据的多条代码<strong>锁</strong>起来，让任意时刻只能有一个线程去执行，Java中提供<strong>同步代码块</strong>的方式来解决</li><li>同步代码块<ol><li>格式：<code>synchronized(obj)&#123;共享数据的代码&#125;</code></li><li>obj表示任意一个对象，每一个对象都有一个锁</li><li>一个线程要想执行代码块中的代码必须获得这个锁，任何时刻只能有一个线程可以获得这个代码块的锁，多个线程想要实现同步则必须共用一个锁</li><li>当代码块执行完毕时或者代码块中抛出异常都会释放锁</li><li>好处是解决了多线程数据安全问题，弊端是降低程序执行效率</li></ol></li><li>同步方法<ol><li>格式：<code>修饰符 synchronized 返回值类型 方法名(方法参数)&#123;&#125;</code></li><li>同步方法的锁对象是<strong>this</strong></li><li>如果同步方法是<strong>静态方法</strong>，则锁对象是<strong>类名.class</strong></li></ol></li><li>同步代码块和同步方法区别<ol><li>同步代码块是锁住指定代码，同步方法是锁住方法中全部代码</li><li>同步代码块可以指定锁对象，同步方法不能指定锁对象</li></ol></li><li>Lock锁<ol><li>为了更加清晰表达如何加锁和释放锁，JDK5以后提供了一个锁对象Lock</li><li>由于Lock是接口，所以实际使用它的实现类<strong>ReentrantLock</strong>类来实例化</li><li>Lock提供了两个方法 <code>void lock();</code>和 <code>void unlock();</code>来分别加锁和释放锁，需要同步的代码则处于这两个方法之间</li><li>为了避免在同步代码中出现异常导致程序中断而没能执行unlock()方法，所以unlock()方法一般放在finally块中处理</li></ol></li><li>死锁：线程死锁是由于两个或多个线程持有对方所需要的资源，导致这些线程处于等待状态，无法继续执行。比如在锁嵌套时会出现死锁</li></ul><h3 id="7-生产者消费者模式"><a href="#7-生产者消费者模式" class="headerlink" title="7.生产者消费者模式"></a>7.生产者消费者模式</h3><ul><li><p>等待唤醒机制</p></li><li><p>多线程协作的模式，加深多线程编程的理解</p></li><li><p>Object类中的等待和唤醒方法</p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>void wait()</td><td>使线程处于等待状态，直到另一个线程调用该对象的notify()方法或notifyAll()方法</td></tr><tr><td>void notify()</td><td>唤醒正在等待的单个线程</td></tr><tr><td>void notifyAll()</td><td>唤醒正在等待的所有线程</td></tr></tbody></table></li><li><p>生产者消费者模式范例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Desk</span> <span class="variable">desk</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Desk</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Foodie</span> <span class="variable">foodie</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Foodie</span>(desk);</span><br><span class="line">        <span class="type">Cooker</span> <span class="variable">cooker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cooker</span>(desk);</span><br><span class="line"></span><br><span class="line">        foodie.start();</span><br><span class="line">        cooker.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Desk</span>&#123;</span><br><span class="line">    <span class="comment">//定义标记</span></span><br><span class="line">    <span class="comment">//true表示桌上还有汉堡</span></span><br><span class="line">    <span class="comment">//false表示桌上没有汉堡</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> flag;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//汉堡包总数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//锁对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Desk</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(<span class="literal">false</span>,<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Desk</span><span class="params">(<span class="type">boolean</span> flag, <span class="type">int</span> count)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.flag = flag;</span><br><span class="line">        <span class="built_in">this</span>.count = count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isFlag</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> flag;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setFlag</span><span class="params">(<span class="type">boolean</span> flag)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.flag = flag;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCount</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCount</span><span class="params">(<span class="type">int</span> count)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.count = count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getLock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> lock;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Desk&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;flag=&quot;</span> + flag +</span><br><span class="line">                <span class="string">&quot;, count=&quot;</span> + count +</span><br><span class="line">                <span class="string">&quot;, lock=&quot;</span> + lock +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Foodie</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="comment">//消费者步骤：</span></span><br><span class="line">    <span class="comment">//判断桌子是否含有汉堡</span></span><br><span class="line">    <span class="comment">//没有就等待</span></span><br><span class="line">    <span class="comment">//有就开吃</span></span><br><span class="line">    <span class="comment">//吃完之后，唤醒生产者继续生产</span></span><br><span class="line">    <span class="comment">//汉堡数量-1</span></span><br><span class="line">    <span class="keyword">private</span> Desk desk;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Foodie</span><span class="params">(Desk desk)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.desk = desk;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (desk.getLock())&#123;</span><br><span class="line">                <span class="keyword">if</span>(desk.getCount() == <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">if</span>(desk.isFlag())&#123;</span><br><span class="line">                        <span class="comment">//有，开吃</span></span><br><span class="line">                        System.out.println(<span class="string">&quot;消费者吃汉堡.....&quot;</span>);</span><br><span class="line">                        desk.setFlag(<span class="literal">false</span>);</span><br><span class="line">                        desk.getLock().notifyAll();</span><br><span class="line">                        desk.setCount(desk.getCount()-<span class="number">1</span>);</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        <span class="comment">//桌子上没有，等待</span></span><br><span class="line">                        <span class="comment">//使用什么锁对象，就用那个锁对象去唤醒或等待</span></span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            desk.getLock().wait();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cooker</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="comment">//生产者步骤：</span></span><br><span class="line">    <span class="comment">//判断桌子是否有汉堡</span></span><br><span class="line">    <span class="comment">//如果有则等待</span></span><br><span class="line">    <span class="comment">//如果没有则生产汉堡，放在桌子上</span></span><br><span class="line">    <span class="comment">//唤醒等待的消费者</span></span><br><span class="line">    <span class="keyword">private</span> Desk desk;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Cooker</span><span class="params">(Desk desk)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.desk = desk;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (desk.getLock()) &#123;</span><br><span class="line">                <span class="keyword">if</span>(desk.getCount() == <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">if</span>(desk.isFlag())&#123;</span><br><span class="line">                        <span class="comment">//有，等待</span></span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            desk.getLock().wait();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        <span class="comment">//没有，开始生产</span></span><br><span class="line">                        <span class="comment">//放在桌上</span></span><br><span class="line">                        <span class="comment">//唤醒消费者</span></span><br><span class="line">                        System.out.println(<span class="string">&quot;生产者正在做汉堡.....&quot;</span>);</span><br><span class="line">                        desk.setFlag(<span class="literal">true</span>);</span><br><span class="line">                        desk.getLock().notifyAll();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>阻塞队列</p><ol><li><p><strong>ArrayBlockingQueue</strong>类，底层是数组，有界，没有无参构造方法</p></li><li><p><strong>LinkedBlockingQueue</strong>类，底层是链表，无界但最多能存放int的最大值，无参构造方法默认容量就是最大值</p></li><li><p>常用方法</p><ul><li><code>put(Object o);</code>，将参数放入队列，如果放不进去会阻塞</li><li><code>take();</code>，取出第一个数据，取不到会阻塞</li></ul></li><li><p>使用阻塞队列实现生产者消费者模式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ArrayBlockingQueue;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        ArrayBlockingQueue&lt;String&gt; arrayBlockingQueue = <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Foodie</span> <span class="variable">foodie</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Foodie</span>(arrayBlockingQueue);</span><br><span class="line">        <span class="type">Cooker</span> <span class="variable">cooker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cooker</span>(arrayBlockingQueue);</span><br><span class="line"></span><br><span class="line">        foodie.start();</span><br><span class="line">        cooker.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Foodie</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ArrayBlockingQueue&lt;String&gt; arrayBlockingQueue;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Foodie</span><span class="params">(ArrayBlockingQueue&lt;String&gt; arrayBlockingQueue)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.arrayBlockingQueue = arrayBlockingQueue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">take</span> <span class="operator">=</span> arrayBlockingQueue.take();</span><br><span class="line">                System.out.println(<span class="string">&quot;生产者消费了一个&quot;</span>+take);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cooker</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ArrayBlockingQueue&lt;String&gt; arrayBlockingQueue;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Cooker</span><span class="params">(ArrayBlockingQueue&lt;String&gt; arrayBlockingQueue)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.arrayBlockingQueue = arrayBlockingQueue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                arrayBlockingQueue.put(<span class="string">&quot;汉堡包&quot;</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;生产者放了一个汉堡包&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>由于锁是在put()和take()里边，而输出的语句在外边，所以控制台输出时会出现重复</li></ul></li></ol></li></ul><h3 id="8-线程的状态"><a href="#8-线程的状态" class="headerlink" title="8.线程的状态"></a>8.线程的状态</h3><ul><li><p>状态变化的流程</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5809/ThreadStatus.png" alt="ThreadStatus"></p></li><li><p>虚拟机中定义的六种线程状态（Thread的内部类State）</p><ol><li>新建状态（NEW）———-&gt;创建线程对象</li><li>就绪状态（RUNNABLE）———-&gt;start方法</li><li>阻塞状态（BLOCKED）———-&gt;无法获得锁对象</li><li>等待状态（WAITING）———-&gt;wait方法</li><li>计时等待（TIMED_WAITING）———-&gt;sleep方法</li><li>结束状态（TERMINATED）———-&gt;全部代码运行完毕</li></ol></li></ul><h3 id="9-线程池"><a href="#9-线程池" class="headerlink" title="9.线程池"></a>9.线程池</h3><ul><li><p>每一个线程的启动和结束都是比较消耗时间和资源的，如果在系统中用到很多线程，大量的线程启动和结束操作会导致性能变卡、响应变慢，为了解决这个问题，引入线程池的设计思想，线程池是一种生产者消费者模式</p></li><li><p>主要思想是创建若干个线程放入池子，有任务需要处理时将任务提交到线程池中的任务队列，任务处理完后线程并不会销毁，而是继续在线程池中等待下一个任务</p></li><li><p>静态方法创建线程池</p><ol><li>使用<strong>Executors</strong>类中的静态方法 <code>static ExecutorService newCachedThreadPool()</code>创建线程池，默认线程池是空的，根据需要创建线程，超过60秒未被使用的线程则<strong>销毁</strong>，最多能创建int最大值个线程</li><li>使用<strong>Executors</strong>类中的静态方法 <code>static ExecutorService newFixedThreadPool(int nThreads)</code>创建线程池，默认线程池是空的，根据需要创建线程，参数表示线程池最多能够创建的线程，创建的线程将<strong>一直存在直到显式调用shutdown()方法</strong></li><li>这两个方法返回值类型是<strong>ExecutorService</strong>接口，这个接口里边定义了操作线程池的方法，常用的两个方法是<ul><li><code>submit(task)</code>，task是需要执行的任务，可以是实现Runnable接口或Callable接口的类对象，也可以是Lambda表达式</li><li><code>shutdown()</code>，用于任务执行后关闭线程池</li></ul></li></ol></li><li><p>使用<strong>ThreadPoolexecutor</strong>类创建线程池</p><ol><li><p>上述使用静态方法创建的线程池实际上是使用了该类来创建并返回的线程池</p></li><li><p>常用构造方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(</span></span><br><span class="line"><span class="params">                          <span class="type">int</span> corePoolSize,</span></span><br><span class="line"><span class="params">                          <span class="type">int</span> maximumPoolSize,</span></span><br><span class="line"><span class="params">                          <span class="type">long</span> keepAliveTime,</span></span><br><span class="line"><span class="params">                          TimeUnit unit,</span></span><br><span class="line"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span><br><span class="line"><span class="params">                          ThreadFactory threadFactory,</span></span><br><span class="line"><span class="params">                          RejectedExecutionHandler handler</span></span><br><span class="line"><span class="params">)</span>&#123;&#125;</span><br></pre></td></tr></table></figure></li><li><p>构造方法参数解析</p><ul><li><code>corePoolSize</code>：核心线程数量</li><li><code>maximumPoolSize</code>：最大线程数量</li><li><code>keepAliveTime</code>：空闲线程存活时间的值</li><li><code>unit</code>：存活时间的单位</li><li><code>workQueue</code>：任务队列</li><li><code>threadFactory</code>：线程工厂，指定创建线程的方式</li><li><code>handler</code>：任务拒绝策略，当任务队列已满，新任务不能提交到线程池时触发对新任务的处理策略</li></ul></li><li><p>任务拒绝策略</p><ul><li><code>ThreadPoolExecutor.AbortPolicy</code>，丢弃任务并抛出RejectExecutionException异常，默认的任务拒绝策略</li><li><code>ThreadPoolExecutor.DiscardPolicy</code>，丢弃任务但不抛出异常，不推荐使用</li><li><code>ThreadPoolExecutor.DiscardOldestPolicy</code>，抛弃队列中等待最久的任务然后将当前任务加入任务队列</li><li><code>ThreadPoolExecutor.CallerRunsPolicy</code>，调用任务的run()方法绕过线程池直接执行</li></ul></li></ol></li></ul><h3 id="10-一个问题"><a href="#10-一个问题" class="headerlink" title="10.一个问题"></a>10.一个问题</h3><ul><li><p>问题</p><ol><li>堆内存是唯一的，每一个线程都有自己的线程栈</li><li>线程在使用堆里面的变量时，会先拷贝一本到变量的副本中</li><li>线程每次使用变量都是从变量副本中获取的</li><li>所以，当一个线程修改了共享变量中的值时，其他线程不一定能够及时使用最新的值</li></ol></li><li><p>解决方式1：使用<strong>volatile</strong>关键字修饰共享变量，作用是线程在每次使用该变量的时候，都会查看共享变量的值</p></li><li><p>解决方式2：使用<strong>synchronized</strong>同步代码块，作用是：</p><ol><li>线程获得锁</li><li>清空变量副本</li><li>拷贝共享变量最新的值到变量副本中</li><li>执行代码</li><li>将修改后变量副本的值赋值给共享数据</li><li>释放锁</li></ol></li></ul><h3 id="11-原子性"><a href="#11-原子性" class="headerlink" title="11.原子性"></a>11.原子性</h3><ul><li><p>原子性是指一个操作是不可中断的，要么全部执行成功要么全部执行失败，有着“同生共死”的感觉。即使在多个线程一起执行的时候，一个操作一旦开始，就不会被其他线程所干扰</p></li><li><p>volatile不能保证原子性，synchronized可以保证原子性</p></li><li><p>原子操作类，既能保证原子性又比synchronized高效，如<strong>AtomicInteger</strong>类</p><ol><li><p>构造方法</p><ul><li><code>public AtomicInteger()</code>，创建初始值为0的对象</li><li><code>public AtomicInteger(int value)</code>，创建指定值的对象</li></ul></li><li><p>常用方法</p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>int get()</td><td>获取值</td></tr><tr><td>int getAndIncrement()</td><td>以原子方式将当前值加1，返回加1前的旧值</td></tr><tr><td>int incrementAndGet()</td><td>以原子方式将当前值加1，返回加1后的新值</td></tr><tr><td>int addAndGet(int value)</td><td>以原子方式将当前值与参数相加，并返回结果</td></tr><tr><td>int getAndSet(int value)</td><td>以原子方式将当前值设置为参数的值，返回旧值</td></tr></tbody></table></li><li><p>原理（底层使用<strong>自旋+CAS算法</strong>）</p><ul><li>CAS算法<ol><li>线程在修改共享数据时查看<strong>共享数据</strong>的值与<strong>变量副本</strong>的值是否相同</li><li>如果<strong>相同</strong>说明共享变量的值没有被其他线程修改，可以直接将新值赋给共享数据</li><li>如果<strong>不相同</strong>，说明在对变量副本进行操作时有其他线程修改了共享数据，此时不能修改共享数据，而是重新获取共享数据的值</li></ol></li><li>自旋（自旋就是重新获取共享变量的操作）</li></ul></li><li><p>sychronized与CAS的区别</p><ul><li>相同点：在多线程情况下，都可以保证共享数据的安全性</li><li>不同点：<ol><li>sychronized总是从最坏的角度出发，认为每次获取数据时，别的线程都有可能修改，所以在每次操作共享数据前，都会上锁（悲观锁）</li><li>CAS是从乐观的角度出发，假设每次获取数据时别的线程都不会修改，所以不上锁，只是在修改共享数据时再查看其他线程有没有修改共享数据，如果有就重新获取新的共享数据，如果没有就直接修改共享数据（乐观锁）</li></ol></li></ul></li></ol></li></ul><h3 id="12-并发工具类"><a href="#12-并发工具类" class="headerlink" title="12.并发工具类"></a>12.并发工具类</h3><ul><li><strong>HashTable</strong>类<ol><li>HashMap是线程不安全的，为了保证数据安全性可以使用线程安全的<strong>HashTable</strong>代替</li><li>HashTable效率比较低下</li><li>HashTable采用sychronized悲观锁，当有线程访问时会将整个集合加锁</li></ol></li><li><strong>ConcurrentHashMap</strong>类<ol><li>ConcurrentHashMap是线程安全的，效率较高</li><li>在JDK7和JDK8中实现的原理有区别</li><li>JDK7原理<ul><li>使用无参构造创建对象时，创建一个默认长度16，加载因子为0.75的数组，数组名为segment，并且这个数组无法扩容</li><li>再创建长度为2的小数组，将该小数组地址存入segment数组的0索引，segment其他索引均为null，这个小数组作为模板数组</li><li>在添加元素时会根据元素的哈希值计算出在segment的应存入位置的索引。如果为null则按照模板数组创建小数组，创建完毕后会进行二次哈希，计算出在小数组中应存入位置的索引，然后直接存入；如果不是null则直接找到小数组进行二次哈希，计算出在小数组中应存入位置的索引，如果小数组需要扩容则扩容到两倍，然后存入，如果小数组不需要扩容就查看该位置有无元素，如果没有元素直接存，如果有元素就调用equals()方法比较，相同的话不存，不相同就形成哈希桶结构</li><li>根据添加的原理，该集合实际上是创建了16个哈希表结构</li><li>保证线程安全的方式是，当线程对segment某个索引处的哈希表进行操作时对该索引处加锁，而其他索引则不加锁</li></ul></li><li>JDK8原理<ul><li>使用无参构造创建对象时并不会创建底层数组，而是在第一次添加数据时初始化长度为16，加载因子为0.75的数组</li><li>添加元素时计算应存入的索引，如果索引为null，则利用CAS算法将元素添加到此处；如果不为null，则利用volatile关键字获取当前位置最新的节点地址，将当前元素挂在它下面变成链表，当链表长度大于8时转为红黑树</li><li>保证数据安全的方式是对链表或者红黑树头节点加锁，配合悲观锁保证多线程操作集合时的安全性</li></ul></li></ol></li><li><strong>CountDownLatch</strong>类</li><li><strong>Semaphore</strong>类</li></ul><h2 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h2><h3 id="1-网络编程三要素"><a href="#1-网络编程三要素" class="headerlink" title="1.网络编程三要素"></a>1.网络编程三要素</h3><ul><li>IP地址：设备在网络中的唯一标识<ol><li>IPv4，32位的IP地址，常用点分十进制方便书写</li><li>IPv6，128位的IP地址，常用冒分十六进制方便书写</li><li>常用命令，在cmd中可以用 <code>ipcofig</code>查看本机IP地址，用 <code>ping IP地址/域名</code>可以检测当前与某个设备是否可以连通</li><li>特殊的IP地址：127.0.0.1称为回送地址又叫本地回环地址，可以代表本机IP地址，一般用作测试</li><li><strong>inetAddress</strong>类<ul><li>不提供构造方法，可以通过提供的一些静态方法获取一个对象，这些静态方法需要传入主机名或IP地址</li><li>常用方法有 <code>String getHostName()</code>和 <code>String getHostAddress()</code>分别获取主机名和IP地址</li></ul></li></ol></li><li>端口号：应用程序在设备中唯一标识<ol><li>两个字节表示的整数，范围时0~65535</li><li>其中0~1023之间的端口号用于知名网络服务或应用，自用的需要在1024以上</li><li>注意一个端口号只能被一个应用程序使用</li></ol></li><li>协议：数据在传输过程中遵守的规则<ol><li>UDP，用户数据报协议，面向无连接的通信协议，速度快一次最多发送64K的数据，数据不安全易丢失</li><li>TCP，传输控制协议，面向连接的通信协议，速度慢，没有大小限制，数据安全</li></ol></li></ul><h3 id="2-UDP通信程序"><a href="#2-UDP通信程序" class="headerlink" title="2.UDP通信程序"></a>2.UDP通信程序</h3><ul><li><p>发送数据步骤</p><ol><li><p>创建发送端<strong>DatagramSocket</strong>对象</p></li><li><p>创建数据并打包<strong>DatagramPacket</strong>对象</p></li><li><p>调用DatagramSocket对象的方法发送数据</p></li><li><p>释放资源</p></li><li><p>范例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//无参构造表示不指定端口，而是使用随机端口</span></span><br><span class="line">        <span class="type">DatagramSocket</span> <span class="variable">ds</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">data</span> <span class="operator">=</span> <span class="string">&quot;这是我发送的数据&quot;</span>;</span><br><span class="line">        <span class="type">byte</span>[] bytes = data.getBytes();</span><br><span class="line">        <span class="type">InetAddress</span> <span class="variable">address</span> <span class="operator">=</span> InetAddress.getByName(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//10000表示接收端的端口</span></span><br><span class="line">        <span class="type">DatagramPacket</span> <span class="variable">dp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(bytes,bytes.length,address,<span class="number">10000</span>);</span><br><span class="line"></span><br><span class="line">        ds.send(dp);</span><br><span class="line"></span><br><span class="line">        ds.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li><li><p>接受数据步骤</p><ol><li><p>创建接收端<strong>DatagramSocket</strong>对象</p></li><li><p>创建<strong>DatagramPacket</strong>对象接收数据</p></li><li><p>调用DategramSocket的方法将数据装入DatagramPacket对象</p></li><li><p>解析数据</p></li><li><p>释放资源</p></li><li><p>范例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.DatagramPacket;</span><br><span class="line"><span class="keyword">import</span> java.net.DatagramSocket;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.Charset;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Service</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//指定端口</span></span><br><span class="line">        <span class="type">DatagramSocket</span> <span class="variable">ds</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>(<span class="number">10000</span>);</span><br><span class="line">        <span class="comment">//接收数据</span></span><br><span class="line">        <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="type">DatagramPacket</span> <span class="variable">dp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(bytes,bytes.length);</span><br><span class="line">        ds.receive(dp);</span><br><span class="line"></span><br><span class="line">        <span class="type">byte</span>[] data = dp.getData();</span><br><span class="line">        System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(data,<span class="number">0</span>,dp.getLength()));</span><br><span class="line"></span><br><span class="line">        ds.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li><li><p>三种通信方式</p><ol><li><p>单播，一对一</p></li><li><p>组播，一对多</p><ul><li><p>组播地址是224.0.0.0<del>239.255.255.255，其中224.0.0.0</del>224.0.0.255是预留的不能使用，只能从224.0.1.0开始使用</p></li><li><p>组播发送端与单薄类似，但是发送的地址应该是<strong>组播地址</strong></p></li><li><p>组播接收端使用的是<strong>MulticastSocket</strong>对象而不是DatagramSocket</p></li><li><p>接收端需要将本机添加入组播中才能收到数据</p></li><li><p>范例</p><p>发送端：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client_</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">DatagramSocket</span> <span class="variable">ds</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;这是多播的数据&quot;</span>;</span><br><span class="line">        <span class="type">byte</span>[] bytes = s.getBytes();</span><br><span class="line">        <span class="type">InetAddress</span> <span class="variable">address</span> <span class="operator">=</span> InetAddress.getByName(<span class="string">&quot;224.0.1.0&quot;</span>);<span class="comment">//多播地址</span></span><br><span class="line"></span><br><span class="line">        <span class="type">DatagramPacket</span> <span class="variable">dp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(bytes,bytes.length,address,<span class="number">10000</span>);</span><br><span class="line"></span><br><span class="line">        ds.send(dp);</span><br><span class="line"></span><br><span class="line">        ds.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接收端：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.DatagramPacket;</span><br><span class="line"><span class="keyword">import</span> java.net.InetAddress;</span><br><span class="line"><span class="keyword">import</span> java.net.MulticastSocket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Service_</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">MulticastSocket</span> <span class="variable">ms</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MulticastSocket</span>(<span class="number">10000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">DatagramPacket</span> <span class="variable">dp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(<span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>],<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//把当前计算机绑定一个组播地址，表示添加到这一组</span></span><br><span class="line">        ms.joinGroup(InetAddress.getByName(<span class="string">&quot;224.0.1.0&quot;</span>));</span><br><span class="line">        ms.receive(dp);</span><br><span class="line"></span><br><span class="line">        <span class="type">byte</span>[] data = dp.getData();</span><br><span class="line">        System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(data,<span class="number">0</span>,dp.getLength()));</span><br><span class="line"></span><br><span class="line">        ms.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>广播，一对全部</p><ul><li>广播地址是255.255.255.255</li><li>广播的发送端与单播一样，只是将地址换成广播地址即可</li><li>广播的接收端和单播一样</li></ul></li></ol></li></ul><h3 id="3-TCP通信程序"><a href="#3-TCP通信程序" class="headerlink" title="3.TCP通信程序"></a>3.TCP通信程序</h3><ul><li><p>TCP通信协议是可靠的网络协议，，它在通信的两端各建立一个Socket对象，通信之前要<strong>保证连接已经建立</strong>，通过Socket产生IO流来进行网络通信</p></li><li><p>客户端发送数据步骤</p><ol><li>创建客户端<strong>Socket</strong>对象，与指定的服务端连接，<code>public Socket(String host,int port)</code></li><li>利用Socket对象获取输出流，<code>OutputStream getOutputStream()</code>，利用获取到的输出流对象的 <code>write()</code>方法写数据</li><li>释放资源，<code>void close()</code></li></ol></li><li><p>服务端接收数据步骤</p><ol><li>创建<strong>ServerSocket</strong>对象，<code>public ServerSocket(int port)</code></li><li>监听客户端连接，获取Socket对象，<code>Socket accept()</code></li><li>获取输入流，读数据，<code>InputStream getyInputStream()</code></li><li>释放资源，<code>void close()</code></li></ol></li><li><p>范例</p><p>客户端：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//创建Socket对象</span></span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">10001</span>);</span><br><span class="line">        <span class="comment">//获取输出流</span></span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> socket.getOutputStream();</span><br><span class="line">        <span class="comment">//写数据</span></span><br><span class="line">        outputStream.write(<span class="string">&quot;helloworld&quot;</span>.getBytes());</span><br><span class="line">        <span class="comment">//关闭资源</span></span><br><span class="line">        outputStream.close();</span><br><span class="line">        socket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>服务端：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Server</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//创建ServerSocket对象</span></span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">serverSocket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">10001</span>);</span><br><span class="line">        <span class="comment">//等待客户端连接</span></span><br><span class="line">        <span class="type">Socket</span> <span class="variable">accept</span> <span class="operator">=</span> serverSocket.accept();</span><br><span class="line">        <span class="comment">//获取输入流对象</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> accept.getInputStream();</span><br><span class="line">        <span class="comment">//开始读数据,当输入流没有数据时，read方法会阻塞，-1是当客户端关闭资源时发送过来的结束标记</span></span><br><span class="line">        <span class="type">int</span> b;</span><br><span class="line">        <span class="keyword">while</span>((b = inputStream.read()) != -<span class="number">1</span>)&#123;</span><br><span class="line">            System.out.print((<span class="type">char</span>)b);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//关闭资源</span></span><br><span class="line">        inputStream.close();</span><br><span class="line">        serverSocket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="4-文件传输案例"><a href="#4-文件传输案例" class="headerlink" title="4.文件传输案例"></a>4.文件传输案例</h3><ul><li><p>客户端</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">10001</span>);</span><br><span class="line">        <span class="comment">//本机的文件输入流</span></span><br><span class="line">        <span class="type">BufferedInputStream</span> <span class="variable">bis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;image.jpg&quot;</span>));</span><br><span class="line">        <span class="comment">//网络输出流</span></span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> socket.getOutputStream();</span><br><span class="line">        <span class="type">BufferedOutputStream</span> <span class="variable">bos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(os);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> b;</span><br><span class="line">        <span class="keyword">while</span>((b = bis.read()) != -<span class="number">1</span>)&#123;</span><br><span class="line">            bos.write(b);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//发送结束标记</span></span><br><span class="line">        socket.shutdownOutput();</span><br><span class="line">        <span class="comment">//接收服务端消息</span></span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(socket.getInputStream()));</span><br><span class="line">        String line;</span><br><span class="line">        <span class="keyword">while</span>((line = br.readLine()) != <span class="literal">null</span>)&#123;</span><br><span class="line">            System.out.println(line);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//关闭资源</span></span><br><span class="line">        bis.close();</span><br><span class="line">        br.close();</span><br><span class="line">        socket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>服务端</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Server</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">ss</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">10001</span>);</span><br><span class="line">        <span class="type">Socket</span> <span class="variable">accept</span> <span class="operator">=</span> ss.accept();</span><br><span class="line">        <span class="comment">//网络输入流</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> accept.getInputStream();</span><br><span class="line">        <span class="type">BufferedInputStream</span> <span class="variable">bis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(is);</span><br><span class="line">        <span class="comment">//本机输出流</span></span><br><span class="line">        <span class="type">BufferedOutputStream</span> <span class="variable">bos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;copy.jpg&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> b;</span><br><span class="line">        <span class="keyword">while</span> ((b = bis.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">            bos.write(b);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//给客户端发送消息</span></span><br><span class="line">        <span class="type">BufferedWriter</span> <span class="variable">bw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(accept.getOutputStream()));</span><br><span class="line">        bw.write(<span class="string">&quot;文件上传成功&quot;</span>);</span><br><span class="line">        bw.newLine();</span><br><span class="line">        bw.flush();</span><br><span class="line"></span><br><span class="line">        bos.close();</span><br><span class="line">        accept.close();</span><br><span class="line"></span><br><span class="line">        ss.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用while循环，UUID，多线程和线程池来<strong>优化服务端</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">import</span> java.util.UUID;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ArrayBlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ThreadPoolExecutor;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Server</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">ss</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">10001</span>);</span><br><span class="line">        <span class="type">ThreadPoolExecutor</span> <span class="variable">tpe</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line">                <span class="number">3</span>,</span><br><span class="line">                <span class="number">10</span>,</span><br><span class="line">                <span class="number">60</span>,</span><br><span class="line">                TimeUnit.SECONDS,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">5</span>),</span><br><span class="line">                Executors.defaultThreadFactory(),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.AbortPolicy()</span><br><span class="line">        );</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="type">Socket</span> <span class="variable">accept</span> <span class="operator">=</span> ss.accept();</span><br><span class="line">            <span class="type">ThreadSocket</span> <span class="variable">ts</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadSocket</span>(accept);</span><br><span class="line">            tpe.submit(ts);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadSocket</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Socket accept;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ThreadSocket</span><span class="params">(Socket accept)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.accept = accept;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">BufferedOutputStream</span> <span class="variable">bos</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> accept.getInputStream();</span><br><span class="line">            <span class="type">BufferedInputStream</span> <span class="variable">bis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(is);</span><br><span class="line">            <span class="comment">//UUID确保每次文件名是随机的</span></span><br><span class="line">            bos = <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(UUID.randomUUID().toString() + <span class="string">&quot;.jpg&quot;</span>));</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> b;</span><br><span class="line">            <span class="keyword">while</span> ((b = bis.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">                bos.write(b);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">BufferedWriter</span> <span class="variable">bw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(accept.getOutputStream()));</span><br><span class="line">            bw.write(<span class="string">&quot;文件上传成功&quot;</span>);</span><br><span class="line">            bw.newLine();</span><br><span class="line">            bw.flush();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(bos != <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    bos.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(accept != <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    accept.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="类加载器-amp-反射"><a href="#类加载器-amp-反射" class="headerlink" title="类加载器&amp;反射"></a>类加载器&amp;反射</h2><h3 id="1-类加载器"><a href="#1-类加载器" class="headerlink" title="1.类加载器"></a>1.类加载器</h3><ul><li><p>类加载器负责将.class文件（存储的物理文件）加载到内存中</p></li><li><p>类加载的时机</p><ol><li>创建类的实例</li><li>调用类的类方法</li><li>访问类或接口的类变量，或者为该类变量赋值</li><li>使用反射方式来强制创建某个类或接口对应的java.lang.Class对象</li><li>初始化某个类的子类</li><li>直接使用java.exe命令来运行某个主类</li></ol></li><li><p>类加载的过程</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">graph LR;</span><br><span class="line">A(加载) --&gt; B(验证)</span><br><span class="line">B --&gt; C(准备)</span><br><span class="line">C --&gt; D(解析)</span><br><span class="line">D --&gt; E(初始化)</span><br></pre></td></tr></table></figure><ul><li>其中验证、准备、解析这三步属于<strong>链接</strong>的过程</li><li>加载<ol><li>通过类的全限定名来获取定义此类的二进制字节流</li><li>将这个字节流所代表的静态存储结构转化为运行时数据结构（加载到内存中）</li><li>在内存中生成一个代表这个类的java.lang.Class对象（任何类被使用时，系统都会为它建立一个java.lang.Class对象）</li></ol></li><li>链接<ol><li>验证：确保Class文件字节流中包含的信息符合虚拟机要求，不会危害虚拟机自身安全</li><li>准备：为类的<strong>类变量</strong>分配内存，并设置<strong>默认</strong>初始化值</li><li>解析：将二进制数据流中的<strong>符号引用</strong>替换为<strong>直接引用</strong>，意思是找到需要用到的类</li></ol></li><li>初始化：根据程序员通过程序制定的主观计划去初始化<strong>类变量</strong>和其他资源（静态变量赋值和初始化其他资源）</li></ul></li><li><p>类加载器的分类</p><ul><li>启动类加载器（Bootstrap ClassLoader）：虚拟机内置的类加载器</li><li>平台类加载器（Platform ClassLoader）：负责加载JDK中一些特殊的模块</li><li>系统类加载器（System ClassLoader）：负责加载用户类路径上所指定的类库</li></ul></li><li><p>双亲委派模型</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">graph BT;</span><br><span class="line">A(&quot;系统类加载器（System ClassLoader）&quot;) --&gt; B(&quot;平台类加载器（Platform ClassLoader）&quot;)</span><br><span class="line">B --&gt; C(&quot;启动类加载器（Bootstrap ClassLoader）&quot;)</span><br><span class="line">C --&gt; B</span><br><span class="line">B --&gt; A</span><br></pre></td></tr></table></figure><ul><li>类加载器收到加载任务时会将加载任务逐层向上传递给父类加载器，最终到达顶层的启动类加载器</li><li>当启动类加载器不能完成加载任务时，再委托给下层的子类加载器，最终完成类的加载</li><li>ClassLoader对象的getParent()方法可以获取父类加载器</li></ul></li><li><p>常用方法</p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>public static ClassLoader getSystemClassLoader()</td><td>获取系统类加载器</td></tr><tr><td>public InputStream getResourceAsStream(String name)</td><td>加载某一个资源文件</td></tr></tbody></table></li></ul><h3 id="2-反射"><a href="#2-反射" class="headerlink" title="2.反射"></a>2.反射</h3><ul><li><p>概述</p><ol><li>在运行状态中，对于任何一个类都能知道这个类的所有属性和方法</li><li>对于任何一个对象，都能够调用它的任意方法和属性</li><li>这种<strong>动态</strong>获取信息以及<strong>动态</strong>调用对象方法的功能称为Java语言的反射机制</li></ol></li><li><p>获取Class对象</p><ol><li>通过 <code>Class.forName(全类名)</code>获取，该方法是Class类的静态方法</li><li>通过 <code>类名.class</code>获取</li><li>通过 <code>对象.getClass()</code>获取</li><li>注意：这三种方式获取的Class对象是同一个Class对象，一个类在JVM中只会有一个Class对象</li></ol></li><li><p>反射获取构造方法</p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>Constructor&lt;?&gt;[] getConstructors()</td><td>返回所有<strong>公共</strong>构造方法对象的数组</td></tr><tr><td>Constructor&lt;?&gt;[] getDeclaredConstructors()</td><td>返回所有构造方法对象的数组（包括私有）</td></tr><tr><td>Constructor&lt;?&gt; getConstructor(Class&lt;?&gt;…parameterTypes)</td><td>获取单个、公共的构造方法对象，如果是无参构造则该方法参数留空，如果是有参则该方法参数是参数类型的Class对象</td></tr><tr><td>Constructor&lt;?&gt; getDeclaredConstructor(Class&lt;?&gt;…parameterTypes)</td><td>获取单个、公共或私有的构造方法对象，如果是无参构造则该方法参数留空，如果是有参则该方法参数是参数类型的Class对象</td></tr></tbody></table></li><li><p>由获取的构造方法对象创建对象</p><ol><li><p>可以利用构造方法类<strong>Constructor</strong>中的 <code>T newInstance(Object...initargs)</code>方法来创建对象</p></li><li><p>如果该构造方法是<strong>私有</strong>的构造方法，则创建对象之前需要使用Constructor类中的 <code>void setAccessible(boolean b)</code>方法临时取消访问检查</p></li><li><p>实例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InvocationTargetException, InstantiationException, IllegalAccessException, NoSuchMethodException, ClassNotFoundException &#123;</span><br><span class="line">        <span class="comment">//反射获取Class对象</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;Student&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取公共的构造方法</span></span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">publicConstructor</span> <span class="operator">=</span> clazz.getConstructor(String.class, <span class="type">int</span>.class);</span><br><span class="line">        <span class="comment">//由公共构造方法创建对象</span></span><br><span class="line">        <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> (Student) publicConstructor.newInstance(<span class="string">&quot;廖向前&quot;</span>, <span class="number">21</span>);</span><br><span class="line">        System.out.println(student);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取私有的构造方法</span></span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">privateConstructor</span> <span class="operator">=</span> clazz.getDeclaredConstructor(String.class);</span><br><span class="line">        <span class="comment">//临时取消访问检查</span></span><br><span class="line">        privateConstructor.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="comment">//由私有的构造方法创建对象</span></span><br><span class="line">        <span class="type">Student</span> <span class="variable">student1</span> <span class="operator">=</span> (Student) privateConstructor.newInstance(<span class="string">&quot;廖向前&quot;</span>);</span><br><span class="line">        System.out.println(student1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Student</span><span class="params">(String name)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;私有的构造方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name,<span class="type">int</span> age)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;公共的构造方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li><li><p>反射获取成员变量</p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>Field[] getFields()</td><td>返回所有公共成员变量对象的数组</td></tr><tr><td>Field[] getDeclaredFields()</td><td>返回所有成员变量对象的数组</td></tr><tr><td>Field getField(String name)</td><td>根据变量名获取一个公共成员变量对象</td></tr><tr><td>Field getDeclaredField(String name)</td><td>根据变量名获取一个成员变量对象</td></tr></tbody></table></li><li><p>由Field对象操作成员变量</p><ol><li><code>void set(Object o,Object v)</code>，设置某个成员变量的值，第一个参数是需要设置成员变量的对象，第二个参数是成员变量的值</li><li><code>Object get(Object o)</code>，获取某个对象的当前成员变量的值</li><li>注意，如果成员变量是私有的，在使用get和set方法时也需要使用setAccessible()方法暂时取消访问检查</li></ol></li><li><p>反射获取成员方法</p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>Method[] getMethods()</td><td>获取所有公共成员方法对象数组</td></tr><tr><td>Method[] getDeclaredMethods()</td><td>获取所有成员方法对象数组</td></tr><tr><td>Method getMethod(String name,Class&lt;?&gt;…parameterTypes)</td><td>获取一个公共的成员方法对象，第一个参数是方法名，第二个参数是方法的参数的Class对象</td></tr><tr><td>Method getDeclaredMethod(String name,Class&lt;?&gt;…parameterTypes)</td><td>获取一个成员方法对象，第一个参数是方法名，第二个参数是方法的参数的Class对象</td></tr></tbody></table></li><li><p>由Method对象操作成员方法</p><ul><li>使用 <code>Object invoke(Object o,Object...args)</code>方法可以运行成员方法</li><li>第一个参数是指调用该方法的对象</li><li>第二个参数是指该方法的参数</li><li>返回值Object是成员方法的返回值，如果没有则可以不用接收</li></ul></li></ul><h2 id="枚举-amp-注解"><a href="#枚举-amp-注解" class="headerlink" title="枚举&amp;注解"></a>枚举&amp;注解</h2><h3 id="1-枚举"><a href="#1-枚举" class="headerlink" title="1.枚举"></a>1.枚举</h3><ul><li><p>概述：枚举是一种特殊的类，表示一组常量</p></li><li><p>定义格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> 枚举类名&#123;</span><br><span class="line">    枚举项<span class="number">1</span>,枚举项<span class="number">2</span>,枚举项<span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>特点</p><ol><li>所有枚举类都是Enum类的子类，所以枚举类可以使用Enum类中的方法</li><li>可以通过<strong>枚举类名.枚举项</strong>去访问指定的枚举项</li><li>每一个枚举项实际上是是该枚举类的一个对象</li><li>枚举项可以有构造方法，但必须是<strong>private</strong>修饰，如果不提供无参构造，则必须在枚举项中使用有参构造</li><li>枚举类还可以有成员变量，成员方法，抽象方法，但是抽象方法必须在枚举项中重写</li><li>枚举类第一行必须是枚举项</li></ol></li><li><p>常用方法</p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>String name()</td><td>获取枚举项名称</td></tr><tr><td>int ordinal()</td><td>获取枚举项索引</td></tr><tr><td>int compareTo(E o)</td><td>返回与其他枚举项索引的差值</td></tr><tr><td>String toString()</td><td>返回枚举项名称</td></tr><tr><td>static<code>&lt;T&gt;</code> T valueOf(Class<code>&lt;T&gt;</code> type,String name)</td><td>获取指定枚举类中指定名字的枚举项</td></tr><tr><td>T[] values()</td><td>获取所有的枚举项</td></tr></tbody></table></li></ul><h3 id="2-注解"><a href="#2-注解" class="headerlink" title="2.注解"></a>2.注解</h3><ul><li><p>注解作用是：对程序进行标注和解释</p></li><li><p>三个注解</p><table><thead><tr><th>注解</th><th>说明</th></tr></thead><tbody><tr><td>@Override</td><td>描述子类重写父类方法</td></tr><tr><td>@Deprecated</td><td>描述方法过时</td></tr><tr><td>@SuppressWarnings</td><td>压制警告</td></tr></tbody></table></li><li><p>注解和注释的区别</p><ol><li>注释是给程序员看</li><li>注解是给编译器看（让虚拟机看到程序中的注解，注解代表程序的一些特殊功能）</li></ol></li><li><p>自定义注解</p><ul><li><p>格式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> 注解名&#123;</span><br><span class="line">    <span class="keyword">public</span> 元素类型 元素名() <span class="keyword">default</span> 默认值;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>元素前的public修饰是默认的可以省略，但是不能使用其他的修饰</p></li><li><p>default是用来设置默认值的，在使用的时候如果不指定元素的值则默认是设置的这个默认值</p></li><li><p>元素类型可以使用如下</p><p><code>基本数据类型</code></p><p><code>String类型</code></p><p><code>Class类型</code></p><p><code>注解类型</code></p><p><code>枚举类型</code></p><p><code>以上类型的一维数组</code></p></li></ul></li><li><p>元注解</p><ol><li><p>元注解是<strong>修饰注解</strong>的注解，JDK提供了一些元注解使用</p></li><li><p>常用元注解</p><ul><li><p><code>@Target</code>，用于定义被修饰的注解可以应用于代码中的哪些位置，如</p><ol><li><p>类或接口：<code>ElementType.TYPE</code></p></li><li><p>成员变量：<code>ElementType.FIELD</code></p></li><li><p>成员方法：<code>ElementType.METHOD</code></p></li><li><p>构造方法：<code>ElementType.CONSTRUCTOR</code></p></li><li><p>方法参数：<code>ElementType.PARAMETER</code></p></li><li><p>范例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Demo&#123;&#125;<span class="comment">//说明Demo注解可以用在类前面</span></span><br></pre></td></tr></table></figure></li></ol></li><li><p><code>@Retention</code>，用于定义注解的生命周期</p><ol><li>仅编译期：<code>RetentionPolicty.SOURCE</code></li><li>仅class文件：<code>RetentionPolicty.CLASS</code></li><li>运行期：<code>RetentionPolicty.RUNTIME</code></li><li>通常我们自定义的注解是在运行期使用的，所以自定义注解时会使用这个元注解修饰自定义注解，并设置为RetentionPolicty.RUNTIME</li></ol></li></ul></li></ol></li><li><p>注解的使用</p><ol><li><p>格式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方式1，给指定的元素赋值，没有赋值的将使用默认值</span></span><br><span class="line">@注解名(元素<span class="number">1</span> = 属性值,元素<span class="number">2</span> = 属性值)</span><br><span class="line"><span class="comment">//方式2，给元素名为value的元素赋值，value是特殊的一个元素，如果自定义注解中不给出该元素而使用这种方式赋值会报错</span></span><br><span class="line">@注解名(属性值)</span><br><span class="line"><span class="comment">//方式3，全部元素使用默认值</span></span><br><span class="line">@注解名</span><br></pre></td></tr></table></figure></li><li><p>判断某个注解是否存在于某个 <code>Class</code>、<code>Field</code>、<code>Method</code>、<code>Constructor</code></p><ul><li>Class.isAnnotationPresent(Class)</li><li>Field.isAnnotationPresent(Class)</li><li>Method.isAnnotationPresent(Class)</li><li>Constructor.isAnnotationPresent(Class)</li><li>注意：方法的参数是需要判断的注解的Class对象，返回值类型是boolean</li></ul></li></ol></li></ul><h2 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h2><ul><li><p>使用Junit来进行单元测试</p></li><li><p>Junit提供注解来识别测试方法</p></li><li><p>可以查看允许情况</p></li><li><p>基本使用步骤</p><ol><li>将Junit的jar包导入项目</li><li>测试的方法必须是<strong>公共的、无参数、无返回值的非静态方法</strong></li><li>在需要测试的方法上方用**@Test**注解标注该方法是个测试方法</li><li>开始测试</li></ol></li><li><p>常用的三个注解</p><table><thead><tr><th>注解</th><th>说明</th></tr></thead><tbody><tr><td>@Test</td><td>表示测试该方法</td></tr><tr><td>@Before</td><td>表示在测试的方法前运行</td></tr><tr><td>@After</td><td>表示在测试的方法后运行</td></tr></tbody></table></li></ul>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java复习笔记1</title>
      <link href="/2022/12/01/java%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A0/"/>
      <url>/2022/12/01/java%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="java基础复习"><a href="#java基础复习" class="headerlink" title="java基础复习"></a><strong>java基础复习</strong></h1><p><a href="https://www.developers.pub/wiki/1002310/1012017">开发者客栈-帮助开发者面试的平台-顽强网络 (developers.pub)</a><code>&lt;br /&gt;</code><a href="http://c.biancheng.net/java/10/">http://c.biancheng.net/java/10/</a><code>&lt;br /&gt;</code><strong>Java 语言是一种分布式的面向对象语言，具有面向对象、平台无关性、简单性、解释执行、多线程、安全性等很多特点</strong><br><code>&lt;a name=&quot;bXuoh&quot;&gt;&lt;/a&gt;</code></p><h2 id="1-面向对象"><a href="#1-面向对象" class="headerlink" title="1. 面向对象"></a>1. 面向对象</h2><p>Java 是一种面向对象的语言，它对对象中的类、对象、继承、封装、多态、接口、包等均有很好的支持。为了简单起见，Java 只支持类之间的单继承，但是可以使用接口来实现多继承。<br><code>&lt;a name=&quot;DcKJf&quot;&gt;&lt;/a&gt;</code></p><h2 id="2-多线程"><a href="#2-多线程" class="headerlink" title="2. 多线程"></a>2. 多线程</h2><p>Java 语言是多线程的，这也是 Java 语言的一大特性，它必须由 Thread 类和它的子类来创建。Java 支持多个线程同时执行，并提供多线程之间的同步机制。任何一个线程都有自己的 run() 方法，要执行的方法就写在 run() 方法体内。<br><code>&lt;a name=&quot;hKtkN&quot;&gt;&lt;/a&gt;</code></p><h2 id="3-java中jvm-jre-jdk三者有什么区别"><a href="#3-java中jvm-jre-jdk三者有什么区别" class="headerlink" title="3.java中jvm ,jre,jdk三者有什么区别"></a>3.java中jvm ,jre,jdk三者有什么区别</h2><p><a href="http://c.biancheng.net/java/">Java</a> 语言的开发运行，也离不开 Java 语言的运行环境 JRE。没有 JRE 的支持，Java 语言便无法运行。当然，如果还想编译 Java 程序，搞搞小开发的话，JRE 是明显不够了，这时候就需要 JDK。  <code>&lt;br /&gt;</code>其实啊，JDK 就是 JRE 加上一些常用工具组成的。JDK 不仅能运行已经被编译好了的 Java 程序，还能支持我们编译 Java 程序（JDK&#x3D;JER+各种工具）。</p><ul><li>JDK（Java Development Kid，Java 开发开源工具包），是针对 Java 开发人员的产品，是整个 Java 的核心，包括了 Java 运行环境 JRE、Java 工具和 Java 基础类库。</li><li>JRE（Java Runtime Environment，Java 运行环境）是运行 JAVA 程序所必须的环境的集合，包含 JVM 标准实现及 Java 核心类库。</li><li>JVM（Java Virtual Machine，Java 虚拟机）是整个 Java 实现跨平台的最核心的部分，能够运行以 Java 语言写作的软件程序。</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2022/png/33764834/1668330128204-7358e5f4-8f27-44ee-976b-53a0151c0af8.png#averageHue=%2392bf77&crop=0&crop=0&crop=1&crop=1&id=cxFcI&originHeight=346&originWidth=411&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><code>&lt;br /&gt;</code><img src="https://cdn.nlark.com/yuque/0/2022/png/33764834/1668330128666-9d7478b5-376a-49c6-9fb2-65fc65477ca8.png#averageHue=%2399a0eb&crop=0&crop=0&crop=1&crop=1&id=lD9Of&originHeight=275&originWidth=500&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><ul><li>JDK&#x3D;JRE+多种Java开发工具</li><li>JRE&#x3D;JVM+各种类库</li><li>这三者的关系是一层层的嵌套关系。JDK&gt;JRE&gt;JVM<br><code>&lt;a name=&quot;kd8EI&quot;&gt;&lt;/a&gt;</code></li></ul><h2 id="4-java初学者容易犯的几个问题"><a href="#4-java初学者容易犯的几个问题" class="headerlink" title="4.java初学者容易犯的几个问题"></a>4.java初学者容易犯的几个问题</h2><p><code>&lt;a name=&quot;XOnhn&quot;&gt;&lt;/a&gt;</code></p><h4 id="1）大小写问题"><a href="#1）大小写问题" class="headerlink" title="1）大小写问题"></a>1）大小写问题</h4><p><code>&lt;a name=&quot;1VdwB&quot;&gt;&lt;/a&gt;</code></p><h4 id="2）路径里包含空格的问题"><a href="#2）路径里包含空格的问题" class="headerlink" title="2）路径里包含空格的问题"></a>2）路径里包含空格的问题</h4><p><code>&lt;a name=&quot;O9tKO&quot;&gt;&lt;/a&gt;</code></p><h4 id="3）main-方法的问题"><a href="#3）main-方法的问题" class="headerlink" title="3）main 方法的问题"></a>3）main 方法的问题</h4><p>如果需要用 java 命令直接运行一个 Java 类，这个 Java 类必须包含 main 方法，这个 main 方法必须使用 public 和 static 来修饰，必须使用 void 声明该方法的返回值，而且该方法的参数类型只能是一个字符串数组，而不能是其他形式的参数。对于这个 main 方法而言，前面的 public 和 static 修饰符的位置可以互换，但其他部分则是固定的。  <code>&lt;br /&gt;</code>定义 main 方法时，不要写成 Main 方法，如果不小心把方法名的首字母写成了大写，编译时不会出现任何问题，但运行该程序时将给出如图 2 的错误提示：<code>&lt;br /&gt;</code>这个错误提示找不到 main 方法，因为 Java 虚拟机只会选择从 main 方法开始执行。对于 Main 方法，Java 虚拟机会把该方法当成一个普通方法，而不是程序的入口。  <code>&lt;br /&gt;</code>main 方法里可以放置程序员需要执行的可执行性语句，例如 System.out.println(“Hello Java!”)，这行语句是 Java 里的输出语句，用于向控制台输岀“Hello Java!”这个字符串内容，输出结束后还输出一个换行符。  <code>&lt;br /&gt;</code>在 Java 程序里执行输岀有两种简单的方式：System.out.print(需要输出的内容) 和 System.out.println (需要输出的内容)，其中前者在输出结束后不会换行，而后者在输出结束后会换行。后面会有关于这两个方法更详细的解释，此处读者只能把这两个方法先记下来。<br><code>&lt;a name=&quot;VgQOB&quot;&gt;&lt;/a&gt;</code></p><h2 id="5-String、StringBuffer和StringBuilder类的区别"><a href="#5-String、StringBuffer和StringBuilder类的区别" class="headerlink" title="5.String、StringBuffer和StringBuilder类的区别"></a>5.String、StringBuffer和StringBuilder类的区别</h2><p>在 <a href="http://c.biancheng.net/java/">Java</a> 中字符串属于对象，Java 提供了 String 类来创建和操作字符串。String 类是不可变类，即一旦一个 String 对象被创建以后，包含在这个对象中的字符序列是不可改变的，直至这个对象被销毁。<code>&lt;br /&gt;</code>StringBuilder 类是 JDK 1.5 新增的类，它也代表可变字符串对象。实际上，StringBuilder 和 StringBuffer 功能基本相似，方法也差不多。不同的是，StringBuffer 是线程安全的，而 StringBuilder 则没有实现线程安全功能，所以性能略高。因此在通常情况下，如果需要创建一个内容可变的字符串对象，则应该优先考虑使用 StringBuilder 类。<br><code>&lt;a name=&quot;InBNA&quot;&gt;&lt;/a&gt;</code></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>String 是 Java 中基础且重要的类，被声明为 final class，是不可变字符串。因为它的不可变性，所以拼接字符串时候会产生很多无用的中间对象，如果频繁的进行这样的操作对性能有所影响。  <code>&lt;br /&gt;</code>StringBuffer 就是为了解决大量拼接字符串时产生很多中间对象问题而提供的一个类。它提供了 append 和 add 方法，可以将字符串添加到已有序列的末尾或指定位置，它的本质是一个线程安全的可修改的字符序列。  <code>&lt;br /&gt;</code>在很多情况下我们的字符串拼接操作不需要线程安全，所以 StringBuilder 登场了。StringBuilder 是 JDK1.5 发布的，它和 StringBuffer 本质上没什么区别，就是去掉了保证线程安全的那部分，减少了开销。<br><code>&lt;a name=&quot;aR8kQ&quot;&gt;&lt;/a&gt;</code></p><h4 id="线程安全："><a href="#线程安全：" class="headerlink" title="线程安全："></a>线程安全：</h4><p>StringBuffer：线程安全  <code>&lt;br /&gt;</code>StringBuilder：线程不安全<br><code>&lt;a name=&quot;T9tnt&quot;&gt;&lt;/a&gt;</code></p><h4 id="速度："><a href="#速度：" class="headerlink" title="速度："></a>速度：</h4><p>一般情况下，速度从快到慢为 StringBuilder &gt; StringBuffer &gt; String，当然这是相对的，不是绝对的。<br><code>&lt;a name=&quot;gdxSZ&quot;&gt;&lt;/a&gt;</code></p><h4 id="使用环境："><a href="#使用环境：" class="headerlink" title="使用环境："></a>使用环境：</h4><p>操作少量的数据使用 String。  <code>&lt;br /&gt;</code>单线程操作大量数据使用 StringBuilder。  <code>&lt;br /&gt;</code>多线程操作大量数据使用 StringBuffer。<code>&lt;br /&gt;</code>Java正则表达式详解<code>&lt;br /&gt;</code>正则表达式是一个强大的字符串处理工具，可以对字符串进行查找、提取、分割、替换等操作，是一种可以用于模式匹配和替换的规范。一个正则表达式就是由普通的字符（如字符 a~z）以及特殊字符（元字符）组成的文字模式，它用以描述在查找文字主体时待匹配的一个或多个字符串<code>&lt;br /&gt;</code>String 类里也提供了如下几个特殊的方法。</p><ul><li>boolean matches(String regex)：判断该字符串是否匹配指定的正则表达式。</li><li>String replaceAll(String regex, String replacement)：将该字符串中所有匹配 regex 的子串替换成 replacement。</li><li>String replaceFirst(String regex, String replacement)：将该字符串中第一个匹配 regex 的子串替换成 replacement。</li><li>String[] split(String regex)：以 regex 作为分隔符，把该字符串分割成多个子串。</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2022/png/33764834/1668330129341-57e584d0-eb34-42c9-985e-9511847b3e08.png#averageHue=%23f8f7f6&crop=0&crop=0&crop=1&crop=1&id=eQYRJ&originHeight=894&originWidth=1156&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><code>&lt;br /&gt;</code>如果需要匹配这些特殊字符，就必须首先将这些字符转义，也就是在前面添加一个反斜线&lt;br &#x2F;&gt;<img src="https://cdn.nlark.com/yuque/0/2022/png/33764834/1668330129792-e308d408-6618-4c8e-ac4b-ee5f41587e3c.png#averageHue=%23f3f2f1&crop=0&crop=0&crop=1&crop=1&id=euFcQ&originHeight=880&originWidth=1226&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><code>&lt;br /&gt;</code><img src="https://cdn.nlark.com/yuque/0/2022/png/33764834/1668330130272-4ae2f1c7-fad4-40b7-ad4b-25b9aafa8cbe.png#averageHue=%23f6f6f5&crop=0&crop=0&crop=1&crop=1&id=iturN&originHeight=611&originWidth=1160&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><code>&lt;br /&gt;</code>Math的方法<code>&lt;br /&gt;</code><img src="https://cdn.nlark.com/yuque/0/2022/png/33764834/1668330130845-13e43d91-6192-4892-9405-e6476266816b.png#averageHue=%23f7f6f5&crop=0&crop=0&crop=1&crop=1&id=C8dFL&originHeight=971&originWidth=1115&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><code>&lt;br /&gt;</code><img src="https://cdn.nlark.com/yuque/0/2022/png/33764834/1668330131357-19465d99-5c64-428a-803e-356a338e61e3.png#averageHue=%23f7f6f6&crop=0&crop=0&crop=1&crop=1&id=fC2ZP&originHeight=682&originWidth=1604&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><code>&lt;br /&gt;</code><img src="https://cdn.nlark.com/yuque/0/2022/png/33764834/1668330131733-ab6da237-7e6a-44f2-ae65-14413e4800cd.png#averageHue=%23f6f5f4&crop=0&crop=0&crop=1&crop=1&id=GzLWQ&originHeight=850&originWidth=1591&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br><code>&lt;a name=&quot;sFidm&quot;&gt;&lt;/a&gt;</code></p><h2 id="6-Java生成随机数（random-和Random类）"><a href="#6-Java生成随机数（random-和Random类）" class="headerlink" title="6.Java生成随机数（random()和Random类）"></a>6.Java生成随机数（random()和Random类）</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/33764834/1668330132385-c995f1d2-e4c9-443b-bdd3-89f22e5dc396.png#averageHue=%23f4f3f2&crop=0&crop=0&crop=1&crop=1&id=vG2qS&originHeight=853&originWidth=1305&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br><code>&lt;a name=&quot;WwmUn&quot;&gt;&lt;/a&gt;</code></p><h2 id="7-Java数字格式化"><a href="#7-Java数字格式化" class="headerlink" title="7.Java数字格式化"></a>7.Java数字格式化</h2><p><code>&lt;a name=&quot;pwkqM&quot;&gt;&lt;/a&gt;</code></p><h3 id="数字的格式在解决实际问题时使用非常普遍，这时可以使用-DedmalFormat-类对结果进行格式化处理"><a href="#数字的格式在解决实际问题时使用非常普遍，这时可以使用-DedmalFormat-类对结果进行格式化处理" class="headerlink" title="数字的格式在解决实际问题时使用非常普遍，这时可以使用 DedmalFormat 类对结果进行格式化处理"></a>数字的格式在解决实际问题时使用非常普遍，这时可以使用 DedmalFormat 类对结果进行格式化处理</h3><p><img src="https://cdn.nlark.com/yuque/0/2022/png/33764834/1668330132773-03067d3d-21f6-4b14-80f9-3cdd4d68d2e7.png#averageHue=%23f7f6f5&crop=0&crop=0&crop=1&crop=1&id=T9hT0&originHeight=715&originWidth=1233&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br><code>&lt;a name=&quot;wLude&quot;&gt;&lt;/a&gt;</code></p><h2 id="8-数组的总结"><a href="#8-数组的总结" class="headerlink" title="8.数组的总结"></a>8.数组的总结</h2><p><code>&lt;a name=&quot;O48LM&quot;&gt;&lt;/a&gt;</code></p><h3 id="数组操作"><a href="#数组操作" class="headerlink" title="数组操作"></a>数组操作</h3><p><code>&lt;a name=&quot;KyPW6&quot;&gt;&lt;/a&gt;</code></p><h4 id="1-比较数组"><a href="#1-比较数组" class="headerlink" title="1. 比较数组"></a>1. 比较数组</h4><p>比较数组元素的个数和对应位置的元素是否相等。<code>&lt;br /&gt;</code>Arrays.equals(arrayA, arrayB);<code>&lt;br /&gt;</code>arrayA 是用于比较的第一个数组，arrayB 是用于比较的第二个数组。<br><code>&lt;a name=&quot;Utxlm&quot;&gt;&lt;/a&gt;</code></p><h4 id="2-填充数组"><a href="#2-填充数组" class="headerlink" title="2. 填充数组"></a>2. 填充数组</h4><p>在指定位置进行数值填充。<code>&lt;br /&gt;</code>Arrays.fill(array,value);<code>&lt;br /&gt;</code>array 表示数组，value 表示填充的值。只能使用同一个数值进行填充。<br><code>&lt;a name=&quot;7ynyt&quot;&gt;&lt;/a&gt;</code></p><h4 id="3-数组查找"><a href="#3-数组查找" class="headerlink" title="3. 数组查找"></a>3. 数组查找</h4><p>从数组中查询指定位置的元素，或者查询某元素在指定数组中的位置，语法格式如下。  <code>&lt;br /&gt;</code>binarySearch(Object[] a,Object key);<code>&lt;br /&gt;</code>a 表示要搜索的数组，key 表示要搜索的值。  <code>&lt;br /&gt;</code>在数组中指定范围内查找，语法格式如下。<code>&lt;br /&gt;</code>binarySearch(Object[] a,int fromIndex,int toIndex,Object key);<code>&lt;br /&gt;</code>a 表示要进行查找的数组，fromIndex 指定范围的开始处索引（包含开始处），toIndex 指定范围的结束处索引（不包含结束处），key 表示要搜索的元素。<br><code>&lt;a name=&quot;bakDn&quot;&gt;&lt;/a&gt;</code></p><h4 id="4-复制数组"><a href="#4-复制数组" class="headerlink" title="4. 复制数组"></a>4. 复制数组</h4><p><code>&lt;a name=&quot;tuqBh&quot;&gt;&lt;/a&gt;</code></p><h4 id="1-copyOf"><a href="#1-copyOf" class="headerlink" title="1) copyOf()"></a>1) copyOf()</h4><p>Arrays.copyOf(dataType[] srcArray,int length);<code>&lt;br /&gt;</code>srcArray 表示要进行复制的数组，length 表示复制后的新数组的长度<br><code>&lt;a name=&quot;Boj4k&quot;&gt;&lt;/a&gt;</code></p><h4 id="2-CopyOfRange"><a href="#2-CopyOfRange" class="headerlink" title="2) CopyOfRange()"></a>2) CopyOfRange()</h4><p>Arrays.copyOfRange(dataType[] srcArray,int startIndex,int endIndex)<code>&lt;br /&gt;</code>srcArray 表示原数组，startIndex 表示开始复制的起始索引，endIndex 表示终止索引。<br><code>&lt;a name=&quot;65umr&quot;&gt;&lt;/a&gt;</code></p><h4 id="3-arraycopy"><a href="#3-arraycopy" class="headerlink" title="3) arraycopy()"></a>3) arraycopy()</h4><p>System.arraycopy(dataType[] srcArray,int srcIndex,int destArray,int destIndex,int length)<code>&lt;br /&gt;</code>srcArray 表示原数组，srcIndex 表示源数组中的起始索引，destArray 表示目标数组，destIndex 表示目标数组中的起始索引，length 表示要复制的数组长度。<br><code>&lt;a name=&quot;HPDWo&quot;&gt;&lt;/a&gt;</code></p><h4 id="4-clone"><a href="#4-clone" class="headerlink" title="4) clone()"></a>4) clone()</h4><p>array_name.clone()<br><code>&lt;a name=&quot;CZFk0&quot;&gt;&lt;/a&gt;</code></p><h3 id="数组排序"><a href="#数组排序" class="headerlink" title="数组排序"></a>数组排序</h3><p><code>&lt;a name=&quot;JCEYd&quot;&gt;&lt;/a&gt;</code></p><h4 id="Java-数组中有-5-种常见排序方法，分别是："><a href="#Java-数组中有-5-种常见排序方法，分别是：" class="headerlink" title="Java 数组中有 5 种常见排序方法，分别是："></a>Java 数组中有 5 种常见排序方法，分别是：</h4><ol><li>Arrays.sort()</li><li>冒泡排序</li><li>快速排序</li><li>选择排序</li><li>直接插入<br><code>&lt;a name=&quot;hkm5B&quot;&gt;&lt;/a&gt;</code></li></ol><h3 id="常见问题解答"><a href="#常见问题解答" class="headerlink" title="常见问题解答"></a>常见问题解答</h3><p><code>&lt;a name=&quot;lC32w&quot;&gt;&lt;/a&gt;</code></p><h4 id="1-声明数组需要注意什么？"><a href="#1-声明数组需要注意什么？" class="headerlink" title="1. 声明数组需要注意什么？"></a>1. 声明数组需要注意什么？</h4><p>声明数组时，一定要考虑数组的最大容量，防止容量不够的现象。数组一旦被声明，它的容量就固定了，不容改变。如果想在运行程序时改变容量，就需要用到集合。关于集合我们会在教程后面讲解。<br><code>&lt;a name=&quot;CaxrI&quot;&gt;&lt;/a&gt;</code></p><h4 id="2-数组在平时的程序代码中使用是否频繁？"><a href="#2-数组在平时的程序代码中使用是否频繁？" class="headerlink" title="2. 数组在平时的程序代码中使用是否频繁？"></a>2. 数组在平时的程序代码中使用是否频繁？</h4><p>数组有一个缺点，就是一旦声明，就不能改变容量，这个也是其使用频率不高的原因。一般存储数据会使用集合或 Vector 来存储数据，后面我们会讲到。</p><p><code>&lt;a name=&quot;0F3hA&quot;&gt;&lt;/a&gt;</code></p><h2 id="9-super和this的区别"><a href="#9-super和this的区别" class="headerlink" title="9.super和this的区别"></a>9.super和this的区别</h2><p><strong>this 指的是当前对象的引用，super 是当前对象的父对象的引用。下面先简单介绍一下 super 和 this 关键字的用法。</strong><br><code>&lt;a name=&quot;CufaA&quot;&gt;&lt;/a&gt;</code></p><h3 id="super-关键字的用法："><a href="#super-关键字的用法：" class="headerlink" title="super 关键字的用法："></a>super 关键字的用法：</h3><p>super 可以用来直接调用父类中的构造方法，使编写代码也更加简洁方便。  <code>&lt;br /&gt;</code>编译器会自动在子类构造方法的第一句加上super();来调用父类的无参构造方法，必须写在子类构造方法的第一句，也可以省略不写。通过 super 来调用父类其它构造方法时，只需要把相应的参数传过去。</p><ol><li>super.父类属性名：调用父类中的属性</li><li>super.父类方法名：调用父类中的方法</li><li>super()：调用父类的无参构造方法</li><li>super(参数)：调用父类的有参构造方法</li><li>如果构造方法的第一行代码不是 this() 和 super()，则系统会默认添加 super()。<br><code>&lt;a name=&quot;a5gXL&quot;&gt;&lt;/a&gt;</code></li></ol><h3 id="this-关键字的用法："><a href="#this-关键字的用法：" class="headerlink" title="this 关键字的用法："></a>this 关键字的用法：</h3><ol><li>this.属性名：表示当前对象的属性</li><li>this.方法名(参数)：表示调用当前对象的方法</li><li>当局部变量和成员变量发生冲突时，使用this.进行区分。<br><code>&lt;a name=&quot;XGxLk&quot;&gt;&lt;/a&gt;</code></li></ol><h3 id="关于-Java-super-和-this-关键字的异同，可简单总结为以下几条。"><a href="#关于-Java-super-和-this-关键字的异同，可简单总结为以下几条。" class="headerlink" title="关于 Java super 和 this 关键字的异同，可简单总结为以下几条。"></a>关于 <a href="http://c.biancheng.net/java/">Java</a> super 和 this 关键字的异同，可简单总结为以下几条。</h3><ol><li>子类和父类中变量或方法名称相同时，用 super 关键字来访问。可以理解为 super 是指向自己父类对象的一个指针。在子类中调用父类的构造方法。</li><li>this 是自身的一个对象，代表对象本身，可以理解为 this 是指向对象本身的一个指针。在同一个类中调用其它方法。</li><li>this 和 super 不能同时出现在一个构造方法里面，因为 this 必然会调用其它的构造方法，其它的构造方法中肯定会有 super 语句的存在，所以在同一个构造方法里面有相同的语句，就失去了语句的意义，编译器也不会通过。</li><li>this( ) 和 super( ) 都指的是对象，所以，均不可以在 static 环境中使用，包括 static 变量、static 方法和 static 语句块。</li><li>从本质上讲，this 是一个指向对象本身的指针, 然而 super 是一个 Java 关键字。<br><code>&lt;a name=&quot;5ZSX0&quot;&gt;&lt;/a&gt;</code></li></ol><h1 id="10-Java对象类型转换：向上转型和向下转型"><a href="#10-Java对象类型转换：向上转型和向下转型" class="headerlink" title="10.Java对象类型转换：向上转型和向下转型"></a>10.Java对象类型转换：向上转型和向下转型</h1><p>将一个类型强制转换成另一个类型的过程被称为类型转换。本节所说的对象类型转换，是指存在继承关系的对象，不是任意类型的对象。当对不存在继承关系的对象进行强制类型转换时，会抛出 <a href="http://c.biancheng.net/java/">Java</a> 强制类型转换（java.lang.ClassCastException）异常<br><code>&lt;a name=&quot;tumYL&quot;&gt;&lt;/a&gt;</code></p><h3 id="1）向上转型"><a href="#1）向上转型" class="headerlink" title="1）向上转型"></a>1）向上转型</h3><p>父类引用指向子类对象为向上转型，语法格式如下：<code>&lt;br /&gt;</code>fatherClass obj &#x3D; new sonClass();<br><code>&lt;a name=&quot;wwcgi&quot;&gt;&lt;/a&gt;</code></p><h3 id="2）向下转型"><a href="#2）向下转型" class="headerlink" title="2）向下转型"></a>2）向下转型</h3><p>与向上转型相反，子类对象指向父类引用为向下转型，语法格式如下：<code>&lt;br /&gt;</code>sonClass obj &#x3D; (sonClass) fatherClass;<br><code>&lt;a name=&quot;IwO9Z&quot;&gt;&lt;/a&gt;</code></p><h2 id="11-异常处理"><a href="#11-异常处理" class="headerlink" title="11.异常处理"></a>11.异常处理</h2><p><code>&lt;a name=&quot;r4V2l&quot;&gt;&lt;/a&gt;</code></p><h3 id="在-Java-中一个异常的产生，主要有如下三种原因："><a href="#在-Java-中一个异常的产生，主要有如下三种原因：" class="headerlink" title="在 Java 中一个异常的产生，主要有如下三种原因："></a>在 Java 中一个异常的产生，主要有如下三种原因：</h3><ol><li>Java 内部错误发生异常，Java 虚拟机产生的异常。</li><li>编写的程序代码中的错误所产生的异常，例如空指针异常、数组越界异常等。</li><li>通过 throw 语句手动生成的异常，一般用来告知该方法的调用者一些必要信息。<br><code>&lt;a name=&quot;m4PYZ&quot;&gt;&lt;/a&gt;</code></li></ol><h2 id="12-继承"><a href="#12-继承" class="headerlink" title="12.继承"></a>12.继承</h2><p>执行顺序：父类静态变量，方法→父类静态代码块→子类静态变量，方法→子类静态代码块→父类非静态代码快→父类构造函数→子类非静态代码快→子类构造函数。注：静态变量，方法按照位置顺序执行。<code>&lt;br /&gt;</code>静态块中的代码按写的顺序首先依次执行，执行于方法前<br><code>&lt;a name=&quot;tDe5s&quot;&gt;&lt;/a&gt;</code></p><h2 id="13-构造方法"><a href="#13-构造方法" class="headerlink" title="13.构造方法"></a>13.构造方法</h2><p><code>&lt;a name=&quot;ogmcM&quot;&gt;&lt;/a&gt;</code></p><h3 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h3><ul><li>构造方法名与类名相同</li><li>构造方法没有返回值 类型，也不写void</li><li>构造方法可以重载<br><code>&lt;a name=&quot;EEvDx&quot;&gt;&lt;/a&gt;</code></li></ul><h3 id="构造方法的作用："><a href="#构造方法的作用：" class="headerlink" title="构造方法的作用："></a>构造方法的作用：</h3><ul><li>在创建对象时，给属性赋初值</li><li>构造方法何时使用</li><li>构造方法在创建对象时被调用<br><code>&lt;a name=&quot;bhjeP&quot;&gt;&lt;/a&gt;</code></li></ul><h3 id="构造方法的分类："><a href="#构造方法的分类：" class="headerlink" title="构造方法的分类："></a>构造方法的分类：</h3><ul><li>显示的构造方法和隐式的构造方法</li><li>当声明了构造方法时，系统不会提供隐式的默认的无参构造方法\</li><li>编译看左边，运行看右边</li></ul><p><strong>下面的笔记和题目顺序大致一致</strong></p><p><code>&lt;a name=&quot;wQZOx&quot;&gt;&lt;/a&gt;</code></p><h1 id="java基础复习总结"><a href="#java基础复习总结" class="headerlink" title="java基础复习总结"></a>java基础复习总结</h1><p><code>&lt;a name=&quot;wys1q&quot;&gt;&lt;/a&gt;</code></p><h2 id="一-基础概念和常识"><a href="#一-基础概念和常识" class="headerlink" title="一.基础概念和常识"></a>一.基础概念和常识</h2><blockquote><p>1） JVM vs JDK vs JRE<code>&lt;br /&gt;</code>2） 为什么说 Java 语言“编译与解释并存”？</p></blockquote><p><code>&lt;a name=&quot;RWvw4&quot;&gt;&lt;/a&gt;</code></p><h3 id="1-JVM-vs-JDK-vs-JRE"><a href="#1-JVM-vs-JDK-vs-JRE" class="headerlink" title="1. JVM vs JDK vs JRE"></a>1. JVM vs JDK vs JRE</h3><ul><li>JDK：Java Development Kit</li><li>JRE：Java Runtime Environment</li></ul><p>JRE就是运行Java字节码的虚拟机。但是，如果只有Java源码，要编译成Java字节码，就需要JDK，因为JDK除了包含JRE，还提供了编译器、调试器等开发工具。<code>&lt;br /&gt;</code>二者关系如下：<code>&lt;br /&gt;</code>┌─    ┌──────────────────────────────────┐<code>&lt;br /&gt;</code>│     │     Compiler, debugger, etc.     │<code>&lt;br /&gt;</code>│     └──────────────────────────────────┘<code>&lt;br /&gt;</code>JDK ┌─ ┌──────────────────────────────────┐<code>&lt;br /&gt;</code>│  │  │                                  │<code>&lt;br /&gt;</code>│ JRE │      JVM + Runtime Library       │<code>&lt;br /&gt;</code>│  │  │                                  │<code>&lt;br /&gt;</code>└─ └─ └──────────────────────────────────┘<code>&lt;br /&gt;</code>┌───────┐┌───────┐┌───────┐┌───────┐<code>&lt;br /&gt;</code>│Windows││ Linux ││ macOS ││others │<code>&lt;br /&gt;</code>└───────┘└───────┘└───────┘└───────┘<code>&lt;br /&gt;</code>JDK（Java Development<code>&lt;br /&gt;</code>Kit）是针对Java开发员的产品，是整个Java的核心，包括了Java运行环境JRE、Java工具和Java基础类库。<code>&lt;br /&gt;</code>JRE (Java Runtime Environment)是运行JAVA程序所必须的环境的集合，包含JVM标准实现及Java核心类库。<code>&lt;br /&gt;</code>JVM (Java Virtual<code>&lt;br /&gt;</code>Machine)是Java虚拟机的缩写，是整个java实现跨平台的最核心的部分，能够运行以Java语言写作的软件程序。<code>&lt;br /&gt;</code>三者的关系是JDK包含JRE包含JVM，Java运行步骤：源码—javac编译器—&gt;字节码文件—Java解释器—&gt;机器码文件。<code>&lt;br /&gt;</code>jvm的作用是将字节码文件解释为机器码文件。<code>&lt;br /&gt;</code>源码通过javac编译器转化为字节码文件，字节码文件是一样的。不一样的是jvm，针对不同的系统有不同的 jvm 实现。<code>&lt;br /&gt;</code>总结<code>&lt;br /&gt;</code>JDK是整个Java的核心，包括了Java运行环境JRE、Java工具和Java基础类库。JRE是运行JAVA程序所必须的环境的集合，包含JVM标准实现及Java核心类库。JVM是整个java实现跨平台的最核心的部分，能够运行以Java语言写的程序。<code>&lt;br /&gt;</code>2.</p><p><code>&lt;a name=&quot;LZQ6h&quot;&gt;&lt;/a&gt;</code></p><h3 id="2-为什么说-Java-语言“编译与解释并存”？"><a href="#2-为什么说-Java-语言“编译与解释并存”？" class="headerlink" title="2. 为什么说 Java 语言“编译与解释并存”？"></a>2. 为什么说 Java 语言“编译与解释并存”？</h3><p><code>&lt;a name=&quot;kSV8W&quot;&gt;&lt;/a&gt;</code></p><h4 id="编译型语言"><a href="#编译型语言" class="headerlink" title="编译型语言"></a>编译型语言</h4><p>会通过编译器将源代码翻译成可执行的机器码<code>&lt;br /&gt;</code>这类语言的执行速度比较快,开发效率低<code>&lt;br /&gt;</code>常见的C,C++,Go,Rust都是编译型语言<br><code>&lt;a name=&quot;G9ZNq&quot;&gt;&lt;/a&gt;</code></p><h4 id="解释型语言"><a href="#解释型语言" class="headerlink" title="解释型语言"></a>解释型语言</h4><p>会通过解释器将代码一句一句的解释成机器代码然后再去执行<code>&lt;br /&gt;</code>开发效率快,执行速度比较慢<code>&lt;br /&gt;</code>常见的Python,JS,PHP都是解释型语言<br><code>&lt;a name=&quot;b5yUT&quot;&gt;&lt;/a&gt;</code></p><h4 id="编译与解释并存"><a href="#编译与解释并存" class="headerlink" title="编译与解释并存"></a>编译与解释并存</h4><p>java具有编译型语言的特征,也具有解释型语言的特征<code>&lt;br /&gt;</code>java程序会经过先编译后解释<code>&lt;br /&gt;</code><img src="https://cdn.nlark.com/yuque/0/2022/png/33764834/1668330133097-42b84326-fc4c-4694-8ea5-4283c0d66a28.png#averageHue=%23c4c672&crop=0&crop=0&crop=1&crop=1&id=LhyQS&originHeight=357&originWidth=609&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br><code>&lt;a name=&quot;TkHzC&quot;&gt;&lt;/a&gt;</code></p><h4 id="先编译生成字节码-class文件"><a href="#先编译生成字节码-class文件" class="headerlink" title="先编译生成字节码(.class文件)"></a>先编译生成字节码(.class文件)</h4><p>再将字节码交给java解释器来解释执行<code>&lt;br /&gt;</code>所以先编译后解释<code>&lt;br /&gt;</code>.java经过javac编译器编译之后得到.class文件-&gt;这个就是java文件到虚拟机的中间码-&gt;.class文件只有被JVM加载-&gt;然后通过解释器-逐行解释执行，这种方式的执行速度会相对比较慢。这是属于解释型语言的特点，中间码即.calss文件只是一个中间码，并不算机器码，所以并不满足编译型语言的特点。然而，有些方法和代码块是经常需要被调用的，也就是所谓的热点代码，后面引进了 JIT 编译器，JIT 属于运行时编译。当 JIT 编译器完成第一次编译后，其会将字节码对应的机器码保存下来，下次可以直接使用。这是属于编译型语言的特点，机器码的运行效率肯定是高于 Java 解释器的。这也解释了我们为什么经常会说 <strong>Java 是编译与解释共存的语言。</strong><br><code>&lt;a name=&quot;mnTGs&quot;&gt;&lt;/a&gt;</code></p><h2 id="二-基本语法"><a href="#二-基本语法" class="headerlink" title="二.基本语法"></a>二.基本语法</h2><blockquote><ol><li>1） 注解</li><li>2） 字符型常量和字符串常量</li><li>3） 标识符和关键字的区别</li><li>4） 泛型，类型擦除</li><li>5） &#x3D;&#x3D;和equals()</li><li>6）  hashCode() 与 equals() 等</li></ol></blockquote><p><code>&lt;a name=&quot;YvJIy&quot;&gt;&lt;/a&gt;</code></p><h3 id="Java注解"><a href="#Java注解" class="headerlink" title="Java注解"></a><strong>Java注解</strong></h3><p><strong>是一个很重要的知识点，用于对代码进行说明，可以对包、类、接口、字段、方法参数、局部变量等进行注解。掌握好Java注解有利于学习</strong><a href="https://so.csdn.net/so/search?q=%E6%A1%86%E6%9E%B6&spm=1001.2101.3001.7020"><strong>框架</strong></a><strong>底层实现。</strong><code>&lt;br /&gt;</code><img src="https://cdn.nlark.com/yuque/0/2022/png/33764834/1668330133498-42fbd406-6166-4665-94d3-9fb2bb5330ea.png#averageHue=%23a9bdbb&crop=0&crop=0&crop=1&crop=1&id=gm08R&originHeight=407&originWidth=1487&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br><code>&lt;a name=&quot;xxVOB&quot;&gt;&lt;/a&gt;</code></p><h4 id="1、Java自带的标准注解"><a href="#1、Java自带的标准注解" class="headerlink" title="1、Java自带的标准注解"></a>1、Java自带的标准注解</h4><p>包括@Override、@Deprecated、@SuppressWarnings等，使用这些注解后编译器就会进行检查。<br><code>&lt;a name=&quot;ca8D3&quot;&gt;&lt;/a&gt;</code></p><h4 id="2、元注解"><a href="#2、元注解" class="headerlink" title="2、元注解"></a>2、元注解</h4><p>元注解是用于定义注解的注解，包括@Retention、@Target、@Inherited、@Documented、@Repeatable 等。  <code>&lt;br /&gt;</code>元注解也是Java自带的标准注解，只不过用于修饰注解，比较特殊。<code>&lt;br /&gt;</code><img src="https://cdn.nlark.com/yuque/0/2022/png/33764834/1668330133836-89ead97a-5fdf-4d79-95b0-2a576079b8c3.png#averageHue=%23f8f7f7&crop=0&crop=0&crop=1&crop=1&id=vL2eF&originHeight=245&originWidth=2028&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><code>&lt;br /&gt;</code><img src="https://cdn.nlark.com/yuque/0/2022/png/33764834/1668330134085-bdfd414b-6d96-4516-8ae2-2d41a78c73eb.png#averageHue=%23f9f8f8&crop=0&crop=0&crop=1&crop=1&id=hEGNu&originHeight=485&originWidth=1910&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><code>&lt;br /&gt;</code><img src="https://cdn.nlark.com/yuque/0/2022/png/33764834/1668330134491-83ee42e5-51f7-4eb4-9f31-266492da95a7.png#averageHue=%23f8f7f7&crop=0&crop=0&crop=1&crop=1&id=akZt3&originHeight=455&originWidth=1362&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><code>&lt;br /&gt;</code><img src="https://cdn.nlark.com/yuque/0/2022/png/33764834/1668330134974-67b03011-d1e6-4664-ba8b-2b078e781235.png#averageHue=%23f8efd7&crop=0&crop=0&crop=1&crop=1&id=UtAdq&originHeight=639&originWidth=1856&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><code>&lt;br /&gt;</code><img src="https://cdn.nlark.com/yuque/0/2022/png/33764834/1668330135505-5bc1fd8a-3ce4-49bf-8b5c-3159567da50d.png#averageHue=%23f1efed&crop=0&crop=0&crop=1&crop=1&id=uC43A&originHeight=68&originWidth=1473&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><code>&lt;br /&gt;</code><img src="https://cdn.nlark.com/yuque/0/2022/png/33764834/1668330135907-72e9100a-46f6-4590-8e1a-09021e4928ab.png#averageHue=%23e3e2e2&crop=0&crop=0&crop=1&crop=1&id=l4O0f&originHeight=1139&originWidth=2180&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><code>&lt;br /&gt;</code><img src="https://cdn.nlark.com/yuque/0/2022/png/33764834/1668330136669-3d8338be-ed40-4a0b-8899-f8f95770e735.png#averageHue=%23ebebea&crop=0&crop=0&crop=1&crop=1&id=ymk84&originHeight=858&originWidth=1446&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><code>&lt;br /&gt;</code><img src="https://cdn.nlark.com/yuque/0/2022/png/33764834/1668330137142-27e053e8-6f34-464a-9b05-35a16ebbd40c.png#averageHue=%23f9f9f8&crop=0&crop=0&crop=1&crop=1&id=HghKn&originHeight=546&originWidth=2098&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br><code>&lt;a name=&quot;bejXA&quot;&gt;&lt;/a&gt;</code></p><h3 id="java中字符型常量和字符串常量的区别"><a href="#java中字符型常量和字符串常量的区别" class="headerlink" title="java中字符型常量和字符串常量的区别"></a>java中字符型常量和字符串常量的区别</h3><p><code>&lt;a name=&quot;epLcf&quot;&gt;&lt;/a&gt;</code></p><h4 id="1-形式上"><a href="#1-形式上" class="headerlink" title="1.形式上"></a>1.形式上</h4><p>字符常量 是单引号(‘’)引起的一个字符，字符串常量 是双引号引起的若干个字符<br><code>&lt;a name=&quot;CTuWA&quot;&gt;&lt;/a&gt;</code></p><h4 id="2-含有上"><a href="#2-含有上" class="headerlink" title="2.含有上"></a>2.含有上</h4><p>字符常量相当于一个整形值(ASCll值)，可以参与表达式的运算。字符串常量代表一个地址值(该字符串在内存中存放的位置）<br><code>&lt;a name=&quot;HNH8Z&quot;&gt;&lt;/a&gt;</code></p><h4 id="3-占内存大小"><a href="#3-占内存大小" class="headerlink" title="3.占内存大小"></a>3.占内存大小</h4><p>字符常量占两个字节，字符串常量若干个字节（至少一个字符结束标志）<code>&lt;br /&gt;</code>1） 标识符和关键字的区别<br><code>&lt;a name=&quot;pToyc&quot;&gt;&lt;/a&gt;</code></p><h2 id="Java标识符和关键字的区别"><a href="#Java标识符和关键字的区别" class="headerlink" title="Java标识符和关键字的区别"></a>Java标识符和关键字的区别</h2><p><strong>一、主体不同</strong><code>&lt;br /&gt;</code><strong>关键字</strong>属于保留字，是整个语言范围内预先保留的标识符。<strong>一般标识符</strong>是用户编程时使用的名字，用于给变量、常量、函数、语句块等命名，以建立起名称与使用之间的关系。<code>&lt;br /&gt;</code><strong>二、特点不同</strong><code>&lt;br /&gt;</code><strong>关键字</strong>不能声明与关键字同名的标识符。<strong>一般标识符</strong>由字母和数字以及其它字符构成。<code>&lt;br /&gt;</code><strong>三、规则不同</strong><code>&lt;br /&gt;</code><strong>关键字</strong>经过预处理后，关键字从预处理记号(preprocessing-token)中区别出来，剩下的标识符作为记号(token)，用于声明对象、函数、类型、命名空间等。一般标识符长度是由机器上的编译系统决定的，一般的限制为8字符。<br><code>&lt;a name=&quot;jXom2&quot;&gt;&lt;/a&gt;</code></p><h4 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h4><p><strong>对编译器有特殊意义的固定单词</strong>，不能在程序中做其他目的使用。关键字具有专门的意义和用途，<strong>和自定义的标识符不同，不能当作一般的标识符来使用</strong>！<code>&lt;br /&gt;</code>Java 语言按其用途划分为如下几组，<strong>这些关键字不能作为变量名、类名和方法名来使用！！（注意：关键字一律用小写字母标识）</strong><code>&lt;br /&gt;</code><strong>1、用于数据类型</strong>：boolean、byte、char、 double、 float、int、long、new、short、void、instanceof。<code>&lt;br /&gt;</code><strong>2、用于语句</strong>：break、case、 catch、 continue、 default 、do、 else、 for、 if、return、switch、try、 while、 finally、 throw、this、 super。<code>&lt;br /&gt;</code><strong>3、用于修饰</strong>：abstract、final、native、private、 protected、public、static、synchronized、transient、 volatile。<code>&lt;br /&gt;</code><strong>4、用于方法、类、接口、包和异常</strong>：class、 extends、 implements、interface、 package、import、throws。<code>&lt;br /&gt;</code><strong>5、还有些关键字</strong>,如 future、 generic、 operator、 outer、rest、var等都是Java保留的没有意义的关键字。<code>&lt;br /&gt;</code><strong>6、另外，Java还有3个保留字</strong>：goto、const、null。它们不是关键字，而是文字。包含Java定义的值。和关键字一样，它们也不可以作为标识符使用。<br><code>&lt;a name=&quot;LRHUF&quot;&gt;&lt;/a&gt;</code></p><h4 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h4><p>1、标识符由数字（0<del>9）和字母（A</del>Z 和 a~z）、美元符号（$）、下划线（_）以及 Unicode 字符集中符号大于 0xC0 的所有符号组合构成（各符号之间没有空格）。<code>&lt;br /&gt;</code>2、标识符的第一个符号为字母、下划线和美元符号，后面可以是任何字母、数字、美元符号或下划线。<br><code>&lt;a name=&quot;B8S35&quot;&gt;&lt;/a&gt;</code></p><h5 id="标识符的分类"><a href="#标识符的分类" class="headerlink" title="标识符的分类"></a><strong>标识符的分类</strong></h5><p>1、关键字是有特殊含义的标识符，如 true、false 表示逻辑的真假。<code>&lt;br /&gt;</code>2、用户自定义标识符是由用户按标识符构成规则生成的非保留字的标识符，如 abc 就是一个标识符。</p><p><code>&lt;a name=&quot;BsEzl&quot;&gt;&lt;/a&gt;</code></p><h2 id="泛型，类型擦除"><a href="#泛型，类型擦除" class="headerlink" title="泛型，类型擦除"></a>泛型，类型擦除</h2><ol><li>泛型方法不能使用基本数据类型作为参数。</li><li>使用泛型进行编程可以提高程序安全性以及可读性。</li><li>泛型只存在于编译期间。</li><li>通过使用通配符可以放宽对参数的限制增加程序灵活性。</li></ol><p>1 泛型通配符<br><code>&lt;a name=&quot;ZqPpU&quot;&gt;&lt;/a&gt;</code></p><h4 id="1-1-无边界通配符-lt-gt"><a href="#1-1-无边界通配符-lt-gt" class="headerlink" title="1.1 无边界通配符 &lt;?&gt;"></a>1.1 无边界通配符 &lt;?&gt;</h4><p><code>&lt;a name=&quot;rjzRG&quot;&gt;&lt;/a&gt;</code></p><h4 id="1-2-固定上边界的通配符-lt-extends-E-gt"><a href="#1-2-固定上边界的通配符-lt-extends-E-gt" class="headerlink" title="1.2 固定上边界的通配符 &lt;? extends E&gt;"></a>1.2 固定上边界的通配符 &lt;? extends E&gt;</h4><p>对于上限通配符需要注意的一点就是使用上限通配符只能从结构中获取值而不能将值放入结构中<br><code>&lt;a name=&quot;Ox98W&quot;&gt;&lt;/a&gt;</code></p><h4 id="1-3-固定下边界的通配符-lt-super-E-gt"><a href="#1-3-固定下边界的通配符-lt-super-E-gt" class="headerlink" title="1.3 固定下边界的通配符&lt;? super E&gt;"></a>1.3 固定下边界的通配符&lt;? super E&gt;</h4><p>对于下限通配符同样需要注意的一点就是使用下限通配符只能将值放入结构中或者将读取结果转换为Object<code>&lt;br /&gt;</code>总结</p><pre><code>1. 如果要从结构中获取值，使用上限通配符；     2. 在将值放入结构中时，使用下限通配符。     3. 可以为通配符指定上限，也可以指定下限，但不能同时指定两者。</code></pre><p>反编译命令 javap -c [Class名称] 就可以编译class文件。<br><code>&lt;a name=&quot;zJ1k0&quot;&gt;&lt;/a&gt;</code></p><h3 id="1、泛型不是协变的"><a href="#1、泛型不是协变的" class="headerlink" title="1、泛型不是协变的"></a>1、<a href="https://so.csdn.net/so/search?q=%E6%B3%9B%E5%9E%8B&spm=1001.2101.3001.7020">泛型</a>不是协变的</h3><p>_协变_：能在使用父类型的场景中改用子类型<code>&lt;br /&gt;</code>_逆变_：能在使用子类型的场景中改用父类型<code>&lt;br /&gt;</code>_不变_：不能做到以上两点<br><code>&lt;a name=&quot;LkHZR&quot;&gt;&lt;/a&gt;</code></p><h3 id="2-泛型的特性所引起的问题"><a href="#2-泛型的特性所引起的问题" class="headerlink" title="2 泛型的特性所引起的问题"></a>2 泛型的特性所引起的问题</h3><p>泛型类型变量不能是基本数据类型<code>&lt;br /&gt;</code>因为当类型擦除后会变为Object等引用类型，因此基本数据类型不能用于定义泛型类型变量。<code>&lt;br /&gt;</code>使用instanceof注意点<code>&lt;br /&gt;</code>instanceof 是用来测试一个对象是否为一个类的实例，而对于泛型在类型擦除后会变为Object等引用类型，因此instanceof检测和类型转换工作只对原始类型进行.<code>&lt;br /&gt;</code>泛型在静态方法和静态类中的问题<code>&lt;br /&gt;</code>泛型类中的静态方法和静态变量不能使用泛型类所声明的泛型类型参数，因为泛型类中的泛型参数的实例化是在定义对象的时候指定的，而静态变量和静态方法不需要使用对象来调用，因此对象没有创建也就无法确定这个泛型参数是何种类型。另外由于类型擦除的原因，实际上多个泛型方法只存在一个对应的原始类，因此静态变量在这多个泛型类实例之间是共享的。<code>&lt;br /&gt;</code><strong>不能创建一个泛型类型的实例</strong><code>&lt;br /&gt;</code><strong>没有泛型数组</strong>由于数组是协变的加上泛型最终会被类型擦除，因此泛型数组违背了泛型的设计初衷是被禁止的<code>&lt;br /&gt;</code>Java泛型实际上是“伪泛型”，它只是在编译期存在当程序到运行时则会被Java虚拟机进行类型擦除，同时Java虚拟机通过桥接的方式将编译期和运行期的程序（泛型类和原始类）连接了起来，从而实现了泛型的整个过程。另外对于Java泛型的许多限制都可以通过类型擦除和泛型的设计初衷来解释（将可能出现的运行时异常移至编译其解决）。<br><code>&lt;a name=&quot;ZmDtz&quot;&gt;&lt;/a&gt;</code></p><h2 id="x3D-x3D-和equals"><a href="#x3D-x3D-和equals" class="headerlink" title="&#x3D;&#x3D;和equals()"></a>&#x3D;&#x3D;和equals()</h2><p>一、对字符串而言，&#x3D;&#x3D;和equals()的区别</p><ul><li>“&#x3D;&#x3D;” 比较的是两个对象的引用（内存地址）是否相同，也用来比较两个基本数据类型的变量值是否相等。</li><li>equals() 比较的是两个对象的值（内容）是否相同。</li><li>对于&#x3D;&#x3D;：在简单类型中(int等)，这能使用该方法进行比较，这种类型没有equals方法，int的值是存在栈中的，&#x3D;&#x3D;比较的是栈的内容是否相同。在String类型中，比较特殊，用String&#x3D;“<strong>”；这种进行赋值时，两个相同的值用&#x3D;&#x3D;比较也是相同的。但是用new String()，赋值就不相同。说明String&#x3D;“”时，java会检查在堆中是否由相同的值，如果有，把新对象的地址也同老对象的地址赋为相同，因此&#x3D;&#x3D;比较会相同（“</strong>”存储在常量区内存中）。但是new String()开辟的就是两个栈，因此用&#x3D;&#x3D;比较不会相同。对于包装类，如Integer num&#x3D;127；时，进行自动装箱操作。如果数值在-128-127会有缓存，此时&#x3D;&#x3D;是相同的；如果数值不在-128～127之间，则&#x3D;&#x3D;不相同。</li><li>对于equals：当时String类型或者是包装类（如Integer），比较的就是堆中的值。对于用户自定义的普通类，equals比较的内存的首地址，这时候和&#x3D;&#x3D;是一样的，即比较两边指向的是不是同一个对象。<br><code>&lt;a name=&quot;WNWUV&quot;&gt;&lt;/a&gt;</code></li></ul><h3 id="关于hashcode，我们一定要知道一个口诀："><a href="#关于hashcode，我们一定要知道一个口诀：" class="headerlink" title="关于hashcode，我们一定要知道一个口诀："></a>关于hashcode，我们一定要知道一个口诀：</h3><ul><li>hashcode相等，两个对象不一定相等，需要通过equals方法进一步判断；</li><li>hashcode不相等，两个对象一定不相等；</li><li>equals方法为true，则hashcode肯定一样；</li><li>equals方法为false，则hashcode不一定不一样<br><code>&lt;a name=&quot;U6Oaa&quot;&gt;&lt;/a&gt;</code></li></ul><h2 id="hashCode-与-equals"><a href="#hashCode-与-equals" class="headerlink" title="hashCode()与 equals()"></a>hashCode()与 equals()</h2><p>hashCode()和<a href="https://so.csdn.net/so/search?q=equals&spm=1001.2101.3001.7020">equals</a>()都是Object类中的方法<code>&lt;br /&gt;</code>(1).如果类中不<a href="https://so.csdn.net/so/search?q=%E9%87%8D%E5%86%99&spm=1001.2101.3001.7020">重写</a>方法：<code>&lt;br /&gt;</code>hashCode()：属于本地方法，返回的是对象的哈希码值，也称为<a href="https://so.csdn.net/so/search?q=%E6%95%A3%E5%88%97&spm=1001.2101.3001.7020">散列</a>码，实际返回的是一个int的整数。<code>&lt;br /&gt;</code>equals()：用来比较两个对象的地址值是否相等<code>&lt;br /&gt;</code>(2)如果类中重写方法：  <code>&lt;br /&gt;</code>hashCode()：返回的是根据对象的成员变量，计算出的一个整数  <code>&lt;br /&gt;</code>通过hashCode()和equals()搭配使用比较对象是否相等，是如何提高效率的？<code>&lt;br /&gt;</code>问题：对于一个对象中有大量的成员信息，用equals比较会降低效率<code>&lt;br /&gt;</code>解决：可以先通过hashCode()进行比较，如果不相同则两个对象一定不同，如果相同，再通过eauqls()进行比较，这样既可以判断对象是否相同，又可以提高效率<code>&lt;br /&gt;</code>通过hashCode()和equals()搭配使用比较对象是否相等，是如何提高效率的？<code>&lt;br /&gt;</code>问题：对于一个对象中有大量的成员信息，用equals比较会降低效率<code>&lt;br /&gt;</code>解决：可以先通过hashCode()进行比较，如果不相同则两个对象一定不同，如果相同，再通过eauqls()进行比较，这样既可以判断对象是否相同，又可以提高效率</p><ol><li>基本数据类型</li></ol><p>1） 基本数据类所占字节数<code>&lt;br /&gt;</code>2） 自动装箱和拆箱 <code>&lt;br /&gt;</code>3） 数据类型的封装类，以及中间的区别<code>&lt;br /&gt;</code>Java基本数据类型及所占字节大小<code>&lt;br /&gt;</code>一、Java基本数据类型<code>&lt;br /&gt;</code>　　基本数据类型有8种：byte、short、int、long、float、double、boolean、char<code>&lt;br /&gt;</code>分为4类：整数型、浮点型、布尔型、字符型。<code>&lt;br /&gt;</code>整数型：byte、short、int、long<code>&lt;br /&gt;</code>浮点型：float、double<code>&lt;br /&gt;</code>布尔型：boolean<code>&lt;br /&gt;</code>字符型：char<code>&lt;br /&gt;</code>二、各数据类型所占字节大小<code>&lt;br /&gt;</code>1个字节8位<code>&lt;br /&gt;</code>　　计算机的基本单位：bit .　　一个bit代表一个0或1<code>&lt;br /&gt;</code>byte：1byte &#x3D; 8bit　　　　 1个字节是8个bit<code>&lt;br /&gt;</code>short：2byte<code>&lt;br /&gt;</code>int：4byte<code>&lt;br /&gt;</code>long：8byte<code>&lt;br /&gt;</code>float：4byte<code>&lt;br /&gt;</code>double：8byte<code>&lt;br /&gt;</code>boolean：1byte<code>&lt;br /&gt;</code>char：2byte<code>&lt;br /&gt;</code>————————————————</p><p>自动拆箱和装箱<code>&lt;br /&gt;</code><strong>什么是自动装箱拆箱？</strong><code>&lt;br /&gt;</code><strong>装箱就是自动将基本数据类型转换为包装器类型；拆箱就是自动将包装器类型转换为基本数据类型。</strong><br><code>&lt;a name=&quot;zKmrw&quot;&gt;&lt;/a&gt;</code></p><h1 id="Java基本数据类型与封装类的区别"><a href="#Java基本数据类型与封装类的区别" class="headerlink" title="Java基本数据类型与封装类的区别"></a>Java基本数据类型与封装类的区别</h1><p>1.基本数据类型是值传递，封装类是引用传递<code>&lt;br /&gt;</code>2.基本数据类型是存放在栈中的，而封装类是存放于堆中的<code>&lt;br /&gt;</code>3.基本数据类型初始值如:int&#x3D;0,而封装类Integer&#x3D;null<code>&lt;br /&gt;</code>4.集合中添加的元素一定是封装类引用数据类型<code>&lt;br /&gt;</code>5.声明基本数据类型不需要实例化可直接赋值，而封装类必须申请一个存储空间实例化才可赋值。<code>&lt;br /&gt;</code>————————————————<br><code>&lt;a name=&quot;DJm6x&quot;&gt;&lt;/a&gt;</code></p><h2 id="三-方法"><a href="#三-方法" class="headerlink" title="三.方法"></a>三.方法</h2><blockquote><ol><li>方法的几种类型</li><li>什么是返回值</li><li>静态方法的特殊性</li><li>实例方法以及和静态方法的区别</li></ol></blockquote><p><code>&lt;a name=&quot;m8eev&quot;&gt;&lt;/a&gt;</code></p><h3 id="1-java中方法的分类和性质"><a href="#1-java中方法的分类和性质" class="headerlink" title="1.java中方法的分类和性质"></a>1.java中方法的分类和性质</h3><p>1.无参数无返回值的方法（只执行方法体）<code>&lt;br /&gt;</code>2.无参数有返回值的方法（执行完方法后，需接收返回的数据）<code>&lt;br /&gt;</code>3.有参数无返回值的方法（访问方法时，需传入指定数据类型的值）<code>&lt;br /&gt;</code>4.有参数有返回值的方法（访问方法时，需传入指定数据类型的值，执行完方法后，需接收返回的数据）<code>&lt;br /&gt;</code>形参(形式参数)：<strong>定义方法时</strong>，指定的参数，用于<strong>接收实参数据</strong>，也就是在写方法代码的时候，我们指定的参数。实参(实际参数)：<strong>访问方法时</strong>，传入的实际数据。<code>&lt;br /&gt;</code>构造方法:<code>&lt;br /&gt;</code>1.构造方法又称为<strong>构造器</strong>，是<strong>用于构建对象的</strong>，和对象的关系相当于模具和产品，构造方法会确定构造某些对象的基本属性和规则。<code>&lt;br /&gt;</code>2.结合<strong>new关键字</strong>进行创建对象的时候使用<code>&lt;br /&gt;</code>3.不能被对象显示的调用，构造方法是用来构造对象的，不能被对象调用，好比模具和产品，构造方法就是模具，对象就是产品。<code>&lt;br /&gt;</code>4.方法名必须和类名一样，构造方法的方法名必须和当下的类名一模一样（包括字母大小写）。<code>&lt;br /&gt;</code>5.无返回值，也不用加void。构造方法是默认无返回值的方法，也不需要专门加void表示无返回值。<code>&lt;br /&gt;</code>6.当类的定义者（就是我们写代码的人），未提供构造方法时，系统默认提供一个无参数的构造方法。<code>&lt;br /&gt;</code>7.当类的定义者（就是我们写代码的人），一旦提供了构造方法，系统就不再提供默认的构造方法。<code>&lt;br /&gt;</code>————————————————<br><code>&lt;a name=&quot;nPJg6&quot;&gt;&lt;/a&gt;</code></p><h3 id="2-返回值"><a href="#2-返回值" class="headerlink" title="2.返回值:"></a>2.返回值:</h3><p>普通类的情况下，就是你在定义java方法时，必需要定义一个返回值类型或者使用void占位符占位，然后在方法体末端return一个返回值，需要与定义时候的返回值类型一致，然后在调用此方法时，就会把返回值传输到调用处。<br><code>&lt;a name=&quot;MsX7o&quot;&gt;&lt;/a&gt;</code></p><h3 id="3-静态方法的特殊性"><a href="#3-静态方法的特殊性" class="headerlink" title="3. 静态方法的特殊性"></a>3. 静态方法的特殊性</h3><p>静态成员随着类的加载而加载；<code>&lt;br /&gt;</code>静态成员优先于对象存在；<code>&lt;br /&gt;</code>静态成员被所有对象所共享；<code>&lt;br /&gt;</code>静态成员多了一个中调用方式，可以被类名直接调用。<code>&lt;br /&gt;</code>利：<code>&lt;br /&gt;</code>对对象的共享数据进行单独空间的存储，节省空间，没有必要每一个对象中都存储一份；<code>&lt;br /&gt;</code>可以直接被类名调用。<code>&lt;br /&gt;</code>弊：<code>&lt;br /&gt;</code>生命周期过长；<code>&lt;br /&gt;</code>访问出现局限性，只能访问静态。<br><code>&lt;a name=&quot;w8mJ5&quot;&gt;&lt;/a&gt;</code></p><h3 id="4-简述静态方法和实例方法的区别"><a href="#4-简述静态方法和实例方法的区别" class="headerlink" title="4.简述静态方法和实例方法的区别"></a>4.简述静态方法和实例方法的区别</h3><p>1.静态方法在编译时就加载了，而实例方法是实例化后加载，在调用静态方法时还没实例化，所以静态方法不能调用实例化方法。<code>&lt;br /&gt;</code>2.静态方法可以直接类名.方法名或者对象名.方法名调用；实例方法只能实例化后，通过对象名.方法名调用。<code>&lt;br /&gt;</code>3.静态方法只能调用类中静态属性和静态方法，不能调用类中实例属性和实例方法；实例方法可以调用静态属性和静态方法，也可以调用实例属性和实例方法。<code>&lt;br /&gt;</code>————————————————<code>&lt;br /&gt;</code>1) 值传递和引用传递的区别<br><code>&lt;a name=&quot;IBHA1&quot;&gt;&lt;/a&gt;</code></p><h2 id="一、值传递：是指在调用函数时将实际参数复制一份传递到函数中，这样在函数中如果对参数进行修改，将不会影响到实际参数。"><a href="#一、值传递：是指在调用函数时将实际参数复制一份传递到函数中，这样在函数中如果对参数进行修改，将不会影响到实际参数。" class="headerlink" title="一、值传递：是指在调用函数时将实际参数复制一份传递到函数中，这样在函数中如果对参数进行修改，将不会影响到实际参数。"></a>一、<a href="https://so.csdn.net/so/search?q=%E5%80%BC%E4%BC%A0%E9%80%92&spm=1001.2101.3001.7020">值传递</a>：是指在调用函数时将实际参数复制一份传递到函数中，这样在函数中如果对参数进行修改，将不会影响到实际参数。</h2><p>对于基本数据类型的参数，形式参数的改变，不影响实际参数的值。<br><code>&lt;a name=&quot;Hkati&quot;&gt;&lt;/a&gt;</code></p><h2 id="二、引用传递：是指在调用函数时将实际参数的地址传递到函数中，那么在函数中对参数所进行的修改，将影响到实际参数。"><a href="#二、引用传递：是指在调用函数时将实际参数的地址传递到函数中，那么在函数中对参数所进行的修改，将影响到实际参数。" class="headerlink" title="二、引用传递：是指在调用函数时将实际参数的地址传递到函数中，那么在函数中对参数所进行的修改，将影响到实际参数。"></a>二、<a href="https://so.csdn.net/so/search?q=%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92&spm=1001.2101.3001.7020">引用传递</a>：是指在调用函数时将实际参数的地址传递到函数中，那么在函数中对参数所进行的修改，将影响到实际参数。</h2><p><code>&lt;a name=&quot;M86lB&quot;&gt;&lt;/a&gt;</code></p><h3 id="对于引用类型的参数传递，形式参数的改变，影响实际参数的值。"><a href="#对于引用类型的参数传递，形式参数的改变，影响实际参数的值。" class="headerlink" title="对于引用类型的参数传递，形式参数的改变，影响实际参数的值。"></a>对于引用类型的参数传递，形式参数的改变，影响实际参数的值。</h3><ol><li>重载和重写<br><code>&lt;a name=&quot;NWbgj&quot;&gt;&lt;/a&gt;</code></li></ol><h1 id="Java方法重载"><a href="#Java方法重载" class="headerlink" title="Java方法重载"></a>Java方法重载</h1><p><a href="http://c.biancheng.net/java/">Java</a> 允许同一个类中定义多个同名方法，只要它们的形参列表不同即可。如果同一个类中包含了两个或两个以上方法名相同的方法，但形参列表不同，这种情况被称为方法重载（overload）。<code>&lt;br /&gt;</code>方法重载的要求是两同一不同：同一个类中方法名相同，参数列表不同。至于方法的其他部分，如方法返回值类型、修饰符等，与方法重载没有任何关系。<br><code>&lt;a name=&quot;Izqgr&quot;&gt;&lt;/a&gt;</code></p><h1 id="Java方法重写"><a href="#Java方法重写" class="headerlink" title="Java方法重写"></a>Java方法重写</h1><p>在子类中如果创建了一个与父类中相同名称、相同返回值类型、相同参数列表的方法，只是方法体中的实现不同，以实现不同于父类的功能，这种方式被称为方法重写（override），又称为方法覆盖。当父类中的方法无法满足子类需求或子类具有特有功能的时候，需要方法重写。<code>&lt;br /&gt;</code>在重写方法时，需要遵循下面的规则：</p><ul><li>参数列表必须完全与被重写的方法参数列表相同。</li><li>返回的类型必须与被重写的方法的返回类型相同（<a href="http://c.biancheng.net/java/">Java</a>1.5 版本之前返回值类型必须一样，之后的 Java 版本放宽了限制，返回值类型必须小于或者等于父类方法的返回值类型）。</li><li>访问权限不能比父类中被重写方法的访问权限更低（public&gt;protected&gt;default&gt;private）。</li><li>重写方法一定不能抛出新的检査异常或者比被重写方法声明更加宽泛的检査型异常。例如，父类的一个方法声明了一个检査异常 IOException，在重写这个方法时就不能抛出 Exception，只能拋出 IOException 的子类异常，可以抛出非检査异常。</li></ul><p>另外还要注意以下几条：</p><ul><li>重写的方法可以使用 @Override 注解来标识。</li><li>父类的成员方法只能被它的子类重写。</li><li>声明为 final 的方法不能被重写。</li><li>声明为 static 的方法不能被重写，但是能够再次声明。</li><li>构造方法不能被重写。</li><li>子类和父类在同一个包中时，子类可以重写父类的所有方法，除了声明为 private 和 final 的方法。</li><li>子类和父类不在同一个包中时，子类只能重写父类的声明为 public 和 protected 的非 final 方法。</li><li>如果不能继承一个方法，则不能重写这个方法。</li></ul><p>一、重载和重写的概念：<code>&lt;br /&gt;</code>重载的概念 ：<code>&lt;br /&gt;</code>在同一个类中，允许存在一个以上的同名方法，只要它们的参数个数或者参数 类型不同即可。<code>&lt;br /&gt;</code>重写的概念：<code>&lt;br /&gt;</code>在子类中可以根据需要对从父类中继承来的方法进行改造，也称 为方法的重置、覆盖。在程序执行时，子类的方法将覆盖父类的方法。<code>&lt;br /&gt;</code>二、重载和重写的特点：<code>&lt;br /&gt;</code>重载的特点：<code>&lt;br /&gt;</code>与返回值类型无关，只看参数列表，且参数列表必须不同。(参数个数或参数类 型)。调用时，根据方法参数列表的不同来区别。<code>&lt;br /&gt;</code>重写的特点：<code>&lt;br /&gt;</code>1.子类重写的方法必须和父类被重写的方法具有相同的方法名称、参数列表 。<code>&lt;br /&gt;</code>2.子类重写的方法的返回值类型不能大于父类被重写的方法的返回值类型 （返回类型为类）。<code>&lt;br /&gt;</code>3.子类重写的方法使用的访问权限不能小于父类被重写的方法的访问权限 。<code>&lt;br /&gt;</code>4.子类不能重写父类中声明为private权限的方法 。<code>&lt;br /&gt;</code>5.子类方法抛出的异常不能大于父类被重写方法的异常 （父类异常的子类）。<code>&lt;br /&gt;</code>———————————————<code>&lt;br /&gt;</code>区别:<code>&lt;br /&gt;</code>重写，overriding,是指在继承的情况下，子类中定义了与父类中具有相同型构的新方法，也就是子类重写了父类的方法。<code>&lt;br /&gt;</code>重载，overloading，是在同一个类中，定义了一个以上具有相同名称，但是有着不同型构的方法，在同一个类中是不允许定义多于一个具有相同型构的方法的。<code>&lt;br /&gt;</code>构造器也是可以重载的，实际上，构造器就是一个方法，构造器的名称就是方法的名称。<code>&lt;br /&gt;</code>———————————————<code>&lt;br /&gt;</code>深拷贝和浅拷贝<code>&lt;br /&gt;</code><strong>概念：</strong><code>&lt;br /&gt;</code><strong>浅拷贝</strong> ：只复制指向某个对象的指针，而不复制对象本身，相当于是新建了一个对象，该对象复制了原对象的指针，新旧对象还是共用一个内存块<code>&lt;br /&gt;</code><strong>深拷贝</strong>：是新建一个一模一样的对象，该对象与原对象不共享内存，修改新对象也不会影响原对象</p><ol><li>面向对象</li></ol><p>1） 面向对象和面向过程<code>&lt;br /&gt;</code>2） 成员变量与局部变量的区别有哪些？<code>&lt;br /&gt;</code>3） 对象实体和对象引用的区别<code>&lt;br /&gt;</code>4） 构造方法的作用，特点<code>&lt;br /&gt;</code>5） 三大特性<code>&lt;br /&gt;</code>面向对象和面向过程<code>&lt;br /&gt;</code>优缺点对比<code>&lt;br /&gt;</code>面向过程：<code>&lt;br /&gt;</code>优点：效率高，因为不需要实例化对象。<code>&lt;br /&gt;</code>缺点：耦合度高，扩展性差，不易维护（例如：每个步骤都要有，不然就不行）<code>&lt;br /&gt;</code>面向对象：<code>&lt;br /&gt;</code>优点：耦合低（易复用），扩展性强，易维护，由于面向对象有封装、继承、多态性的特点，可以设计出低耦合的系统，使系统更加灵活、更加易于维护。<code>&lt;br /&gt;</code>缺点：效率比面向过程低。<code>&lt;br /&gt;</code>————————————————<br><code>&lt;a name=&quot;7A8n4&quot;&gt;&lt;/a&gt;</code></p><h1 id="成员变量与局部变量的区别有哪些？"><a href="#成员变量与局部变量的区别有哪些？" class="headerlink" title="成员变量与局部变量的区别有哪些？"></a>成员变量与局部变量的区别有哪些？</h1><p>类中定义的变量是成员变量，而方法中定义的变量是局部变量<code>&lt;br /&gt;</code>1.从语法形式上看，成员变量属于类，而局部变量是在方法中定义的变量或是方法的参数。<code>&lt;br /&gt;</code>成员变量可被修饰符修饰，而局部变量则不能被访问控制修饰符及static所修饰；成员变量和局部变量 都可以被final所修饰。<code>&lt;br /&gt;</code>2.从变量在内存中的储存方式上看，成员变量是对象的一部分，而对象是存在于堆内存的，而局部变量 是存在于栈内存的。<code>&lt;br /&gt;</code>3.从变量在内存中的生存时间上看，成员变量是对象的一部分，而对象是存在于堆内存的，而局部变量是存在于栈内存的。<code>&lt;br /&gt;</code>4.成员变量如果没有被赋初值，则会自动以类型的默认值赋值（例外：被final修饰但没有被static修饰的成员变量必须显式地赋值）；而局部变量则不会自动赋值，必须显式地赋值后才能使用。<code>&lt;br /&gt;</code>———————————————<br><code>&lt;a name=&quot;GK2ZD&quot;&gt;&lt;/a&gt;</code></p><h1 id="java中对象实体与对象的引用有何不同？"><a href="#java中对象实体与对象的引用有何不同？" class="headerlink" title="java中对象实体与对象的引用有何不同？"></a>java中对象实体与对象的引用有何不同？</h1><p>对象实体:就是类的这时体现，每个对象都是独立的内存。  <code>&lt;br /&gt;</code>引用就是表示的对象所在内存的位置。其实就是对象的线索。<code>&lt;br /&gt;</code>对象引用的目的地才是对象的实体。<code>&lt;br /&gt;</code>1） 构造方法的作用，特点<code>&lt;br /&gt;</code>1.构造方法的定义与说明<code>&lt;br /&gt;</code>构造方法 : 用来初始化对象的方法<code>&lt;br /&gt;</code>(1)  构造方法名与类名相同 , 且没有返回值,且不需要使用void修饰 。<code>&lt;br /&gt;</code>(2)  作用:在构造方法中为创建的对象初始化赋值,<code>&lt;br /&gt;</code>(3)  在创建一个对象的时候，至少要调用一个构造方法。<code>&lt;br /&gt;</code>(4) 每个类都有构造方法。如果没有显式地为类定义构造方法,Java将会为该类提供一个默认构造方法,但是只要在一个Java类中定义了一个构造方法后，默认的无参构造方法即失效。<code>&lt;br /&gt;</code>我们说构造方法是用来初始化对象的,那么它是怎样去初始化的呢,回想我们创建对象的语法<code>&lt;br /&gt;</code>例 : Car car&#x3D; new Car();<code>&lt;br /&gt;</code>我们可以看到new关键字右边的这一块 ,这其实就是调用了Car类的构造方法来创建此对象的<code>&lt;br /&gt;</code>2.构造方法的声明与使用<code>&lt;br /&gt;</code>构造方法也分为有参和无参的,如果没有显示的定义构造方法,默认是无参的<code>&lt;br /&gt;</code>构造方法之所以可以分为有参和无参,原因就是方法是可以去重载的<code>&lt;br /&gt;</code>当然我们也可以去为一个类设计更多的构造方法,参数不同即可<code>&lt;br /&gt;</code>1） 三大特性<code>&lt;br /&gt;</code>java三大特性：1、封装，是指隐藏对象的属性和实现细节，仅对外提供公共访问方式；2、继承，从已有的类中派生出新的类，新的类能吸收已有类的数据属性和行为，并能扩展新的能力；3、多态，一个方法可以有多种实现版本，即“一种定义， 多种实现”。<br><code>&lt;a name=&quot;Pz7rQ&quot;&gt;&lt;/a&gt;</code></p><h3 id="封装-Encapsulation-："><a href="#封装-Encapsulation-：" class="headerlink" title="封装(Encapsulation) ："></a>封装(Encapsulation) ：</h3><p>封装：是指隐藏对象的属性和实现细节，仅对外提供公共访问方式。<code>&lt;br /&gt;</code>好处：</p><ul><li>将变化隔离。</li><li>便于使用。</li><li>提高重用性。</li><li>提高安全性。</li><li>封装原则：</li><li>将不需要对外提供的内容都隐藏起来。</li><li>把属性都隐藏，提供公共方法对其访问 。</li></ul><p>private关键字：</p><ul><li>是一个权限修饰符。</li><li>用于修饰成员(成员变量和成员函数)</li><li>被私有化的成员只在本类中有效。</li></ul><p>继承<code>&lt;br /&gt;</code>Java 不支持多继承，只允许一个类直接继承另一个类，即子类只能有一个直接父类，<code>&lt;br /&gt;</code>使用继承的注意点：</p><ol><li>子类一般比父类包含更多的属性和方法。</li><li>父类中的 private 成员在子类中是不可见的，因此在子类中不能直接使用它们。</li><li>父类和其子类间必须存在“是一个”即“is-a”的关系，否则不能用继承。但也并不是所有符合“is-a”关系的都应该用继承。例如，正方形是一个矩形，但不能让正方形类来继承矩形类，因为正方形不能从矩形扩展得到任何东西。正确的继承关系是正方形类继承图形类。</li><li>Java 只允许单一继承（即一个子类只能有一个直接父类），C++ 可以多重继承（即一个子类有多个直接父类）。<br><code>&lt;a name=&quot;FYFX7&quot;&gt;&lt;/a&gt;</code></li></ol><h4 id="继承的优缺点"><a href="#继承的优缺点" class="headerlink" title="继承的优缺点"></a>继承的优缺点</h4><p>在面向对象语言中，继承是必不可少的、非常优秀的语言机制，它有如下优点：</p><ol><li>实现代码共享，减少创建类的工作量，使子类可以拥有父类的方法和属性。</li><li>提高代码维护性和可重用性。</li><li>提高代码的可扩展性，更好的实现父类的方法。</li></ol><p>自然界的所有事物都是优点和缺点并存的，继承的缺点如下：</p><ol><li>继承是侵入性的。只要继承，就必须拥有父类的属性和方法。</li><li>降低代码灵活性。子类拥有父类的属性和方法后多了些约束。</li><li>增强代码耦合性（开发项目的原则为高内聚低耦合）。当父类的常量、变量和方法被修改时，需要考虑子类的修改，有可能会导致大段的代码需要重构。</li></ol><p>Java多态性：Java什么是多态？<code>&lt;br /&gt;</code>多态性是面向对象编程的又一个重要特征，它是指在父类中定义的属性和方法被子类继承之后，可以具有不同的数据类型或表现出不同的行为，这使得同一个属性或方法在父类及其各个子类中具有不同的含义<code>&lt;br /&gt;</code>对面向对象来说，多态分为编译时多态和运行时多态。其中编译时多态是静态的，主要是指方法的重载，它是根据参数列表的不同来区分不同的方法。通过编译之后会变成两个不同的方法，在运行时谈不上多态。而运行时多态是动态的，它是通过动态绑定来实现的，也就是大家通常所说的多态性。<code>&lt;br /&gt;</code><a href="http://c.biancheng.net/java/">Java</a> 实现多态有 3 个必要条件：继承、重写和向上转型。</p><ul><li>继承：在多态中必须存在有继承关系的子类和父类。</li><li>重写：子类对父类中某些方法进行重新定义，在调用这些方法时就会调用子类的方法。</li><li>向上转型：在多态中需要将子类的引用赋给父类对象，只有这样该引用才既能可以调用父类的方法，又能调用子类的方法。</li></ul><p>3.反射<code>&lt;br /&gt;</code>1） 什么是反射<code>&lt;br /&gt;</code>2） 优缺点<code>&lt;br /&gt;</code>3） 使用场景<code>&lt;br /&gt;</code>什么是反射？<code>&lt;br /&gt;</code>反射就是Reflection，Java的反射是指程序在运行期可以拿到一个对象的所有信息。<code>&lt;br /&gt;</code>正常情况下，如果我们要调用一个对象的方法，或者访问一个对象的字段，通常会传入对象实例<code>&lt;br /&gt;</code><img src="https://cdn.nlark.com/yuque/0/2022/png/33764834/1668330137754-9f579263-79ef-448c-b936-986f5a9d54bb.png#averageHue=%23e4e3e3&crop=0&crop=0&crop=1&crop=1&id=BSzas&originHeight=1030&originWidth=2054&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><code>&lt;br /&gt;</code><img src="https://cdn.nlark.com/yuque/0/2022/png/33764834/1668330138272-befffe0c-bb77-47ed-b980-5e0e82b306ca.png#averageHue=%23e3e3e3&crop=0&crop=0&crop=1&crop=1&id=NQJWO&originHeight=821&originWidth=1348&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><code>&lt;br /&gt;</code><img src="https://cdn.nlark.com/yuque/0/2022/png/33764834/1668330138784-357198e1-e840-433d-a747-456dc76c9a44.png#averageHue=%23f6f6f5&crop=0&crop=0&crop=1&crop=1&id=xZUIL&originHeight=497&originWidth=1662&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><code>&lt;br /&gt;</code>一个类在内存中只有一个Class对象<code>&lt;br /&gt;</code>一个类被加载后,类的整个结构都会被封装在Class对象中<code>&lt;br /&gt;</code><img src="https://cdn.nlark.com/yuque/0/2022/png/33764834/1668330139670-2a65d9d4-0d13-45ed-8a92-67dfbea66f2d.png#averageHue=%23e7e5e5&crop=0&crop=0&crop=1&crop=1&id=DvuCJ&originHeight=1192&originWidth=2255&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><code>&lt;br /&gt;</code><img src="https://cdn.nlark.com/yuque/0/2022/png/33764834/1668330140491-81e63274-6db8-4af6-8c3f-5907bdec8473.png#averageHue=%23b9c0e4&crop=0&crop=0&crop=1&crop=1&id=txm1s&originHeight=1159&originWidth=2195&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><code>&lt;br /&gt;</code><img src="https://cdn.nlark.com/yuque/0/2022/png/33764834/1668330141330-6419408f-6dc1-473a-82a0-a3e48e58aaad.png#averageHue=%23f6f6f6&crop=0&crop=0&crop=1&crop=1&id=MdiIO&originHeight=919&originWidth=1839&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><code>&lt;br /&gt;</code>如何获取一个class的Class实例？有三个方法：<code>&lt;br /&gt;</code>方法一：直接通过一个class的静态变量class获取：<code>&lt;br /&gt;</code>方法二：如果我们有一个实例变量，可以通过该实例变量提供的getClass()方法获取：<code>&lt;br /&gt;</code>方法三：如果知道一个class的完整类名，可以通过静态方法Class.forName()获取：<code>&lt;br /&gt;</code>JVM为每个加载的class及interface创建了对应的Class实例来保存class及interface的所有信息；<code>&lt;br /&gt;</code>获取一个class对应的Class实例后，就可以获取该class的所有信息；<code>&lt;br /&gt;</code>通过Class实例获取class信息的方法称为反射（Reflection）；<code>&lt;br /&gt;</code>JVM总是动态加载class，可以在运行期根据条件来控制加载class。<code>&lt;br /&gt;</code>Java的反射API提供的Field类封装了字段的所有信息：<code>&lt;br /&gt;</code>通过Class实例的方法可以获取Field实例：getField()，getFields()，getDeclaredField()，getDeclaredFields()；<code>&lt;br /&gt;</code>通过Field实例可以获取字段信息：getName()，getType()，getModifiers()；<code>&lt;br /&gt;</code>通过Field实例可以读取或设置某个对象的字段，如果存在访问限制，要首先调用setAccessible(true)来访问非public字段。<code>&lt;br /&gt;</code>通过反射读写字段是一种非常规方法，它会破坏对象的封装。</p><ol><li>I\O流</li></ol><p>1） 序列化和反序列化的作用<code>&lt;br /&gt;</code>2） 键盘输入的实现方式<code>&lt;br /&gt;</code>3） 避免序列化的方法<code>&lt;br /&gt;</code>4） 字节流和字符流<code>&lt;br /&gt;</code> 序列化和反序列化的作用</p><ul><li>序列化：把对象转换为字节序列的过程称为对象的序列化.</li><li>反序列化：把字节序列恢复为对象的过程称为对象的反序列化.</li></ul><p>序列化是指把一个Java对象变成二进制内容，本质上就是一个byte[]数组。<code>&lt;br /&gt;</code>为什么要把Java对象序列化呢？<code>&lt;br /&gt;</code>因为序列化后可以把byte[]保存到文件中，或者把byte[]通过网络传输到远程，这样，就相当于把Java对象存储到文件或者通过网络传输出去了。<code>&lt;br /&gt;</code>有序列化，就有反序列化，即把一个二进制内容（也就是byte[]数组）变回Java对象。有了反序列化，保存到文件中的byte[]数组又可以“变回”Java对象，或者从网络上读取byte[]并把它“变回”Java对象。<code>&lt;br /&gt;</code>————————————————<code>&lt;br /&gt;</code>所以序列化和反序列化的作用是：<code>&lt;br /&gt;</code>1、把对象转成JSON、xml 的时候，往往这些接口、方法 都实现了序列化，因为网络传输也是一个二进制的过程，需要进行转换<code>&lt;br /&gt;</code>所以只要我们对内存中的对象进行持久化或网络传输， 这个时候都需要序列化和反序列化.<code>&lt;br /&gt;</code>2、还有一个作用就是把对象的字节序列永久地保存到硬盘上 ，比如通过mybatis可持久化到MySQL，也是实现了序列化的。<code>&lt;br /&gt;</code>————————————————<code>&lt;br /&gt;</code>序列化最重要的作用：在传递和保存对象时.保证对象的完整性和可传递性。对象转换为有序字节流,以便在网络上传输或者保存在本地文件中。<code>&lt;br /&gt;</code>反序列化的最重要的作用：根据字节流中保存的对象状态及描述信息，通过反序列化重建对象。<code>&lt;br /&gt;</code>总结：核心作用就是对象状态的保存和重建。（整个过程核心点就是字节流中所保存的对象状态及描述信息）<code>&lt;br /&gt;</code>————————————————<br><code>&lt;a name=&quot;fpil7&quot;&gt;&lt;/a&gt;</code></p><h2 id="序列化的其他特性"><a href="#序列化的其他特性" class="headerlink" title="序列化的其他特性"></a>序列化的其他特性</h2><p><code>&lt;a name=&quot;RbZoI&quot;&gt;&lt;/a&gt;</code></p><h3 id="1、static-属性不会被序列化"><a href="#1、static-属性不会被序列化" class="headerlink" title="1、static 属性不会被序列化"></a>1、static 属性不会被序列化</h3><p><code>&lt;a name=&quot;3oJG5&quot;&gt;&lt;/a&gt;</code></p><h3 id="2、transient-修饰的属性，也不会被序列化"><a href="#2、transient-修饰的属性，也不会被序列化" class="headerlink" title="2、transient 修饰的属性，也不会被序列化"></a>2、transient 修饰的属性，也不会被序列化</h3><p>二、Java实现序列化和反序列化的过程<code>&lt;br /&gt;</code>1、实现序列化的必备要求：<code>&lt;br /&gt;</code>只有实现了Serializable或者Externalizable接口的类的对象才能被序列化为字节序列。（不是则会抛出异常） <code>&lt;br /&gt;</code>2、JDK中序列化和反序列化的API：<code>&lt;br /&gt;</code>①java.io.ObjectInputStream：对象输入流。<code>&lt;br /&gt;</code>该类的readObject()方法从输入流中读取字节序列，然后将字节序列反序列化为一个对象并返回。<code>&lt;br /&gt;</code>②java.io.ObjectOutputStream：对象输出流。<code>&lt;br /&gt;</code>该类的writeObject(Object obj)方法将将传入的obj对象进行序列化，把得到的字节序列写入到目标输出流中进行输出。<code>&lt;br /&gt;</code>3、实现序列化和反序列化的三种实现：<code>&lt;br /&gt;</code>①若Student类仅仅实现了Serializable接口，则可以按照以下方式进行序列化和反序列化。<code>&lt;br /&gt;</code>ObjectOutputStream采用默认的序列化方式，对Student对象的非transient的实例变量进行序列化。 <code>&lt;br /&gt;</code>ObjcetInputStream采用默认的反序列化方式，对Student对象的非transient的实例变量进行反序列化。<code>&lt;br /&gt;</code>②若Student类仅仅实现了Serializable接口，并且还定义了readObject(ObjectInputStream in)和writeObject(ObjectOutputSteam out)，则采用以下方式进行序列化与反序列化。<code>&lt;br /&gt;</code>ObjectOutputStream调用Student对象的writeObject(ObjectOutputStream out)的方法进行序列化。 <code>&lt;br /&gt;</code>ObjectInputStream会调用Student对象的readObject(ObjectInputStream in)的方法进行反序列化。<code>&lt;br /&gt;</code>③若Student类实现了Externalnalizable接口，且Student类必须实现readExternal(ObjectInput in)和writeExternal(ObjectOutput out)方法，则按照以下方式进行序列化与反序列化。<code>&lt;br /&gt;</code>ObjectOutputStream调用Student对象的writeExternal(ObjectOutput out))的方法进行序列化。 <code>&lt;br /&gt;</code>ObjectInputStream会调用Student对象的readExternal(ObjectInput in)的方法进行反序列化。<code>&lt;br /&gt;</code>三、序列化和反序列化的注意点：<code>&lt;br /&gt;</code>①序列化时，只对对象的状态进行保存，而不管对象的方法。<code>&lt;br /&gt;</code>②当一个父类实现序列化，子类自动实现序列化，不需要显式实现Serializable接口。<code>&lt;br /&gt;</code>③当一个对象的实例变量引用其他对象，序列化该对象时也把引用对象进行序列化。<code>&lt;br /&gt;</code>④并非所有的对象都可以序列化，至于为什么不可以，有很多原因了，比如：<code>&lt;br /&gt;</code>安全方面的原因，比如一个对象拥有private，public等field，对于一个要传输的对象，比如写到文件，或者进行RMI传输等等，在序列化进行传输的过程中，这个对象的private等域是不受保护的；<code>&lt;br /&gt;</code>资源分配方面的原因，比如socket，thread类，如果可以序列化，进行传输或者保存，也无法对他们进行重新的资源分配，而且，也是没有必要这样实现；<code>&lt;br /&gt;</code>⑤声明为static和transient类型的成员数据不能被序列化。因为static代表类的状态，transient代表对象的临时数据。<code>&lt;br /&gt;</code>⑥序列化运行时使用一个称为 serialVersionUID 的版本号与每个可序列化类相关联，该序列号在反序列化过程中用于验证序列化对象的发送者和接收者是否为该对象加载了与序列化兼容的类。为它赋予明确的值。显式地定义serialVersionUID有两种用途。<code>&lt;br /&gt;</code>在某些场合，希望类的不同版本对序列化兼容，因此需要确保类的不同版本具有相同的serialVersionUID。<code>&lt;br /&gt;</code>在某些场合，不希望类的不同版本对序列化兼容，因此需要确保类的不同版本具有不同的serialVersionUID。<code>&lt;br /&gt;</code>⑦Java有很多基础类已经实现了serializable接口，比如String,Vector等。但是也有一些没有实现serializable接口的。<code>&lt;br /&gt;</code>⑧如果一个对象的成员变量是一个对象，那么这个对象的数据成员也会被保存！这是能用序列化解决深拷贝的重要原因。<code>&lt;br /&gt;</code>————————————————<code>&lt;br /&gt;</code> 键盘输入的实现方式</p><ul><li>System.in和System.out方法</li><li><ul><li>缺点一: 该方法能获取从键盘输入的字符，但只能针对一个字符的获取 * 缺点二: 获取的只是char类型的。如果想获得int,float等类型的输入,比较麻烦。</li></ul></li><li><br /></li><li>InputStreamReader和BufferedReader方法<ul><li>优点: 可以获取键盘输入的字符串</li><li>缺点: 如何要获取的是int,float等类型的仍然需要转换</li></ul></li><li>Scanner类中的方法<ul><li>优点一: 可以获取键盘输入的字符串</li><li>优点二: 有现成的获取int,float等类型数据，非常强大，也非常方便；</li></ul></li></ul><p> 避免序列化的方法<br><code>&lt;a name=&quot;DwYth&quot;&gt;&lt;/a&gt;</code></p><h4 id="方式一：transient-关键字"><a href="#方式一：transient-关键字" class="headerlink" title="方式一：transient 关键字"></a>方式一：transient 关键字</h4><p>对于不想进行序列化的变量，使用 transient 关键字修饰。<code>&lt;br /&gt;</code>transient 关键字的作用是：<code>&lt;br /&gt;</code>阻止实例中那些用此关键字修饰的的变量序列化；  <code>&lt;br /&gt;</code>当对象被反序列化时，被 transient 修饰的变量值不会被持久化和恢复。  <code>&lt;br /&gt;</code>transient 只能修饰变量，不能修饰类和方法。<code>&lt;br /&gt;</code>使用 transient 来描述字段，将不能被序列化和反序列化’<br><code>&lt;a name=&quot;DT2Hq&quot;&gt;&lt;/a&gt;</code></p><h4 id="方式二：-Expose注解"><a href="#方式二：-Expose注解" class="headerlink" title="方式二：@Expose注解"></a>方式二：@Expose注解</h4><p>当你不需要完全<a href="https://www.jianshu.com/p/ab9147150a83">序列化</a>model字段时，我们就可以使用 @Expose 来解决。<code>&lt;br /&gt;</code>@Expose 默认有两个属性：serialize 和 deserialize，默认值都为 true，如果你给字段设置了 @Expose 注解，但是没有设置serialize 和 deserialize，那 model 的字段都将会输出。<br><code>&lt;a name=&quot;nWNSr&quot;&gt;&lt;/a&gt;</code></p><h2 id="什么是字节流，什么是字符流"><a href="#什么是字节流，什么是字符流" class="headerlink" title="什么是字节流，什么是字符流"></a>什么是字节流，什么是<a href="https://so.csdn.net/so/search?q=%E5%AD%97%E7%AC%A6%E6%B5%81&spm=1001.2101.3001.7020">字符流</a></h2><p>字节流： 它处理单元为1个字节（byte），操作字节和字节数组，存储的是二进制文件，如果是音频文件、图片、歌曲，就用字节流好点（1byte &#x3D; 8位）；<code>&lt;br /&gt;</code>字符流： 它处理的单元为2个字节的Unicode字符，分别操作字符、字符数组或字符串，字符流是由Java虚拟机将字节转化为2个字节的Unicode字符为单位的字符而成的，如果是关系到中文（文本）的，用字符流好点（1Unicode &#x3D; 2字节 &#x3D; 16位）；<code>&lt;br /&gt;</code>所有文件的储存是都是字节（byte）的储存，在磁盘上保留的并不是文件的字符而是先把字符编码成字节，再储存这些字节到磁盘。在读取文件（特别是文本文件）时，也是一个字节一个字节地读取以形成字节序列。<code>&lt;br /&gt;</code>字节流可用于任何类型的对象，包括二进制对象，而字符流只能处理字符或者字符串； 2. 字节流提供了处理任何类型的IO操作的功能，但它不能直接处理Unicode字符，而字符流就可以。<code>&lt;br /&gt;</code>字节流是最基本的，所有的InputStrem和OutputStream的子类都是,主要用在处理二进制数据，它是按字节来处理的 但实际中很多的数据是文本，又提出了字符流的概念，它是按虚拟机的encode来处理，也就是要进行字符集的转化 这两个之间通过 InputStreamReader,OutputStreamWriter来关联，实际上是通过byte[]和String来关联 在实际开发中出现的汉字问题实际上都是在字符流和字节流之间转化不统一而造成的<code>&lt;br /&gt;</code>————————————————<code>&lt;br /&gt;</code><strong>最简单的区分字节流和字符流</strong><code>&lt;br /&gt;</code>万物皆文件，那就将文件在记事本里面打开，如果打开后能看的懂的就是字符流，如果看不懂那就是字节流<code>&lt;br /&gt;</code><img src="https://cdn.nlark.com/yuque/0/2022/png/33764834/1668330141837-ac999bfb-3998-47a2-95d6-80023a8f9118.png#averageHue=%231e1c1c&crop=0&crop=0&crop=1&crop=1&id=RUS5d&originHeight=1061&originWidth=1145&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><ul><li>字符流是以Reader，Writer结尾的</li><li>字符节流是以InputStream或OutputStream结尾的</li><li>字符流是以Reader，Writer结尾的</li><li>字符节流是以InputStream或OutputStream结尾的</li></ul><p>什么是缓存区？<code>&lt;br /&gt;</code>定义：缓存区相当于缓存，它是存在内存中的<code>&lt;br /&gt;</code>写操作：<code>&lt;br /&gt;</code>没有使用缓存区：CPU读取每个字节之后直接操作磁盘（性能比较底）进行写完，写操作的瓶颈就会出现，因为每个字节都会操作一次磁盘<code>&lt;br /&gt;</code>使用缓冲区：那么每次会将字符放入缓存区（内存），等缓冲区满了之后，才一次性写入磁盘<code>&lt;br /&gt;</code>因为内存的操作速度远远大于磁盘，因此带缓冲区的输入流和输出流实现的效率就非常高（比如扔垃圾，一次性扔完和一次次扔肯定消耗的时间是有很大差距的）<code>&lt;br /&gt;</code>————————————————<br><code>&lt;a name=&quot;x7VJj&quot;&gt;&lt;/a&gt;</code></p><h4 id="5-1-普通的字符流操作"><a href="#5-1-普通的字符流操作" class="headerlink" title="5.1.普通的字符流操作"></a>5.1.普通的字符流操作</h4><p>在程序中一个字符等于两个字节，那么java提供了Reader、Writer两个专门操作字符流的类。<code>&lt;br /&gt;</code>字符输出流：Writer。  <code>&lt;br /&gt;</code>字符输入流：Reader<code>&lt;br /&gt;</code>字节流操作的基本单元是字节；字符流操作的基本单元为Unicode码元。<code>&lt;br /&gt;</code>字节流在操作的时候本身不会用到缓冲区的，是与文件本身直接操作的；而字符流在操作的时候使用到缓冲区的。<code>&lt;br /&gt;</code>所有文件的存储都是字节(byte)的存储，在磁盘上保留的是字节。<code>&lt;br /&gt;</code>在使用字节流操作中，即使没有关闭资源（close方法），也能输出；而字符流不使用close方法的话，不会输出任何内容<code>&lt;br /&gt;</code>————————————————<code>&lt;br /&gt;</code>io流<code>&lt;br /&gt;</code>IO是指Input&#x2F;Output，即输入和输出。以内存为中心：</p><ul><li>Input指从外部读入数据到内存，例如，把文件从磁盘读取到内存，从网络读取数据到内存等等。</li><li>Output指把数据从内存输出到外部，例如，把数据从内存写入到文件，把数据从内存输出到网络等等。</li></ul><p>为什么要把数据读到内存才能处理这些数据？<code>&lt;br /&gt;</code>因为代码是在内存中运行的，数据也必须读到内存，最终的表示方式无非是byte数组，字符串等，都必须存放在内存里。<code>&lt;br /&gt;</code>在Java中，InputStream代表输入字节流，OuputStream代表输出字节流，这是最基本的两种IO流<code>&lt;br /&gt;</code>IO流是一种流式的数据输入&#x2F;输出模型：</p><ul><li>二进制数据以byte为最小单位在InputStream&#x2F;OutputStream中单向流动；</li><li>字符数据以char为最小单位在Reader&#x2F;Writer中单向流动。</li></ul><p>Java标准库的java.io包提供了同步IO功能：</p><ul><li>字节流接口：InputStream&#x2F;OutputStream；</li><li>字符流接口：Reader&#x2F;Writer。</li></ul><p>File对象有3种形式表示的路径，一种是getPath()，返回构造方法传入的路径，一种是getAbsolutePath()，返回绝对路径，一种是getCanonicalPath，它和绝对路径类似，但是返回的是规范路径。<code>&lt;br /&gt;</code>ile对象既可以表示文件，也可以表示目录。特别要注意的是，构造一个File对象，即使传入的文件或目录不存在，代码也不会出错，因为构造一个File对象，并不会导致任何磁盘操作。只有当我们调用File对象的某些方法的时候，才真正进行磁盘操作。<code>&lt;br /&gt;</code>例如，调用isFile()，判断该File对象是否是一个已存在的文件，调用isDirectory()，判断该File对象是否是一个已存在的目录：<code>&lt;br /&gt;</code>用File对象获取到一个文件时，还可以进一步判断文件的权限和大小：</p><ul><li>boolean canRead()：是否可读；</li><li>boolean canWrite()：是否可写；</li><li>boolean canExecute()：是否可执行；</li><li>long length()：文件字节大小。</li></ul><p>对目录而言，是否可执行表示能否列出它包含的文件和子目录。<br><code>&lt;a name=&quot;OA13U&quot;&gt;&lt;/a&gt;</code></p><h3 id="创建和删除文件"><a href="#创建和删除文件" class="headerlink" title="创建和删除文件"></a>创建和删除文件</h3><p>当File对象表示一个文件时，可以通过createNewFile()创建一个新文件，用delete()删除该文件：<code>&lt;br /&gt;</code>有些时候，程序需要读写一些临时文件，File对象提供了createTempFile()来创建一个临时文件，以及deleteOnExit()在JVM退出时自动删除该文件。<br><code>&lt;a name=&quot;bb5G5&quot;&gt;&lt;/a&gt;</code></p><h3 id="遍历文件和目录"><a href="#遍历文件和目录" class="headerlink" title="遍历文件和目录"></a>遍历文件和目录</h3><p>当File对象表示一个目录时，可以使用list()和listFiles()列出目录下的文件和子目录名。listFiles()提供了一系列重载方法，可以过滤不想要的文件和目录：</p><ol><li>新特性</li></ol><p>1） Java8的新特性<code>&lt;br /&gt;</code>2） Streams流<code>&lt;br /&gt;</code>3） Lambda表达式<code>&lt;br /&gt;</code>Java8新特性<code>&lt;br /&gt;</code><img src="https://cdn.nlark.com/yuque/0/2022/png/33764834/1668330142217-e29871e5-f70a-487e-82d2-e6fa42028774.png#averageHue=%23f7f7f7&crop=0&crop=0&crop=1&crop=1&id=uBZ5t&originHeight=957&originWidth=646&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><ul><li>速度更快</li><li>代码更少(增加了新的语法：<strong>Lambda</strong> <strong>表达式</strong>)</li><li>强大的 <strong>Stream API</strong></li><li>便于并行</li><li>最大化减少空指针异常：Optional</li><li>Nashorn引擎，允许在JVM上运行JS应用</li></ul><p>Lambda 表达式：在Java 8 语言中引入的一种新的语法元素和操作符。这个操作符为 “-&gt;” ， 该操作符被称为 Lambda 操作符 或箭头操作符。它将 Lambda 分为两个部分：<code>&lt;br /&gt;</code>左侧：指定了 Lambda 表达式需要的参数列表 （其实就是接口中的抽象方法的形参列表）<code>&lt;br /&gt;</code><strong>右侧：</strong>指定了 Lambda 体，是抽象方法的实现逻辑，（其实就是重写的抽象方法的方法体）<code>&lt;br /&gt;</code>————————————————<code>&lt;br /&gt;</code>-&gt;左边：lambda形参列表的参数类型可以省略(类型推断)；如果lambda形参列表只有一个参数，其一对()也可以省略<code>&lt;br /&gt;</code>-&gt;右边：lambda体应该使用一对{}包裹；如果lambda体只有一条执行语句（可能是return语句），省略这一对{}和return关键字<code>&lt;br /&gt;</code>Lambda表达式的本质：作为函数式接口的实例<code>&lt;br /&gt;</code>如果一个接口中，只声明了一个抽象方法，则此接口就称为函数式接口。我们可以在一个接口上使用 @FunctionalInterface 注解，这样做可以检查它是否是一个函数式接口。<code>&lt;br /&gt;</code>以前用匿名实现类表示的现在都可以用Lambda表达式来写。<code>&lt;br /&gt;</code>————————————————<code>&lt;br /&gt;</code>类型推断<code>&lt;br /&gt;</code>在Lambda 表达式中的参数类型都是由编译器推断得出的。Lambda 表达式中无需指定类型，程序依然可以编译，这是因为 javac 根据程序的上下文，在后台推断出了参数的类型。Lambda 表达式的类型依赖于上下文环境，是由编译器推断出来的。这就是所谓的“类型推断”。<code>&lt;br /&gt;</code>————————————————<code>&lt;br /&gt;</code><strong>什么是 Stream</strong><code>&lt;br /&gt;</code>Stream到底是什么呢？是数据渠道，用于操作数据源（集合、数组等）所生成的元素序列。<code>&lt;br /&gt;</code>“集合讲的是数据，Stream讲的是计算！”<code>&lt;br /&gt;</code>注意：<code>&lt;br /&gt;</code>①Stream 自己不会存储元素。<code>&lt;br /&gt;</code>②Stream 不会改变源对象。相反，他们会返回一个持有结果的新Stream。<code>&lt;br /&gt;</code>③Stream 操作是延迟执行的。这意味着他们会等到需要结果的时候才执行。<code>&lt;br /&gt;</code>————————————————<code>&lt;br /&gt;</code><img src="https://cdn.nlark.com/yuque/0/2022/png/33764834/1668330142771-2e2e385f-82b1-4bd1-abfb-49372be35578.png#averageHue=%23f3f3f2&crop=0&crop=0&crop=1&crop=1&id=Eu1Uf&originHeight=956&originWidth=1407&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><code>&lt;br /&gt;</code>5.3 Stream创建方式<code>&lt;br /&gt;</code>创建 Stream方式一：通过集合<code>&lt;br /&gt;</code>Java8 中的 Collection 接口被扩展，提供了两个获取流<code>&lt;br /&gt;</code>的方法：<code>&lt;br /&gt;</code>default Stream stream() : 返回一个顺序流<code>&lt;br /&gt;</code>default Stream parallelStream() : 返回一个并行流<code>&lt;br /&gt;</code>————————————————<code>&lt;br /&gt;</code>创建 Stream方式二：通过数组<code>&lt;br /&gt;</code>Java8 中的 Arrays 的静态方法 stream() 可以获取数组流：<code>&lt;br /&gt;</code>static Stream stream(T[] array): 返回一个流<code>&lt;br /&gt;</code>重载形式，能够处理对应基本类型的数组：<code>&lt;br /&gt;</code>public static IntStream stream(int[] array)<code>&lt;br /&gt;</code>public static LongStream stream(long[] array)<code>&lt;br /&gt;</code>public static DoubleStream stream(double[] array)<code>&lt;br /&gt;</code>————————————————<code>&lt;br /&gt;</code><strong>创建 Stream方式三：通过Stream的of()</strong><code>&lt;br /&gt;</code><strong>可以调用Stream类静态方法 of(), 通过显示值创建一个流。它可以接收任意数量的参数。</strong></p><ul><li><strong>public static Stream of(T… values) :</strong> <strong>返回一个流</strong></li></ul><p>可以使用静态方法 Stream.iterate() 和 Stream.generate(),创建无限流。<code>&lt;br /&gt;</code>迭代<code>&lt;br /&gt;</code>public static Stream iterate(final T seed, final UnaryOperator f)<code>&lt;br /&gt;</code>生成<code>&lt;br /&gt;</code>public static Stream generate(Supplier s)<code>&lt;br /&gt;</code>————————————————<code>&lt;br /&gt;</code><img src="https://cdn.nlark.com/yuque/0/2022/png/33764834/1668330143281-598d9c0c-c6ee-4f6e-beb6-59dc79f86cfe.png#averageHue=%23bdad93&crop=0&crop=0&crop=1&crop=1&id=v1dLd&originHeight=878&originWidth=1909&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><code>&lt;br /&gt;</code><img src="https://cdn.nlark.com/yuque/0/2022/png/33764834/1668330143962-7c9ebd53-6c36-448e-b917-090d12d7301f.png#averageHue=%23c0cfda&crop=0&crop=0&crop=1&crop=1&id=pwQuc&originHeight=744&originWidth=1481&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><code>&lt;br /&gt;</code><img src="https://cdn.nlark.com/yuque/0/2022/png/33764834/1668330144437-95dd3461-1b0b-4c27-a552-036683df62c7.png#averageHue=%23c6d2d5&crop=0&crop=0&crop=1&crop=1&id=l0ZWX&originHeight=473&originWidth=1340&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><code>&lt;br /&gt;</code><img src="https://cdn.nlark.com/yuque/0/2022/png/33764834/1668330144958-8ba8060d-8dcd-4738-8b32-3191e43479f8.png#averageHue=%23f3f2f2&crop=0&crop=0&crop=1&crop=1&id=MTYjc&originHeight=261&originWidth=1543&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><code>&lt;br /&gt;</code><img src="https://cdn.nlark.com/yuque/0/2022/png/33764834/1668330145378-3af384fa-fe36-4f7f-b226-22df5edbd2cf.png#averageHue=%23c2d1da&crop=0&crop=0&crop=1&crop=1&id=UA5wM&originHeight=1059&originWidth=1468&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><code>&lt;br /&gt;</code><img src="https://cdn.nlark.com/yuque/0/2022/png/33764834/1668330146141-a924105c-073e-4cf8-a224-d8717c5d7450.png#averageHue=%23c2c9c7&crop=0&crop=0&crop=1&crop=1&id=L5rAR&originHeight=431&originWidth=1459&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><code>&lt;br /&gt;</code><img src="https://cdn.nlark.com/yuque/0/2022/png/33764834/1668330146701-2466240f-ee3f-4c65-9924-767e34878834.png#averageHue=%23dee7e7&crop=0&crop=0&crop=1&crop=1&id=wODWq&originHeight=1150&originWidth=1488&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><code>&lt;br /&gt;</code>Date类<code>&lt;br /&gt;</code><img src="https://cdn.nlark.com/yuque/0/2022/png/33764834/1668330147377-b7aa1ffa-2224-495e-af3d-4badabe5e6f8.png#averageHue=%23b0c3dd&crop=0&crop=0&crop=1&crop=1&id=vHZhi&originHeight=776&originWidth=1180&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br><code>&lt;a name=&quot;3mGrc&quot;&gt;&lt;/a&gt;</code></p><h2 id="Instant-时间戳"><a href="#Instant-时间戳" class="headerlink" title="Instant 时间戳"></a>Instant 时间戳</h2><p>用于“时间戳”的运算。它是以Unix元年(传统的设定为UTC时区1970年1月1日午夜时分)开始所经历的描述进行运算<br><code>&lt;a name=&quot;3Y9Ex&quot;&gt;&lt;/a&gt;</code></p><h2 id="7-3Duration-和-Period"><a href="#7-3Duration-和-Period" class="headerlink" title="7.3Duration 和 Period"></a>7.3Duration 和 Period</h2><p>⚫ Duration:用于计算两个“时间”间隔<code>&lt;br /&gt;</code>⚫ Period:用于计算两个“日期”间隔<br><code>&lt;a name=&quot;vTdzD&quot;&gt;&lt;/a&gt;</code></p><h2 id="7-4日期的操纵"><a href="#7-4日期的操纵" class="headerlink" title="7.4日期的操纵"></a>7.4日期的操纵</h2><p>⚫ TemporalAdjuster : 时间校正器。有时我们可能需要获取例如：将日期调整到“下个周日”等操作。<code>&lt;br /&gt;</code>⚫ TemporalAdjusters: 该类通过静态方法提供了大量的常用 TemporalAdjuster 的实现。<br><code>&lt;a name=&quot;dAE4d&quot;&gt;&lt;/a&gt;</code></p><h2 id="7-5解析与格式化"><a href="#7-5解析与格式化" class="headerlink" title="7.5解析与格式化"></a>7.5解析与格式化</h2><p>java.time.format.DateTimeFormatter类：该类提供了三种格式化方法：<code>&lt;br /&gt;</code>⚫ 预定义的标准格式<code>&lt;br /&gt;</code>⚫ 语言环境相关的格式<code>&lt;br /&gt;</code>⚫ 自定义的格式<code>&lt;br /&gt;</code>7.6时区的处理<code>&lt;br /&gt;</code>⚫ Java8 中加入了对时区的支持，带时区的时间为分别为：ZonedDate、ZonedTime、ZonedDateTime<code>&lt;br /&gt;</code>其中每个时区都对应着 ID，地区ID都为 “{区域}&#x2F;{城市}”的格式<code>&lt;br /&gt;</code>例如 ：Asia&#x2F;Shanghai 等<code>&lt;br /&gt;</code>ZoneId：该类中包含了所有的时区信息<code>&lt;br /&gt;</code>getAvailableZoneIds() : 可以获取所有时区时区信息<code>&lt;br /&gt;</code>of(id) : 用指定的时区信息获取ZoneId 对象<code>&lt;br /&gt;</code>————————————————<code>&lt;br /&gt;</code><img src="https://cdn.nlark.com/yuque/0/2022/png/33764834/1668330148209-3ff9fd27-6654-45a0-86c8-5d6fb9306ac8.png#averageHue=%23a9bbd6&crop=0&crop=0&crop=1&crop=1&id=sbUhA&originHeight=1159&originWidth=1749&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br><code>&lt;a name=&quot;xYdCw&quot;&gt;&lt;/a&gt;</code></p><h1 id="Java8新特性"><a href="#Java8新特性" class="headerlink" title="Java8新特性"></a>Java8新特性</h1><p><a href="https://juejin.cn/post/6962035387787116551">Java之Java 8新特性 - 掘金 (juejin.cn)</a><code>&lt;br /&gt;</code>——Map的新方法<code>&lt;br /&gt;</code>Map 类型不支持 streams，不过Map提供了一些新的有用的方法来处理一些日常任务。Map接口本身没有可用的 stream（）方法，但是你可以在键，值上创建专门的流或者通过 map.keySet().stream(),map.values().stream()和map.entrySet().stream()。<code>&lt;br /&gt;</code>此外,Maps 支持各种新的和有用的方法来执行常见任务。<code>&lt;br /&gt;</code>————————————————<code>&lt;br /&gt;</code><img src="https://cdn.nlark.com/yuque/0/2022/png/33764834/1668330148717-5656f774-cc0f-46b8-b53d-1a5a64a61c69.png#averageHue=%23f9f8f7&crop=0&crop=0&crop=1&crop=1&id=gyDN5&originHeight=1130&originWidth=1398&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><ol><li>异常体系</li></ol><p>1） 异常层次<code>&lt;br /&gt;</code>2） Throwable 类<code>&lt;br /&gt;</code>3） 异常和错误<br><code>&lt;a name=&quot;7W9Uk&quot;&gt;&lt;/a&gt;</code></p><h1 id="什么是异常"><a href="#什么是异常" class="headerlink" title="什么是异常"></a>什么是异常</h1><p><strong>定义：</strong>在程序运行过程中出现的错误，称为异常。异常就是程序运行过程中出现了不正常现象导致程序的中断。<code>&lt;br /&gt;</code>在Java中，把各种异常现象进行了抽象形成了异常类。<code>&lt;br /&gt;</code><img src="https://cdn.nlark.com/yuque/0/2022/png/33764834/1668330149223-73d8d5ad-9f6d-4b0c-8b67-7d13837635bd.png#averageHue=%23fbf7f2&crop=0&crop=0&crop=1&crop=1&id=iL9OJ&originHeight=787&originWidth=1135&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><code>&lt;br /&gt;</code><img src="https://cdn.nlark.com/yuque/0/2022/png/33764834/1668330149744-4e96f416-67b0-44b1-9ea1-6716574adeb9.png#averageHue=%23f7f6f5&crop=0&crop=0&crop=1&crop=1&id=H2Phn&originHeight=824&originWidth=1405&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><code>&lt;br /&gt;</code><img src="https://cdn.nlark.com/yuque/0/2022/png/33764834/1668330150203-d7e2a887-bbee-47a8-a8a5-db72f5ff7c51.png#averageHue=%23c0c0b0&crop=0&crop=0&crop=1&crop=1&id=YXHQs&originHeight=871&originWidth=1562&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><code>&lt;br /&gt;</code><img src="https://cdn.nlark.com/yuque/0/2022/png/33764834/1668330150789-999d19d2-f790-4875-a2db-fe241f3e8ff1.png#averageHue=%234a5a6a&crop=0&crop=0&crop=1&crop=1&id=mvVuV&originHeight=804&originWidth=1551&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br><code>&lt;a name=&quot;OBAS9&quot;&gt;&lt;/a&gt;</code></p><h3 id="4-1-3-异常的捕获顺序"><a href="#4-1-3-异常的捕获顺序" class="headerlink" title="4.1.3 异常的捕获顺序"></a>4.1.3 异常的捕获顺序</h3><p>异常的捕获：一般按照由小到大的顺序，也就是先截获子异常，再截获父异常<code>&lt;br /&gt;</code>4.2 throws抛出处理<code>&lt;br /&gt;</code>在定义方法时，如果方法体中有受检（编译时）异常需要预处理，可以捕获处理，也可以抛出处理。<code>&lt;br /&gt;</code>处理异常时，使用throws抛出处理：<code>&lt;br /&gt;</code>谁调用这个方法，谁负责处理该异常<code>&lt;br /&gt;</code>在定义方法时，把异常抛出就是为了提醒方法的使用者，有异常需要预处理<code>&lt;br /&gt;</code>在处理异常时，是选择捕获处理还是抛出处理<code>&lt;br /&gt;</code>一般情况下，在调用其他方法时，如果被调用的方法有受检（编译时）异常需要预处理，选择捕获处理，因为你调用了方法， 你负责处理该异常。<code>&lt;br /&gt;</code>在定义方法时，如果方法体中有受检异常需要预处理，可以选择捕获 ，也可以选择抛出处理。如果方法体中通过throw语句抛出了一个异常对象，所在的方法应该使用throws声明该异常。<code>&lt;br /&gt;</code>————————————————<code>&lt;br /&gt;</code>4.3 getMessage()和printStackTrace()<code>&lt;br /&gt;</code>如何取得异常对象的具体信息，常用的方法主要有两种：<code>&lt;br /&gt;</code>获取异常描述信息<code>&lt;br /&gt;</code>使用异常对象的getMessage()方法，通常用于打印日志时<code>&lt;br /&gt;</code>取得异常的堆栈信息<code>&lt;br /&gt;</code>使用异常对象的printStackTrace()方法，比较适合于程序调试阶段<code>&lt;br /&gt;</code>————————————————<code>&lt;br /&gt;</code>4.4 方法覆盖中的异常处理<code>&lt;br /&gt;</code>方法覆盖(重写)规则：<code>&lt;br /&gt;</code>方法签名必须相同，方法名与参数列表就是方法签名<code>&lt;br /&gt;</code>方法的返回值类型可以相同 ，子类方法的返回值类型也可以是父类方法返回值类型的子类型<code>&lt;br /&gt;</code>子类方法的访问权限可以更宽泛(更大)<code>&lt;br /&gt;</code>a、如果父类方法使用public修饰，子类方法只能是public修饰<code>&lt;br /&gt;</code>b、如果父类方法使用protected修饰，子类方法可以是protected或者public修饰<code>&lt;br /&gt;</code>子类方法的异常要比父类方法的异常更小<code>&lt;br /&gt;</code>a、如果父类方法没有抛出异常，子类重写后也不能抛出异常<code>&lt;br /&gt;</code>b、如果父类方法抛出了异常，子类方法可以抛出相同的异常，也可以抛出父类异常的子异常，也可以不抛出异常<code>&lt;br /&gt;</code>————————————————<br><code>&lt;a name=&quot;MRNvG&quot;&gt;&lt;/a&gt;</code></p><h1 id="异常相关的面试题"><a href="#异常相关的面试题" class="headerlink" title="异常相关的面试题"></a>异常相关的面试题</h1><p><code>&lt;a name=&quot;FjgMe&quot;&gt;&lt;/a&gt;</code></p><h2 id="5-1-谈谈你Java异常处理机制的理解？"><a href="#5-1-谈谈你Java异常处理机制的理解？" class="headerlink" title="5.1 谈谈你Java异常处理机制的理解？"></a>5.1 谈谈你Java异常处理机制的理解？</h2><p>Java对异常进行了分类，不同类型的异常分别用不同的Java类表示，所有异常的根类为 java.lang.Throwable，Throwable下面又派生了两个子类：Error和Exception。<code>&lt;br /&gt;</code>Error： 表示应用程序本身无法克服和恢复的一种严重问题。<code>&lt;br /&gt;</code>Exception： 表示程序还能够克服和恢复的问题，其中又分为系统异常和普通异常。<code>&lt;br /&gt;</code>系统异常<code>&lt;br /&gt;</code>系统异常是软件本身缺陷所导致的问题，也就是软件开发人员考虑不周所导致的问题，软件使用者无法克服和恢复这种问题，但在这种问题下还可以让软件系统继续运行或者让软件死掉，例如，数组下标越界（ArrayIndexOutOfBoundsException），空指针异常（NullPointerException）、类转换异常（ClassCastException）。<code>&lt;br /&gt;</code>普通异常<code>&lt;br /&gt;</code>普通异常是运行环境的变化或异常所导致的问题，是用户能够克服的问题，例如，网络断线，硬盘空间不够，发生这样的异常后，程序不应该死掉。<code>&lt;br /&gt;</code>————————————————<code>&lt;br /&gt;</code>Java为系统异常和普通异常提供了不同的解决方案，编译器强制普通异常必须try…catch处理或用throws声明继续抛给上层调用方法处理，所以普通异常也称为checked异常，而系统异常可以处理也可以不处理，所以编译器不强制用try…catch处理或用throws声明，所以系统异常也称为unchecked异常。<code>&lt;br /&gt;</code>5.2 throw 和 throws 的区别？<code>&lt;br /&gt;</code>throw<code>&lt;br /&gt;</code>throw 语句用在方法体内，表示抛出异常，由方法体内的语句处理。<code>&lt;br /&gt;</code>throw是具体向外抛出异常的动作，所以它抛出的是一个异常实例，执行throw一定是抛出了某种异常。<code>&lt;br /&gt;</code>throw一般用于抛出自定义异常。<code>&lt;br /&gt;</code>throws<code>&lt;br /&gt;</code>throws语句是用在方法声明后面，表示如果抛出异常，由该方法的调用者来进行异常的处理。<code>&lt;br /&gt;</code>throws主要是声明这个方法会抛出某种类型的异常，让它的使用者要知道需要捕获的异常的类型。<code>&lt;br /&gt;</code>throws表示出现异常的一种可能性，并不一定会发生这种异常。<code>&lt;br /&gt;</code>————————————————<code>&lt;br /&gt;</code>网络图片：<a href="https://uploadfiles.nowcoder.com/images/20180704/3807435_1530666258064_20577AE82E2EC5D6D44DD2CA01C99BBA">https://uploadfiles.nowcoder.com/images/20180704/3807435_1530666258064_20577AE82E2EC5D6D44DD2CA01C99BBA</a><br><code>&lt;a name=&quot;ka4CG&quot;&gt;&lt;/a&gt;</code></p><h2 id="5-3-final、finally、finalize-的区别？"><a href="#5-3-final、finally、finalize-的区别？" class="headerlink" title="5.3 final、finally、finalize 的区别？"></a>5.3 final、finally、finalize 的区别？</h2><p>*<code>&lt;br /&gt;</code>final<code>&lt;br /&gt;</code>用于声明属性，方法和类，分别表示属性不可变，方法不可覆盖，被其修饰的类不可继承。<code>&lt;br /&gt;</code>finally<code>&lt;br /&gt;</code>异常处理语句结构的一部分，表示总是执行。<code>&lt;br /&gt;</code>finalize<code>&lt;br /&gt;</code>finalize 是Object 类的一个方法，所以Java对象都有这个方法，当某Java对象没有更多的引用指向的时候，会被垃圾回收器回收，该对象被回收之前，由垃圾回收器来负责调用此方法，通常在该方法中进行回收前的准备工作。该方法更像是一个对象生命周期的临终方法，当该方法被系统调用则代表该对象即将“死亡”，但是需要注意的是，我们主动行为上去调用该方法并不会导致该对象“死亡”，<code>&lt;br /&gt;</code>————————————————<code>&lt;br /&gt;</code>5.4 Java中异常分为哪些种类？<code>&lt;br /&gt;</code>按照异常需要处理的时机，分为编译时异常(也叫受控异常)也叫 CheckedException 和运行时异常(也叫非受控异常)也叫 UnCheckedException。Java认为Checked异常都是可以被处理的异常，所以Java程序必须显式处理Checked异常。如果程序没有处理Checked 异常，该程序在编译时就会发生错误无法编译。这体现了Java 的设计哲学：没有完善错误处理的代码根本没有机会被执行。<code>&lt;br /&gt;</code>对Checked异常处理方法有两种：<code>&lt;br /&gt;</code>当前方法知道如何处理该异常，则用try…catch块来处理该异常。<code>&lt;br /&gt;</code>当前方法不知道如何处理，则在定义该方法时声明抛出该异常。<code>&lt;br /&gt;</code>对于运行时异常，只有当代码在运行时才发行的异常，编译的时候不需要try…catch。<code>&lt;br /&gt;</code>比如：除数是0和数组下标越界等，其产生频繁，处理麻烦，若显示申明或者捕获将会对程序的可读性和运行效率影响很大。所以由系统自动检测并将它们交给缺省的异常处理程序。当然如果你有处理要求也可以显示捕获它们。<code>&lt;br /&gt;</code>————————————————<code>&lt;br /&gt;</code>5.5 error和exception的区别？<code>&lt;br /&gt;</code>Error类和Exception类的父类都是Throwable类，他们的区别如下：<code>&lt;br /&gt;</code>Error类一般是指与虚拟机相关的问题，如系统崩溃，虚拟机错误，内存空间不足，方法调用栈溢出等。对于这类错误的导致的应用程序中断，仅靠程序本身无法恢复和预防，遇到这样的错误，建议让程序终止。<code>&lt;br /&gt;</code>Exception类表示程序可以处理的异常，可以捕获且可能恢复。这种异常是由与程序设计的不完善而出现的问题，遇到这类异常，应该尽可能处理异常，使程序恢复运行，而不应该随意终止异常。<code>&lt;br /&gt;</code>Exception类又分为未检查异常（UnCheckedException）和受检查的异常(CheckedException)。<code>&lt;br /&gt;</code>运行时异常ArithmeticException，IllegalArgumentException编译能通过，但是一运行就终止了，程序不会处理运行时异常，出现这类异常，程序会终止。<code>&lt;br /&gt;</code>而受检查的异常，要么用 try…catch 捕获，要么用throws字句声明抛出，交给它的父类处理，否则编译不会通过。<code>&lt;br /&gt;</code>————————————————<code>&lt;br /&gt;</code>5.6 说出最常见的5个RuntimeException？<code>&lt;br /&gt;</code>常见的异常有：<code>&lt;br /&gt;</code>java.lang.NullPointerException 空指针异常；出现原因：调用了未经初始化的对象或者是不存在的对象<code>&lt;br /&gt;</code>java.lang.ClassCastException 数据类型转换异常<code>&lt;br /&gt;</code>java.lang.ClassNotFoundException 指定的类找不到；出现原因：类的名称和路径加载错误；通常都是程序试图通过字符串来加载某个类时可能引发异常<code>&lt;br /&gt;</code>java.lang.NoSuchMethodException 方法不存在异常<code>&lt;br /&gt;</code>java.lang.NumberFormatException 字符串转换为数字异常；出现原因：字符型数据中包含非数字型字符<code>&lt;br /&gt;</code>java.lang.IndexOutOfBoundsException 数组角标越界异常，常见于操作数组对象时发生<code>&lt;br /&gt;</code>java.lang.IllegalArgumentException 方法传递参数错误<code>&lt;br /&gt;</code>java.lang.NoClassDefFoundException 未找到类定义错误<code>&lt;br /&gt;</code>SQLException SQL 异常，常见于操作数据库时的 SQL 语句错误<code>&lt;br /&gt;</code>java.lang.InstantiationException 实例化异常<code>&lt;br /&gt;</code>————————————————<br><code>&lt;a name=&quot;qK8RF&quot;&gt;&lt;/a&gt;</code></p><h1 id="6-总结"><a href="#6-总结" class="headerlink" title="6 总结"></a>6 总结</h1><p>本文主要对Java中的异常相关的知识，进行了一下总结。</p><ul><li>异常的分类</li><li>受控异常和非受控异常的区别</li><li>异常的捕获和抛出处理</li><li>异常的捕获顺序，先捕获小的，再捕获大的</li><li>方法覆盖和异常的关系</li><li>异常的5个关键字try、catch、finally、throws、throw</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2022/png/33764834/1668330151238-81c787aa-e2b8-4a1b-97c0-166bd60aee96.png#averageHue=%23fcfbf1&crop=0&crop=0&crop=1&crop=1&id=rppdX&originHeight=394&originWidth=554&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><code>&lt;br /&gt;</code><a href="https://www.yuque.com/attachments/yuque/0/2022/docx/33764834/1668332908589-eb9de2f3-079d-4b8b-876e-ce1902f16041.docx">Java基础.docx</a></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java宝典基础篇</title>
      <link href="/2022/12/01/%E5%9F%BA%E7%A1%80%E7%AF%87%E8%AE%B2%E4%B9%89/"/>
      <url>/2022/12/01/%E5%9F%BA%E7%A1%80%E7%AF%87%E8%AE%B2%E4%B9%89/</url>
      
        <content type="html"><![CDATA[<h1 id="基础篇"><a href="#基础篇" class="headerlink" title="基础篇"></a>基础篇</h1><blockquote><p><em><strong>基础篇要点：算法、数据结构、基础设计模式</strong></em></p></blockquote><h2 id="1-二分查找"><a href="#1-二分查找" class="headerlink" title="1. 二分查找"></a>1. 二分查找</h2><p><strong>要求</strong></p><ul><li>能够用自己语言描述二分查找算法</li><li>能够手写二分查找代码</li><li>能够解答一些变化后的考法</li></ul><p><strong>算法描述</strong></p><ol><li><p>前提：有已排序数组 A（假设已经做好）</p></li><li><p>定义左边界 L、右边界 R，确定搜索范围，循环执行二分查找（3、4两步）</p></li><li><p>获取中间索引 M &#x3D; Floor((L+R) &#x2F;2)</p></li><li><p>中间索引的值  A[M] 与待搜索的值 T 进行比较</p><p>① A[M] &#x3D;&#x3D; T 表示找到，返回中间索引</p><p>② A[M] &gt; T，中间值右侧的其它元素都大于 T，无需比较，中间索引左边去找，M - 1 设置为右边界，重新查找</p><p>③ A[M] &lt; T，中间值左侧的其它元素都小于 T，无需比较，中间索引右边去找， M + 1 设置为左边界，重新查找</p></li><li><p>当 L &gt; R 时，表示没有找到，应结束循环</p></li></ol><blockquote><p><em>更形象的描述请参考：binary_search.html</em></p></blockquote><p><strong>算法实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> t)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = a.length - <span class="number">1</span>, m;</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">        m = (l + r) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (a[m] == t) &#123;</span><br><span class="line">            <span class="keyword">return</span> m;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a[m] &gt; t) &#123;</span><br><span class="line">            r = m - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            l = m + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>测试代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] array = &#123;<span class="number">1</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">11</span>, <span class="number">19</span>, <span class="number">22</span>, <span class="number">31</span>, <span class="number">35</span>, <span class="number">40</span>, <span class="number">45</span>, <span class="number">48</span>, <span class="number">49</span>, <span class="number">50</span>&#125;;</span><br><span class="line">    <span class="type">int</span> <span class="variable">target</span> <span class="operator">=</span> <span class="number">47</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> binarySearch(array, target);</span><br><span class="line">    System.out.println(idx);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解决整数溢出问题</strong></p><p>当 l 和 r 都较大时，<code>l + r</code> 有可能超过整数范围，造成运算错误，解决方法有两种：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> l + (r - l) / <span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>还有一种是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> (l + r) &gt;&gt;&gt; <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p><strong>其它考法</strong></p><ol><li>有一个有序表为 1,5,8,11,19,22,31,35,40,45,48,49,50 当二分查找值为 48 的结点时，查找成功需要比较的次数</li><li>使用二分法在序列 1,4,6,7,15,33,39,50,64,78,75,81,89,96 中查找元素 81 时，需要经过（   ）次比较</li><li>在拥有128个元素的数组中二分查找一个数，需要比较的次数最多不超过多少次</li></ol><p>对于前两个题目，记得一个简要判断口诀：奇数二分取中间，偶数二分取中间靠左。对于后一道题目，需要知道公式：</p><p>$$<br>n &#x3D; log_2N &#x3D; log_{10}N&#x2F;log_{10}2<br>$$</p><p>其中 n 为查找次数，N 为元素个数</p><h2 id="2-冒泡排序"><a href="#2-冒泡排序" class="headerlink" title="2. 冒泡排序"></a>2. 冒泡排序</h2><p><strong>要求</strong></p><ul><li>能够用自己语言描述冒泡排序算法</li><li>能够手写冒泡排序代码</li><li>了解一些冒泡排序的优化手段</li></ul><p><strong>算法描述</strong></p><ol><li>依次比较数组中相邻两个元素大小，若 a[j] &gt; a[j+1]，则交换两个元素，两两都比较一遍称为一轮冒泡，结果是让最大的元素排至最后</li><li>重复以上步骤，直到整个数组有序</li></ol><blockquote><p><em>更形象的描述请参考：bubble_sort.html</em></p></blockquote><p><strong>算法实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">bubble</span><span class="params">(<span class="type">int</span>[] a)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; a.length - <span class="number">1</span>; j++) &#123;</span><br><span class="line">        <span class="comment">// 一轮冒泡</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">swapped</span> <span class="operator">=</span> <span class="literal">false</span>; <span class="comment">// 是否发生了交换</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; a.length - <span class="number">1</span> - j; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;比较次数&quot;</span> + i);</span><br><span class="line">            <span class="keyword">if</span> (a[i] &gt; a[i + <span class="number">1</span>]) &#123;</span><br><span class="line">                Utils.swap(a, i, i + <span class="number">1</span>);</span><br><span class="line">                swapped = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;第&quot;</span> + j + <span class="string">&quot;轮冒泡&quot;</span></span><br><span class="line">                           + Arrays.toString(a));</span><br><span class="line">        <span class="keyword">if</span> (!swapped) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>优化点1：每经过一轮冒泡，内层循环就可以减少一次</li><li>优化点2：如果某一轮冒泡没有发生交换，则表示所有数据有序，可以结束外层循环</li></ul><p><strong>进一步优化</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">bubble_v2</span><span class="params">(<span class="type">int</span>[] a)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> a.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">last</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 表示最后一次交换索引位置</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;比较次数&quot;</span> + i);</span><br><span class="line">            <span class="keyword">if</span> (a[i] &gt; a[i + <span class="number">1</span>]) &#123;</span><br><span class="line">                Utils.swap(a, i, i + <span class="number">1</span>);</span><br><span class="line">                last = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        n = last;</span><br><span class="line">        System.out.println(<span class="string">&quot;第轮冒泡&quot;</span></span><br><span class="line">                           + Arrays.toString(a));</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>每轮冒泡时，最后一次交换索引可以作为下一轮冒泡的比较次数，如果这个值为零，表示整个数组有序，直接退出外层循环即可</li></ul><h2 id="3-选择排序"><a href="#3-选择排序" class="headerlink" title="3. 选择排序"></a>3. 选择排序</h2><p><strong>要求</strong></p><ul><li>能够用自己语言描述选择排序算法</li><li>能够比较选择排序与冒泡排序</li><li>理解非稳定排序与稳定排序</li></ul><p><strong>算法描述</strong></p><ol><li>将数组分为两个子集，排序的和未排序的，每一轮从未排序的子集中选出最小的元素，放入排序子集</li><li>重复以上步骤，直到整个数组有序</li></ol><blockquote><p><em>更形象的描述请参考：selection_sort.html</em></p></blockquote><p><strong>算法实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">selection</span><span class="params">(<span class="type">int</span>[] a)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; a.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// i 代表每轮选择最小元素要交换到的目标索引</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> i; <span class="comment">// 代表最小元素的索引</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> s + <span class="number">1</span>; j &lt; a.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[s] &gt; a[j]) &#123; <span class="comment">// j 元素比 s 元素还要小, 更新 s</span></span><br><span class="line">                s = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (s != i) &#123;</span><br><span class="line">            swap(a, s, i);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Arrays.toString(a));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>优化点：为减少交换次数，每一轮可以先找最小的索引，在每轮最后再交换元素</li></ul><p><strong>与冒泡排序比较</strong></p><ol><li><p>二者平均时间复杂度都是 $O(n^2)$</p></li><li><p>选择排序一般要快于冒泡，因为其交换次数少</p></li><li><p>但如果集合有序度高，冒泡优于选择</p></li><li><p>冒泡属于稳定排序算法，而选择属于不稳定排序</p><ul><li>稳定排序指，按对象中不同字段进行多次排序，不会打乱同值元素的顺序</li><li>不稳定排序则反之</li></ul></li></ol><p><strong>稳定排序与不稳定排序</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;=================不稳定================&quot;</span>);</span><br><span class="line">Card[] cards = getStaticCards();</span><br><span class="line">System.out.println(Arrays.toString(cards));</span><br><span class="line">selection(cards, Comparator.comparingInt((Card a) -&gt; a.sharpOrder).reversed());</span><br><span class="line">System.out.println(Arrays.toString(cards));</span><br><span class="line">selection(cards, Comparator.comparingInt((Card a) -&gt; a.numberOrder).reversed());</span><br><span class="line">System.out.println(Arrays.toString(cards));</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;=================稳定=================&quot;</span>);</span><br><span class="line">cards = getStaticCards();</span><br><span class="line">System.out.println(Arrays.toString(cards));</span><br><span class="line">bubble(cards, Comparator.comparingInt((Card a) -&gt; a.sharpOrder).reversed());</span><br><span class="line">System.out.println(Arrays.toString(cards));</span><br><span class="line">bubble(cards, Comparator.comparingInt((Card a) -&gt; a.numberOrder).reversed());</span><br><span class="line">System.out.println(Arrays.toString(cards));</span><br></pre></td></tr></table></figure><p>都是先按照花色排序（♠♥♣♦），再按照数字排序（AKQJ…）</p><ul><li><p>不稳定排序算法按数字排序时，会打乱原本同值的花色顺序</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[[♠7], [♠2], [♠4], [♠5], [♥2], [♥5]]</span><br><span class="line">[[♠7], [♠5], [♥5], [♠4], [♥2], [♠2]]</span><br></pre></td></tr></table></figure><p>原来 ♠2 在前 ♥2 在后，按数字再排后，他俩的位置变了</p></li><li><p>稳定排序算法按数字排序时，会保留原本同值的花色顺序，如下所示 ♠2 与 ♥2 的相对位置不变</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[[♠7], [♠2], [♠4], [♠5], [♥2], [♥5]]</span><br><span class="line">[[♠7], [♠5], [♥5], [♠4], [♠2], [♥2]]</span><br></pre></td></tr></table></figure></li></ul><h2 id="4-插入排序"><a href="#4-插入排序" class="headerlink" title="4. 插入排序"></a>4. 插入排序</h2><p><strong>要求</strong></p><ul><li>能够用自己语言描述插入排序算法</li><li>能够比较插入排序与选择排序</li></ul><p><strong>算法描述</strong></p><ol><li>将数组分为两个区域，排序区域和未排序区域，每一轮从未排序区域中取出第一个元素，插入到排序区域（需保证顺序）</li><li>重复以上步骤，直到整个数组有序</li></ol><blockquote><p><em>更形象的描述请参考：insertion_sort.html</em></p></blockquote><p><strong>算法实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 修改了代码与希尔排序一致</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(<span class="type">int</span>[] a)</span> &#123;</span><br><span class="line">    <span class="comment">// i 代表待插入元素的索引</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> a[i]; <span class="comment">// 代表待插入的元素值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i;</span><br><span class="line">        System.out.println(j);</span><br><span class="line">        <span class="keyword">while</span> (j &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (t &lt; a[j - <span class="number">1</span>]) &#123; <span class="comment">// j-1 是上一个元素索引，如果 &gt; t，后移</span></span><br><span class="line">                a[j] = a[j - <span class="number">1</span>];</span><br><span class="line">                j--;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// 如果 j-1 已经 &lt;= t, 则 j 就是插入位置</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        a[j] = t;</span><br><span class="line">        System.out.println(Arrays.toString(a) + <span class="string">&quot; &quot;</span> + j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>与选择排序比较</strong></p><ol><li>二者平均时间复杂度都是 $O(n^2)$</li><li>大部分情况下，插入都略优于选择</li><li>有序集合插入的时间复杂度为 $O(n)$</li><li>插入属于稳定排序算法，而选择属于不稳定排序</li></ol><p><strong>提示</strong></p><blockquote><p><em>插入排序通常被同学们所轻视，其实它的地位非常重要。小数据量排序，都会优先选择插入排序</em></p></blockquote><h2 id="5-希尔排序"><a href="#5-希尔排序" class="headerlink" title="5. 希尔排序"></a>5. 希尔排序</h2><p><strong>要求</strong></p><ul><li>能够用自己语言描述希尔排序算法</li></ul><p><strong>算法描述</strong></p><ol><li><p>首先选取一个间隙序列，如 (n&#x2F;2，n&#x2F;4 … 1)，n 为数组长度</p></li><li><p>每一轮将间隙相等的元素视为一组，对组内元素进行插入排序，目的有二</p><p>① 少量元素插入排序速度很快</p><p>② 让组内值较大的元素更快地移动到后方</p></li><li><p>当间隙逐渐减少，直至为 1 时，即可完成排序</p></li></ol><blockquote><p><em>更形象的描述请参考：shell_sort.html</em></p></blockquote><p><strong>算法实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">shell</span><span class="params">(<span class="type">int</span>[] a)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> a.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">gap</span> <span class="operator">=</span> n / <span class="number">2</span>; gap &gt; <span class="number">0</span>; gap /= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="comment">// i 代表待插入元素的索引</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> gap; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> a[i]; <span class="comment">// 代表待插入的元素值</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="keyword">while</span> (j &gt;= gap) &#123;</span><br><span class="line">                <span class="comment">// 每次与上一个间隙为 gap 的元素进行插入排序</span></span><br><span class="line">                <span class="keyword">if</span> (t &lt; a[j - gap]) &#123; <span class="comment">// j-gap 是上一个元素索引，如果 &gt; t，后移</span></span><br><span class="line">                    a[j] = a[j - gap];</span><br><span class="line">                    j -= gap;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123; <span class="comment">// 如果 j-1 已经 &lt;= t, 则 j 就是插入位置</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            a[j] = t;</span><br><span class="line">            System.out.println(Arrays.toString(a) + <span class="string">&quot; gap:&quot;</span> + gap);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>参考资料</strong></p><ul><li><a href="https://en.wikipedia.org/wiki/Shellsort">https://en.wikipedia.org/wiki/Shellsort</a></li></ul><h2 id="6-快速排序"><a href="#6-快速排序" class="headerlink" title="6. 快速排序"></a>6. 快速排序</h2><p><strong>要求</strong></p><ul><li>能够用自己语言描述快速排序算法</li><li>掌握手写单边循环、双边循环代码之一</li><li>能够说明快排特点</li><li>了解洛穆托与霍尔两种分区方案的性能比较</li></ul><p><strong>算法描述</strong></p><ol><li>每一轮排序选择一个基准点（pivot）进行分区<ol><li>让小于基准点的元素的进入一个分区，大于基准点的元素的进入另一个分区</li><li>当分区完成时，基准点元素的位置就是其最终位置</li></ol></li><li>在子分区内重复以上过程，直至子分区元素个数少于等于 1，这体现的是分而治之的思想 （<a href="https://en.wikipedia.org/wiki/Divide-and-conquer_algorithm">divide-and-conquer</a>）</li><li>从以上描述可以看出，一个关键在于分区算法，常见的有洛穆托分区方案、双边循环分区方案、霍尔分区方案</li></ol><blockquote><p><em>更形象的描述请参考：quick_sort.html</em></p></blockquote><p><strong>单边循环快排（lomuto 洛穆托分区方案）</strong></p><ol><li>选择最右元素作为基准点元素</li><li>j 指针负责找到比基准点小的元素，一旦找到则与 i 进行交换</li><li>i 指针维护小于基准点元素的边界，也是每次交换的目标索引</li><li>最后基准点与 i 交换，i 即为分区位置</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">quick</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> l, <span class="type">int</span> h)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= h) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> partition(a, l, h); <span class="comment">// p 索引值</span></span><br><span class="line">    quick(a, l, p - <span class="number">1</span>); <span class="comment">// 左边分区的范围确定</span></span><br><span class="line">    quick(a, p + <span class="number">1</span>, h); <span class="comment">// 左边分区的范围确定</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> l, <span class="type">int</span> h)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">pv</span> <span class="operator">=</span> a[h]; <span class="comment">// 基准点元素</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> l;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> l; j &lt; h; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[j] &lt; pv) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i != j) &#123;</span><br><span class="line">                swap(a, i, j);</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i != h) &#123;</span><br><span class="line">        swap(a, h, i);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(Arrays.toString(a) + <span class="string">&quot; i=&quot;</span> + i);</span><br><span class="line">    <span class="comment">// 返回值代表了基准点元素所在的正确索引，用它确定下一轮分区的边界</span></span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>双边循环快排（不完全等价于 hoare 霍尔分区方案）</strong></p><ol><li>选择最左元素作为基准点元素</li><li>j 指针负责从右向左找比基准点小的元素，i 指针负责从左向右找比基准点大的元素，一旦找到二者交换，直至 i，j 相交</li><li>最后基准点与 i（此时 i 与 j 相等）交换，i 即为分区位置</li></ol><p>要点</p><ol><li>基准点在左边，并且要先 j 后 i</li><li>while( <strong>i</strong> **&lt; j** &amp;&amp; a[j] &gt; pv ) j–</li><li>while ( <strong>i</strong> <strong>&lt; j</strong> &amp;&amp; a[i] <strong>&lt;&#x3D;</strong> pv ) i++</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">quick</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> l, <span class="type">int</span> h)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= h) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> partition(a, l, h);</span><br><span class="line">    quick(a, l, p - <span class="number">1</span>);</span><br><span class="line">    quick(a, p + <span class="number">1</span>, h);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> l, <span class="type">int</span> h)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">pv</span> <span class="operator">=</span> a[l];</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> l;</span><br><span class="line">    <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> h;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">        <span class="comment">// j 从右找小的</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt; j &amp;&amp; a[j] &gt; pv) &#123;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// i 从左找大的</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt; j &amp;&amp; a[i] &lt;= pv) &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(a, i, j);</span><br><span class="line">    &#125;</span><br><span class="line">    swap(a, l, j);</span><br><span class="line">    System.out.println(Arrays.toString(a) + <span class="string">&quot; j=&quot;</span> + j);</span><br><span class="line">    <span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>快排特点</strong></p><ol><li>平均时间复杂度是 $O(nlog_2⁡n )$，最坏时间复杂度 $O(n^2)$</li><li>数据量较大时，优势非常明显</li><li>属于不稳定排序</li></ol><p><strong>洛穆托分区方案 vs 霍尔分区方案</strong></p><ul><li>霍尔的移动次数平均来讲比洛穆托少3倍</li><li><a href="https://qastack.cn/cs/11458/quicksort-partitioning-hoare-vs-lomuto">https://qastack.cn/cs/11458/quicksort-partitioning-hoare-vs-lomuto</a></li></ul><blockquote><p><em><strong>补充代码说明</strong></em></p><ul><li>day01.sort.QuickSort3 演示了空穴法改进的双边快排，比较次数更少</li><li>day01.sort.QuickSortHoare 演示了霍尔分区的实现</li><li>day01.sort.LomutoVsHoare 对四种分区实现的移动次数比较</li></ul></blockquote><h2 id="7-ArrayList"><a href="#7-ArrayList" class="headerlink" title="7. ArrayList"></a>7. ArrayList</h2><p><strong>要求</strong></p><ul><li>掌握 ArrayList 扩容规则</li></ul><p><strong>扩容规则</strong></p><ol><li>ArrayList() 会使用长度为零的数组</li><li>ArrayList(int initialCapacity) 会使用指定容量的数组</li><li>public ArrayList(Collection&lt;? extends E&gt; c) 会使用 c 的大小作为数组容量</li><li>add(Object o) 首次扩容为 10，再次扩容为上次容量的 1.5 倍</li><li>addAll(Collection c) 没有元素时，扩容为 Math.max(10, 实际元素个数)，有元素时为 Math.max(原容量 1.5 倍, 实际元素个数)</li></ol><p>其中第 4 点必须知道，其它几点视个人情况而定</p><p><strong>提示</strong></p><ul><li>测试代码见 <code>day01.list.TestArrayList</code> ，这里不再列出</li><li>要<strong>注意</strong>的是，示例中用反射方式来更直观地反映 ArrayList 的扩容特征，但从 JDK 9 由于模块化的影响，对反射做了较多限制，需要在运行测试代码时添加 VM 参数 <code>--add-opens java.base/java.util=ALL-UNNAMED</code> 方能运行通过，后面的例子都有相同问题</li></ul><blockquote><p><em><strong>代码说明</strong></em></p><ul><li>day01.list.TestArrayList#arrayListGrowRule 演示了 add(Object) 方法的扩容规则，输入参数 n 代表打印多少次扩容后的数组长度</li></ul></blockquote><h2 id="8-Iterator"><a href="#8-Iterator" class="headerlink" title="8. Iterator"></a>8. Iterator</h2><p><strong>要求</strong></p><ul><li>掌握什么是 Fail-Fast、什么是 Fail-Safe</li></ul><p>Fail-Fast 与 Fail-Safe</p><ul><li>ArrayList 是 fail-fast 的典型代表，遍历的同时不能修改，尽快失败</li><li>CopyOnWriteArrayList 是 fail-safe 的典型代表，遍历的同时可以修改，原理是读写分离</li></ul><p><strong>提示</strong></p><ul><li>测试代码见 <code>day01.list.FailFastVsFailSafe</code>，这里不再列出</li></ul><h2 id="9-LinkedList"><a href="#9-LinkedList" class="headerlink" title="9. LinkedList"></a>9. LinkedList</h2><p><strong>要求</strong></p><ul><li>能够说清楚 LinkedList 对比 ArrayList 的区别，并重视纠正部分错误的认知</li></ul><p><strong>LinkedList</strong></p><ol><li>基于双向链表，无需连续内存</li><li>随机访问慢（要沿着链表遍历）</li><li>头尾插入删除性能高</li><li>占用内存多</li></ol><p><strong>ArrayList</strong></p><ol><li>基于数组，需要连续内存</li><li>随机访问快（指根据下标访问）</li><li>尾部插入、删除性能可以，其它部分插入、删除都会移动数据，因此性能会低</li><li>可以利用 cpu 缓存，局部性原理</li></ol><blockquote><p><em><strong>代码说明</strong></em></p><ul><li>day01.list.ArrayListVsLinkedList#randomAccess 对比随机访问性能</li><li>day01.list.ArrayListVsLinkedList#addMiddle 对比向中间插入性能</li><li>day01.list.ArrayListVsLinkedList#addFirst 对比头部插入性能</li><li>day01.list.ArrayListVsLinkedList#addLast 对比尾部插入性能</li><li>day01.list.ArrayListVsLinkedList#linkedListSize 打印一个 LinkedList 占用内存</li><li>day01.list.ArrayListVsLinkedList#arrayListSize 打印一个 ArrayList 占用内存</li></ul></blockquote><h2 id="10-HashMap"><a href="#10-HashMap" class="headerlink" title="10. HashMap"></a>10. HashMap</h2><p><strong>要求</strong></p><ul><li>掌握 HashMap 的基本数据结构</li><li>掌握树化</li><li>理解索引计算方法、二次 hash 的意义、容量对索引计算的影响</li><li>掌握 put 流程、扩容、扩容因子</li><li>理解并发使用 HashMap 可能导致的问题</li><li>理解 key 的设计</li></ul><h3 id="1）基本数据结构"><a href="#1）基本数据结构" class="headerlink" title="1）基本数据结构"></a>1）基本数据结构</h3><ul><li>1.7 数组 + 链表</li><li>1.8 数组 + （链表 | 红黑树）</li></ul><blockquote><p>更形象的演示，见资料中的 hash-demo.jar，运行需要 jdk14 以上环境，进入 jar 包目录，执行下面命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar --add-exports java.base/jdk.internal.misc=ALL-UNNAMED hash-demo.jar</span><br></pre></td></tr></table></figure></blockquote><h3 id="2）树化与退化"><a href="#2）树化与退化" class="headerlink" title="2）树化与退化"></a>2）树化与退化</h3><p><strong>树化意义</strong></p><ul><li>红黑树用来避免 DoS 攻击，防止链表超长时性能下降，树化应当是偶然情况，是保底策略</li><li>hash 表的查找，更新的时间复杂度是 $O(1)$，而红黑树的查找，更新的时间复杂度是 $O(log_2⁡n )$，TreeNode 占用空间也比普通 Node 的大，如非必要，尽量还是使用链表</li><li>hash 值如果足够随机，则在 hash 表内按泊松分布，在负载因子 0.75 的情况下，长度超过 8 的链表出现概率是 0.00000006，树化阈值选择 8 就是为了让树化几率足够小</li></ul><p><strong>树化规则</strong></p><ul><li>当链表长度超过树化阈值 8 时，先尝试扩容来减少链表长度，如果数组容量已经 &gt;&#x3D;64，才会进行树化</li></ul><p><strong>退化规则</strong></p><ul><li>情况1：在扩容时如果拆分树时，树元素个数 &lt;&#x3D; 6 则会退化链表</li><li>情况2：remove 树节点时，若 root、root.left、root.right、root.left.left 有一个为 null ，也会退化为链表</li></ul><h3 id="3）索引计算"><a href="#3）索引计算" class="headerlink" title="3）索引计算"></a>3）索引计算</h3><p><strong>索引计算方法</strong></p><ul><li>首先，计算对象的 hashCode()</li><li>再进行调用 HashMap 的 hash() 方法进行二次哈希<ul><li>二次 hash() 是为了综合高位数据，让哈希分布更为均匀</li></ul></li><li>最后 &amp; (capacity – 1) 得到索引</li></ul><p><strong>数组容量为何是 2 的 n 次幂</strong></p><ol><li>计算索引时效率更高：如果是 2 的 n 次幂可以使用位与运算代替取模</li><li>扩容时重新计算索引效率更高： hash &amp; oldCap &#x3D;&#x3D; 0 的元素留在原来位置 ，否则新位置 &#x3D; 旧位置 + oldCap</li></ol><p><strong>注意</strong></p><ul><li>二次 hash 是为了配合 <strong>容量是 2 的 n 次幂</strong> 这一设计前提，如果 hash 表的容量不是 2 的 n 次幂，则不必二次 hash</li><li><strong>容量是 2 的 n 次幂</strong> 这一设计计算索引效率更好，但 hash 的分散性就不好，需要二次 hash 来作为补偿，没有采用这一设计的典型例子是 Hashtable</li></ul><h3 id="4）put-与扩容"><a href="#4）put-与扩容" class="headerlink" title="4）put 与扩容"></a>4）put 与扩容</h3><p><strong>put 流程</strong></p><ol><li>HashMap 是懒惰创建数组的，首次使用才创建数组</li><li>计算索引（桶下标）</li><li>如果桶下标还没人占用，创建 Node 占位返回</li><li>如果桶下标已经有人占用<ol><li>已经是 TreeNode 走红黑树的添加或更新逻辑</li><li>是普通 Node，走链表的添加或更新逻辑，如果链表长度超过树化阈值，走树化逻辑</li></ol></li><li>返回前检查容量是否超过阈值，一旦超过进行扩容</li></ol><p><strong>1.7 与 1.8 的区别</strong></p><ol><li>链表插入节点时，1.7 是头插法，1.8 是尾插法</li><li>1.7 是大于等于阈值且没有空位时才扩容，而 1.8 是大于阈值就扩容</li><li>1.8 在扩容计算 Node 索引时，会优化</li></ol><p><strong>扩容（加载）因子为何默认是 0.75f</strong></p><ol><li>在空间占用与查询时间之间取得较好的权衡</li><li>大于这个值，空间节省了，但链表就会比较长影响性能</li><li>小于这个值，冲突减少了，但扩容就会更频繁，空间占用也更多</li></ol><h3 id="5）并发问题"><a href="#5）并发问题" class="headerlink" title="5）并发问题"></a>5）并发问题</h3><p><strong>扩容死链（1.7 会存在）</strong></p><p>1.7 源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(Entry[] newTable, <span class="type">boolean</span> rehash)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> newTable.length;</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e : table) &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">null</span> != e) &#123;</span><br><span class="line">            Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">            <span class="keyword">if</span> (rehash) &#123;</span><br><span class="line">                e.hash = <span class="literal">null</span> == e.key ? <span class="number">0</span> : hash(e.key);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> indexFor(e.hash, newCapacity);</span><br><span class="line">            e.next = newTable[i];</span><br><span class="line">            newTable[i] = e;</span><br><span class="line">            e = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>e 和 next 都是局部变量，用来指向当前节点和下一个节点</li><li>线程1（绿色）的临时变量 e 和 next 刚引用了这俩节点，还未来得及移动节点，发生了线程切换，由线程2（蓝色）完成扩容和迁移</li></ul><p><img src="/img/image-20210831084325075.png" alt="image-20210831084325075"></p><ul><li>线程2 扩容完成，由于头插法，链表顺序颠倒。但线程1 的临时变量 e 和 next 还引用了这俩节点，还要再来一遍迁移</li></ul><p><img src="/img/image-20210831084723383.png" alt="image-20210831084723383"></p><ul><li>第一次循环<ul><li>循环接着线程切换前运行，注意此时 e 指向的是节点 a，next 指向的是节点 b</li><li>e 头插 a 节点，注意图中画了两份 a 节点，但事实上只有一个（为了不让箭头特别乱画了两份）</li><li>当循环结束是 e 会指向 next 也就是 b 节点</li></ul></li></ul><p><img src="/img/image-20210831084855348.png" alt="image-20210831084855348"></p><ul><li>第二次循环<ul><li>next 指向了节点 a</li><li>e 头插节点 b</li><li>当循环结束时，e 指向 next 也就是节点 a</li></ul></li></ul><p><img src="/img/image-20210831085329449.png" alt="image-20210831085329449"></p><ul><li>第三次循环<ul><li>next 指向了 null</li><li>e 头插节点 a，<strong>a 的 next 指向了 b</strong>（之前 a.next 一直是 null），b 的 next 指向 a，死链已成</li><li>当循环结束时，e 指向 next 也就是 null，因此第四次循环时会正常退出</li></ul></li></ul><p><img src="/img/image-20210831085543224.png" alt="image-20210831085543224"></p><p><strong>数据错乱（1.7，1.8 都会存在）</strong></p><ul><li>代码参考 <code>day01.map.HashMapMissData</code>，具体调试步骤参考视频</li></ul><blockquote><p><em><strong>补充代码说明</strong></em></p><ul><li>day01.map.HashMapDistribution 演示 map 中链表长度符合泊松分布</li><li>day01.map.DistributionAffectedByCapacity 演示容量及 hashCode 取值对分布的影响<ul><li>day01.map.DistributionAffectedByCapacity#hashtableGrowRule 演示了 Hashtable 的扩容规律</li><li>day01.sort.Utils#randomArray 如果 hashCode 足够随机，容量是否是 2 的 n 次幂影响不大</li><li>day01.sort.Utils#lowSameArray 如果 hashCode 低位一样的多，容量是 2 的 n 次幂会导致分布不均匀</li><li>day01.sort.Utils#evenArray 如果 hashCode 偶数的多，容量是 2 的 n 次幂会导致分布不均匀</li><li>由此得出对于容量是 2 的 n 次幂的设计来讲，二次 hash 非常重要</li></ul></li><li>day01.map.HashMapVsHashtable 演示了对于同样数量的单词字符串放入 HashMap 和 Hashtable 分布上的区别</li></ul></blockquote><h3 id="6）key-的设计"><a href="#6）key-的设计" class="headerlink" title="6）key 的设计"></a>6）key 的设计</h3><p><strong>key 的设计要求</strong></p><ol><li>HashMap 的 key 可以为 null，但 Map 的其他实现则不然</li><li>作为 key 的对象，必须实现 hashCode 和 equals，并且 key 的内容不能修改（不可变）</li><li>key 的 hashCode 应该有良好的散列性</li></ol><p>如果 key 可变，例如修改了 age 会导致再次查询时查询不到</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashMapMutableKey</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        HashMap&lt;Student, Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="type">Student</span> <span class="variable">stu</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;张三&quot;</span>, <span class="number">18</span>);</span><br><span class="line">        map.put(stu, <span class="keyword">new</span> <span class="title class_">Object</span>());</span><br><span class="line"></span><br><span class="line">        System.out.println(map.get(stu));</span><br><span class="line"></span><br><span class="line">        stu.age = <span class="number">19</span>;</span><br><span class="line">        System.out.println(map.get(stu));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">        String name;</span><br><span class="line">        <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.name = name;</span><br><span class="line">            <span class="built_in">this</span>.age = age;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> age;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.age = age;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span> == o) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (o == <span class="literal">null</span> || getClass() != o.getClass()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> (Student) o;</span><br><span class="line">            <span class="keyword">return</span> age == student.age &amp;&amp; Objects.equals(name, student.name);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> Objects.hash(name, age);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>String 对象的 hashCode() 设计</strong></p><ul><li>目标是达到较为均匀的散列效果，每个字符串的 hashCode 足够独特</li><li>字符串中的每个字符都可以表现为一个数字，称为 $S_i$，其中 i 的范围是 0 ~ n - 1</li><li>散列公式为： $S_0∗31^{(n-1)}+ S_1∗31^{(n-2)}+ … S_i ∗ 31^{(n-1-i)}+ …S_{(n-1)}∗31^0$</li><li>31 代入公式有较好的散列特性，并且 31 * h 可以被优化为<ul><li>即 $32 ∗h -h $</li><li>即 $2^5  ∗h -h$</li><li>即 $h≪5  -h$</li></ul></li></ul><h2 id="11-单例模式"><a href="#11-单例模式" class="headerlink" title="11. 单例模式"></a>11. 单例模式</h2><p><strong>要求</strong></p><ul><li>掌握五种单例模式的实现方式</li><li>理解为何 DCL 实现时要使用 volatile 修饰静态变量</li><li>了解 jdk 中用到单例的场景</li></ul><p><strong>饿汉式</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton1</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (INSTANCE != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;单例对象不能重复创建&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;private Singleton1()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton1</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton1</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton1 <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">otherMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;otherMethod()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">readResolve</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>构造方法抛出异常是防止反射破坏单例</li><li><code>readResolve()</code> 是防止反序列化破坏单例</li></ul><p><strong>枚举饿汉式</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Singleton2</span> &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton2</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;private Singleton2()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getClass().getName() + <span class="string">&quot;@&quot;</span> + Integer.toHexString(hashCode());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton2 <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">otherMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;otherMethod()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>枚举饿汉式能天然防止反射、反序列化破坏单例</li></ul><p><strong>懒汉式</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton3</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton3</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;private Singleton3()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Singleton3</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Singleton3.class</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton3 <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (INSTANCE == <span class="literal">null</span>) &#123;</span><br><span class="line">            INSTANCE = <span class="keyword">new</span> <span class="title class_">Singleton3</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">otherMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;otherMethod()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>其实只有首次创建单例对象时才需要同步，但该代码实际上每次调用都会同步</li><li>因此有了下面的双检锁改进</li></ul><p><strong>双检锁懒汉式</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton4</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton4</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;private Singleton4()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">Singleton4</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="literal">null</span>; <span class="comment">// 可见性，有序性</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton4 <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (INSTANCE == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton4.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (INSTANCE == <span class="literal">null</span>) &#123;</span><br><span class="line">                    INSTANCE = <span class="keyword">new</span> <span class="title class_">Singleton4</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">otherMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;otherMethod()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为何必须加 volatile：</p><ul><li><code>INSTANCE = new Singleton4()</code> 不是原子的，分成 3 步：创建对象、调用构造、给静态变量赋值，其中后两步可能被指令重排序优化，变成先赋值、再调用构造</li><li>如果线程1 先执行了赋值，线程2 执行到第一个 <code>INSTANCE == null</code> 时发现 INSTANCE 已经不为 null，此时就会返回一个未完全构造的对象</li></ul><p><strong>内部类懒汉式</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton5</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton5</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;private Singleton5()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Holder</span> &#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="type">Singleton5</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton5</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton5 <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Holder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">otherMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;otherMethod()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>避免了双检锁的缺点</li></ul><p><strong>JDK 中单例的体现</strong></p><ul><li>Runtime 体现了饿汉式单例</li><li>Console 体现了双检锁懒汉式单例</li><li>Collections 中的 EmptyNavigableSet 内部类懒汉式单例</li><li>ReverseComparator.REVERSE_ORDER 内部类懒汉式单例</li><li>Comparators.NaturalOrderComparator.INSTANCE 枚举饿汉式单例</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>markdown的语法续</title>
      <link href="/2022/11/01/markdown%E8%AF%AD%E6%B3%95%E7%BB%AD/"/>
      <url>/2022/11/01/markdown%E8%AF%AD%E6%B3%95%E7%BB%AD/</url>
      
        <content type="html"><![CDATA[<h2 id="markdown语法续"><a href="#markdown语法续" class="headerlink" title="markdown语法续"></a>markdown语法续</h2><h3 id="Markdown引用"><a href="#Markdown引用" class="headerlink" title="Markdown引用"></a>Markdown引用</h3><p>在引用的文字之前加 &gt; 即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">示例：</span><br><span class="line">   &gt;这是引用的内容</span><br><span class="line"> </span><br></pre></td></tr></table></figure><h4 id="效果演示"><a href="#效果演示" class="headerlink" title="效果演示"></a>效果演示</h4><blockquote><p>这是效果演示</p></blockquote><h3 id="Markdown图片"><a href="#Markdown图片" class="headerlink" title="Markdown图片"></a>Markdown图片</h3><p>Markdown 图片语法格式如下</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">!   <span class="selector-attr">[alt 属性文本]</span>(图片地址)</span><br><span class="line"></span><br><span class="line">!   <span class="selector-attr">[alt 属性文本]</span>(图片地址 &quot;可选标题&quot;)</span><br></pre></td></tr></table></figure><ul><li><p>开头一个感叹号 !</p></li><li><p>接着一个方括号，里面放上图片的替代文字</p></li><li><p>接着一个普通括号，里面放上图片的网址，最后还可以用引号包住并加上选择性的 ‘title’ 属性的文字。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">示例：![图片]（https/xxxxxxxx图片地址）</span><br></pre></td></tr></table></figure></li></ul><h3 id="Markedown链接"><a href="#Markedown链接" class="headerlink" title="Markedown链接"></a>Markedown链接</h3><p>Markdown 链接的语法格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> [链接名称](链接地址)</span><br><span class="line">或者</span><br><span class="line"> &lt;链接地址&gt;</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这个是一个链接[百度](https://www.baidu.com)</span><br></pre></td></tr></table></figure><p>效果如下：</p><p>这个是一个链接<a href="https://www.baidu.com/">百度</a></p><h3 id="Markdown表格"><a href="#Markdown表格" class="headerlink" title="Markdown表格"></a>Markdown表格</h3><p>Markdown 制作表格使用 | 来分隔不同的单元格，使用 - 来分隔表头和其他行。</p><p>语法格式:</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> |<span class="params">  表头   </span>| 表头  |<span class="params"> 表头</span>|</span><br><span class="line"> |<span class="params">  :---  </span>| <span class="symbol">:--</span>:  |<span class="params">---:</span></span><br><span class="line"><span class="params"> </span>| 单元格  |<span class="params"> 单元格 </span>| 单元格|<span class="params"></span></span><br><span class="line"><span class="params"> </span>| 单元格  |<span class="params"> 单元格 </span>| 单元格|<span class="params"></span></span><br><span class="line"><span class="params"> </span></span><br><span class="line"><span class="params"> 第二行分割表头和内容。</span></span><br><span class="line"><span class="params"> - 有一个就行，为了对齐，多加了几个</span></span><br><span class="line"><span class="params"> 文字默认居左</span></span><br><span class="line"><span class="params">-两边加：表示文字居中</span></span><br><span class="line"><span class="params">-右边加：表示文字居右</span></span><br></pre></td></tr></table></figure><p>效果如下</p><table><thead><tr><th align="left">表头</th><th align="center">表头</th><th align="right">表头</th></tr></thead><tbody><tr><td align="left">单元格</td><td align="center">单元格</td><td align="right">单元格</td></tr><tr><td align="left">单元格</td><td align="center">单元格</td><td align="right">单元格</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>markdown的基本语法</title>
      <link href="/2022/11/01/markdown%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"/>
      <url>/2022/11/01/markdown%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="markdown的基本语法"><a href="#markdown的基本语法" class="headerlink" title="markdown的基本语法"></a>markdown的基本语法</h1><h2 id="markdown语法常用的功能"><a href="#markdown语法常用的功能" class="headerlink" title="markdown语法常用的功能"></a>markdown语法常用的功能</h2><table><thead><tr><th>功能</th><th>快捷键</th></tr></thead><tbody><tr><td>加粗</td><td>Ctrl + B</td></tr><tr><td>斜体</td><td>Ctrl + I</td></tr><tr><td>引用</td><td>Ctrl + Q</td></tr><tr><td>插入链接</td><td>Ctrl + L</td></tr><tr><td>插入代码</td><td>Ctrl + K</td></tr><tr><td>插入图片</td><td>Ctrl + G</td></tr><tr><td>提升标题</td><td>Ctrl + H</td></tr><tr><td>有序列表</td><td>Ctrl + O</td></tr><tr><td>无序列表</td><td>Ctrl + U</td></tr><tr><td>横线</td><td>Ctrl + R</td></tr><tr><td>撤销</td><td>Ctrl + Z</td></tr><tr><td>重做</td><td>Ctrl + Y</td></tr></tbody></table><h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><h3 id="字体设置斜体、粗体、删除线（括号里面没有空格只是为了显示效果）"><a href="#字体设置斜体、粗体、删除线（括号里面没有空格只是为了显示效果）" class="headerlink" title="字体设置斜体、粗体、删除线（括号里面没有空格只是为了显示效果）"></a>字体设置斜体、粗体、删除线（括号里面没有空格只是为了显示效果）</h3><table><thead><tr><th>功能</th><th>效果</th></tr></thead><tbody><tr><td>正常文字</td><td>正常文字</td></tr><tr><td>倾斜文字 （ * 加文字 * ）</td><td><em>倾斜文字</em></td></tr><tr><td>加粗文字（ ** 加文字 **）</td><td><strong>加粗文字</strong></td></tr><tr><td>文字倾斜加粗 （* * * 加文字 * * *）</td><td><em><strong>文字倾斜加粗</strong></em></td></tr><tr><td>下划线文字 （~~ 加文字 ~~）</td><td><del>下划线文字</del></td></tr></tbody></table><h3 id="分级标题"><a href="#分级标题" class="headerlink" title="分级标题"></a>分级标题</h3><table><thead><tr><th>功能</th></tr></thead><tbody><tr><td>一级标题（#一级标题）</td></tr><tr><td>二级标题（##二级标题）</td></tr><tr><td>三级标题（##三级标题）</td></tr><tr><td>…..</td></tr><tr><td>…..</td></tr></tbody></table><h3 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h3><p>你可以在一行中用三个以上的星号(*)、减号(-)、底线(_)来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格。</p><p>效果展示</p><hr><hr><h3 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h3><p>对于程序员来说这个功能是必不可少的，插入程序代码的方式有两种，一种是利用缩进(tab), 另一种是利用英文“&#96;”符号（一般在ESC键下方，和~同一个键）</p><p>这个一个例子 <code>效果</code></p><p><strong>多行代码块与语法高亮</strong>：在需要高亮的代码块的前一行及后一行使用三个单反引号“&#96;”包裹，就可以了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">include&lt;stdio.h&gt;</span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line"><span class="title function_">printf</span><span class="params">(<span class="string">&quot;hello word&quot;</span>)</span>;</span><br></pre></td></tr></table></figure><p>代码块里面包含html代码在代码区块里面， &amp; 、 &lt; 和 &gt; 会自动转成 HTML 实体，这样的方式让你非常容易使用 Markdown 插入范例用的 HTML 原始码，只需要复制贴上，剩下的 Markdown 都会帮你处理。</p><h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><p>无序列表</p><p>使用 *，+，- 表示无序列表。<br>注意：符号后面一定要有一个空格，起到缩进的作用。</p><ul><li>无序列表</li><li>无序列表</li></ul><p>有序列表<br>使用数字和一个英文句点表示有序列表。<br>注意：英文句点后面一定要有一个空格，起到缩进的作用。</p><ol><li>有序列表</li><li>有序列表</li></ol><p>无序列表和有序列表同时使用</p><ul><li><ol><li>列表合并使用</li></ol></li></ul><p>列表和其它要素混合使用<br>列表不光可以单独使用，也可以使用其他的 Markdown 语法，包括标题、引用、代码区块等。</p><p>注意：</p><p>（1）加粗效果不能直接用于列表标题里面，但是可以嵌套在列表里面混合使用。<br>（2）列表中包含代码块（前面加2个tab或者8个空格，并且需要空一行，否则不显示）。</p>]]></content>
      
      
      <categories>
          
          <category> markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> markdown </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
